{"version":3,"file":"lang-markdown-CbmGsfoc.js","sources":["../../../../../../node_modules/@codemirror/lang-markdown/dist/index.js"],"sourcesContent":["import { EditorSelection, countColumn, Prec, EditorState } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, indentUnit, LanguageSupport } from '@codemirror/language';\nimport { CompletionContext } from '@codemirror/autocomplete';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html, htmlCompletionSource } from '@codemirror/lang-html';\nimport { NodeProp } from '@lezer/common';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\nconst headingProp = /*@__PURE__*/new NodeProp();\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null || isList(type) ? undefined\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/headingProp.add(isHeading),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction isHeading(type) {\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n    return match ? +match[1] : undefined;\n}\nfunction isList(type) {\n    return type.name == \"OrderedList\" || type.name == \"BulletList\";\n}\nfunction findSectionEnd(headerNode, level) {\n    let last = headerNode;\n    for (;;) {\n        let next = last.nextSibling, heading;\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\n            break;\n        last = next;\n    }\n    return last.to;\n}\nconst headerIndent = /*@__PURE__*/foldService.of((state, start, end) => {\n    for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\n        if (node.from < start)\n            break;\n        let heading = node.type.prop(headingProp);\n        if (heading == null)\n            continue;\n        let upto = findSectionEnd(node, heading);\n        if (upto > end)\n            return { from: end, to: upto };\n    }\n    return null;\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, [], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n        props: [\n            /*@__PURE__*/foldNodeProp.add({\n                Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [], context = [];\n    for (let cur = node; cur; cur = cur.parent) {\n        if (cur.name == \"FencedCode\")\n            return context;\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\")\n            nodes.push(cur);\n    }\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"Blockquote\" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^( *)\\d+([.)])( *)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^( *)([-+*])( {1,4}\\[[ xX]\\])?( +)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\nfunction normalizeIndent(content, state) {\n    let blank = /^[ \\t]*/.exec(content)[0].length;\n    if (!blank || state.facet(indentUnit) != \"\\t\")\n        return content;\n    let col = countColumn(content, 4, blank);\n    let space = \"\";\n    for (let i = col; i > 0;) {\n        if (i >= 4) {\n            space += \"\\t\";\n            i -= 4;\n        }\n        else {\n            space += \" \";\n            i--;\n        }\n    }\n    return space + content.slice(blank);\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from, -1) && !markdownLanguage.isActiveAt(state, range.from, 1))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            let first = inner.node.firstChild, second = inner.node.getChild(\"ListItem\", \"ListItem\");\n            // Not second item or blank line before: delete a level of markup\n            if (first.to >= pos || second && second.to < pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move second item down, making tight two-item list non-tight\n                let insert = blankLine(context, state, line);\n                return { range: EditorSelection.cursor(pos + insert.length + 1),\n                    changes: { from: line.from, insert: insert + state.lineBreak } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = normalizeIndent(insert, state);\n        if (nonTightList(inner.node, state.doc))\n            insert = blankLine(context, state, line) + state.lineBreak + insert;\n        changes.push({ from, to: pos, insert: state.lineBreak + insert });\n        return { range: EditorSelection.cursor(from + insert.length + 1), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction nonTightList(node, doc) {\n    if (node.name != \"OrderedList\" && node.name != \"BulletList\")\n        return false;\n    let first = node.firstChild, second = node.getChild(\"ListItem\", \"ListItem\");\n    if (!second)\n        return false;\n    let line1 = doc.lineAt(first.to), line2 = doc.lineAt(second.from);\n    let empty = /^[\\s>]*$/.test(line1.text);\n    return line1.number + (empty ? 0 : 1) < line2.number;\n}\nfunction blankLine(context, state, line) {\n    let insert = \"\";\n    for (let i = 0, e = context.length - 2; i <= e; i++) {\n        insert += context[i].blank(i < e\n            ? countColumn(line.text, 4, context[i + 1].from) - insert.length\n            : null, i < e);\n    }\n    return normalizeIndent(insert, state);\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd &&\n                    // Only apply this if we're on the line that has the\n                    // construct's syntax, or there's only indentation in the\n                    // target range\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) {\n                        let insert = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));\n                        if (start == line.from)\n                            insert = normalizeIndent(insert, state);\n                        return { range: EditorSelection.cursor(start + insert.length),\n                            changes: { from: start, to: line.from + inner.to, insert } };\n                    }\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true, htmlTagLanguage = htmlNoMatch } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlTagLanguage.support, headerIndent], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlTagLanguage.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    let lang = mkLang(parser.configure(extensions));\n    if (completeHTMLTags)\n        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));\n    return new LanguageSupport(lang, support);\n}\nfunction htmlTagCompletion(context) {\n    let { state, pos } = context, m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\n    if (!m)\n        return null;\n    let tree = syntaxTree(state).resolveInner(pos, -1);\n    while (tree && !tree.type.isTop) {\n        if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" ||\n            tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\")\n            return null;\n        tree = tree.parent;\n    }\n    return {\n        from: pos - m[0].length, to: pos,\n        options: htmlTagCompletions(),\n        validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nlet _tagCompletions = null;\nfunction htmlTagCompletions() {\n    if (_tagCompletions)\n        return _tagCompletions;\n    let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));\n    return _tagCompletions = result ? result.options : [];\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"],"names":["data","defineLanguageFacet","headingProp","NodeProp","commonmark","parser","foldNodeProp","type","isHeading","isList","tree","state","indentNodeProp","languageDataProp","match","findSectionEnd","headerNode","level","last","next","heading","headerIndent","foldService","start","end","node","syntaxTree","upto","mkLang","Language","commonmarkLanguage","extended","GFM","Subscript","Superscript","Emoji","markdownLanguage","getCodeParser","languages","defaultLanguage","info","found","LanguageDescription","ParseContext","Context","from","to","spaceBefore","spaceAfter","item","maxWidth","trailing","result","i","doc","add","number","itemNumber","getContext","nodes","context","cur","line","startPos","after","len","renumberList","changes","offset","prev","normalizeIndent","content","blank","indentUnit","col","countColumn","space","insertNewlineContinueMarkup","dispatch","dont","range","pos","inner","emptyLine","first","second","delTo","insert","EditorSelection","blankLine","prevLine","quoted","continued","e","nonTightList","isMark","line1","line2","empty","contextNodeForDelete","scan","deleteMarkupBackward","spaceEnd","markdownKeymap","htmlNoMatch","html","markdown","config","codeLanguages","defaultCodeLanguage","addKeymap","completeHTMLTags","htmlTagLanguage","MarkdownParser","extensions","support","defaultCode","LanguageSupport","codeParser","parseCode","Prec","keymap","lang","htmlTagCompletion","m","htmlTagCompletions","_tagCompletions","htmlCompletionSource","CompletionContext","EditorState"],"mappings":"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","x_google_ignoreList":[0]}
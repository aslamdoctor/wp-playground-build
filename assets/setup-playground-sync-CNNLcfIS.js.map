{"version":3,"file":"setup-playground-sync-CNNLcfIS.js","sources":["../../../../../packages/playground/sync/src/sync-mu-plugin.php?raw","../../../../../packages/playground/sync/src/sql.ts","../../../../../packages/playground/sync/src/fs.ts","../../../../../packages/playground/sync/src/transports.ts","../../../../../packages/playground/sync/src/middleware/logger.ts","../../../../../packages/playground/sync/src/middleware/marshall-site-url.ts","../../../../../packages/playground/sync/src/middleware/prune-sql-queries.ts","../../../../../packages/playground/sync/src/middleware/hydrate-fs-writes.ts","../../../../../packages/playground/sync/src/setup-playground-sync.ts"],"sourcesContent":["export default \"<?php\\n\\n/**\\n * Forces SQLite to use monotonically increasing values for every \\n * autoincrement column. For example, if sqlite_sequence says that\\n * `wp_posts` has seq=10, the next row will get id=11.\\n * \\n * ## How to use\\n * \\n * * Call this function when starting the synchronized session.\\n * * Call this function again every time a new autoincrement field is created.\\n * \\n * ## Doesn't SQLite already do that?\\n * \\n * Sadly, no.\\n * \\n * SQLite always uses max(id) + 1 for the next autoincrement value\\n * regardless of the seq value stored in sqlite_sequence.\\n * \\n * This means trouble. Receiving a remote row with a high ID like 450000 \\n * changes the next locally assigned ID from 11 to 450001. This is a \\n * certain way to get ID conflicts between peers.\\n * \\n * Fortunately, we can create a trigger to force SQLite to use ID=seq+1\\n * instead of its default algorithm.\\n * \\n * ## Implementation\\n *\\n * We override the default AUTOINCREMENT algorithm with our own.\\n * \\n * Instead of sqlite_sequence, we use a custom playground_sequence table\\n * to store the next available ID for every table/column pair.\\n * \\n * We use an AFTER INSERT trigger to reassign the AUTOINCREMENT value to the\\n * next available value in the playground_sequence table.\\n * \\n * The last_insert_id() function still returns the original ID assigned by SQLite,\\n * so we introduce a new 'sqlite_last_insert_id' filter in class-wp-sqlite-translator.php\\n * and use it to give WordPress the correct last_insert_id.\\n * \\n * ## Alternatives considered\\n * \\n * * Using a custom DEFAULT value for the PRIMARY KEY column – SQLite doesn't support it\\n * * Update ID with a trigger BEFORE INSERT – SQLite doesn't support it\\n * * Use INSTEAD OF triggers on a table – they only work with views\\n * * Read the entire row after INSERTing it, and reconstruct the query – too complex and be error-prone\\n * * Replace the ID column with a custom, non-autoincrement one – that's complex in SQLite plus it could mess up WP core db migrations\\n * \\n * @param int|null $local_id_offset The offset to use for the first AUTOINCREMENT value.\\n * @return void\\n */\\nfunction playground_sync_override_autoincrement_algorithm($local_id_offset = null, $known_autoincrement_values = null)\\n{\\n    if (null !== $local_id_offset) {\\n        if (get_option('playground_id_offset')) {\\n            // For now, the initial offset may only be set once.\\n            // Changing it on the fly has no clear benefits, but\\n            // it would be a pain to implement correctly and would\\n            // introduce inconvenient gaps in the ID sequence.\\n            throw new Exception(\\n                \\\"playground_sync_override_autoincrement_algorithm() was called twice with different \\\" .\\n                \\\"values for \\\\$local_id_offset. This is not supported.\\\"\\n            );\\n        }\\n        // Store the default autoincrement offset for the current peer:\\n        update_option('playground_id_offset', $local_id_offset);\\n    }\\n\\n    if (null !== $known_autoincrement_values) {\\n        foreach ($known_autoincrement_values as $table_name => $seq) {\\n            $stmt = $GLOBALS['@pdo']->prepare(<<<SQL\\n                INSERT OR REPLACE INTO playground_sequence VALUES (:table_name, :seq)\\n            SQL\\n            );\\n            $stmt->execute([':table_name' => $table_name, ':seq' => $seq]);\\n        }\\n    }\\n\\n    // Insert all the AUTOINCREMENT table/column pairs that are not\\n    // already tracked in playground_sequence:\\n    $pdo = $GLOBALS['@pdo'];\\n    $stmt = $pdo->prepare(<<<SQL\\n        INSERT INTO playground_sequence \\n        SELECT table_name, :seq FROM autoincrement_columns\\n        WHERE 1=1 -- Needed because of the ambiguous ON clause, see https://sqlite.org/lang_upsert.html\\n        ON CONFLICT(table_name) DO NOTHING;\\n    SQL);\\n    $stmt->execute([':seq' => get_option('playground_id_offset')]);\\n\\n    // Create any missing AFTER INSERT triggers:\\n    foreach (playground_sync_get_autoincrement_columns() as $table => $column) {\\n        $pdo->query(<<<SQL\\n            CREATE TRIGGER IF NOT EXISTS \\n            force_seq_autoincrement_on_{$table}_{$column}\\n            AFTER INSERT ON $table\\n            FOR EACH ROW\\n            WHEN\\n                -- Don't run this trigger when we're replaying queries from another peer\\n                (SELECT value FROM playground_variables WHERE name = 'is_replaying') = 'no'\\n            BEGIN\\n                -- Update the inserted row with the next available ID\\n                UPDATE {$table} SET {$column} = (\\n                    SELECT seq FROM playground_sequence WHERE table_name = '{$table}'\\n                ) + 1 WHERE rowid = NEW.rowid;\\n                -- Record the ID that was just assigned\\n                UPDATE playground_sequence SET seq = seq + 1 WHERE table_name = '{$table}';\\n            END;\\n        SQL);\\n    }\\n}\\n\\n/**\\n * Same as playground_sync_override_autoincrement_algorithm(), only runs after\\n * queries that modify the database schema, such as ALTER TABLE and CREATE TABLE.\\n * \\n * @param string $query MySQL Query\\n * @param string $query_type CREATE TABLE, ALTER TABLE, etc.\\n * @return void\\n */\\nfunction playground_sync_override_autoincrement_on_newly_created_fields($query, $query_type)\\n{\\n    if ($query_type === 'CREATE TABLE' || $query_type === 'ALTER TABLE') {\\n        playground_sync_override_autoincrement_algorithm();\\n    }\\n}\\n\\n/**\\n * Ensures that $wpdb gets the actual ID assigned to the last inserted row\\n * as its $wpdb->insert_id value.\\n * \\n * The AFTER INSERT trigger overrides AUTOINCREMENT IDs provided by SQLite.\\n * However, the SQLite integration plugin uses the builtin last_insert_id() \\n * SQLite function which returns the original ID assigned by SQLite. That ID\\n * is no longer in the database, but there is no way to override it at the\\n * database level.\\n * \\n * We must, therefore, act at the application level. This function replaces\\n * the stale ID with the one assigned to the row by the AFTER INSERT trigger.\\n * \\n * @see playground_autoincrement_override_algorithm\\n * \\n * @param int $sqlite_last_insert_id The now-stale ID returned by last_insert_id().\\n * @param string $table_name The table name.\\n * @return int The ID actually stored in the last inserted row.\\n */\\nfunction playground_sync_get_actual_last_insert_id($sqlite_last_insert_id, $table_name)\\n{\\n    // Get the last relevant value from playground_sequence:\\n    $stmt = $GLOBALS['@pdo']->prepare(\\\"SELECT * FROM playground_sequence WHERE table_name = :table_name\\\");\\n    $stmt->execute([':table_name' => $table_name]);\\n    $result = $stmt->fetch(PDO::FETCH_ASSOC);\\n    if ($result) {\\n        return $result['seq'];\\n    }\\n    return $sqlite_last_insert_id;\\n}\\n/**\\n * Returns all auto-increment columns keyed by their table name.\\n *\\n * @return array A [$table => $column] array of all auto-increment columns.\\n */\\nfunction playground_sync_get_autoincrement_columns()\\n{\\n    return $GLOBALS['@pdo']\\n        ->query('SELECT table_name, column_name FROM autoincrement_columns')\\n        ->fetchAll(PDO::FETCH_KEY_PAIR);\\n}\\n\\n/**\\n * Ensures that all the tables and views required by the synchronization\\n * process exist.\\n *\\n * This function may be called multiple times without causing an error.\\n * \\n * @return void\\n */\\nfunction playground_sync_ensure_required_tables()\\n{\\n    $pdo = $GLOBALS['@pdo'];\\n    /** @var PDO $pdo */\\n    $pdo->query(\\\"CREATE TABLE IF NOT EXISTS playground_variables (\\n        name TEXT PRIMARY KEY,\\n        value TEXT\\n    );\\\");\\n    $pdo->query(\\\"CREATE TABLE IF NOT EXISTS playground_sequence (\\n        table_name varchar(255),\\n        seq int default 0 not null,\\n        PRIMARY KEY (table_name)\\n    )\\\");\\n\\n    $pdo->query(<<<SQL\\n    CREATE VIEW IF NOT EXISTS autoincrement_columns AS \\n        SELECT DISTINCT m.name as 'table_name', ti.name AS 'column_name'\\n            FROM\\n                sqlite_schema AS m,\\n                pragma_table_info(m.name) AS ti\\n            INNER JOIN sqlite_sequence seq ON seq.name = m.name\\n            WHERE\\n                m.type = 'table' AND\\n                m.name NOT LIKE 'sqlite_%' AND\\n                ti.pk = 1 AND -- pk stands for primary key\\n                ti.type LIKE '%INTEGER%'\\n            ORDER BY 1\\n    ;\\n    SQL\\n    );\\n}\\n\\n/**\\n * Emits a SQL query to the JavaScript side of the Playground Sync\\n * feature.\\n *\\n * If the query is an INSERT and the local database implicitly assigned\\n * a primary key, this function will send the inserted rows instead of\\n * the original query. We do this because the original query doesn't\\n * give the remote peer enough information to reconstruct the row.\\n *\\n * @param string $query The SQL query to emit.\\n * @param string $query_type The type of the SQL query (e.g. SELECT, INSERT, UPDATE, DELETE).\\n * @param string $table_name The name of the table affected by the SQL query.\\n * @param array $insert_columns The columns affected by the INSERT query.\\n * @param int $last_insert_id The ID of the last inserted row (if applicable).\\n * @param int $affected_rows The number of affected rows.\\n * @return void\\n */\\nfunction playground_sync_emit_mysql_query($query, $query_type, $table_name, $insert_columns, $last_insert_id, $affected_rows)\\n{\\n    // Is it an INSERT that generated a new autoincrement value?\\n    static $auto_increment_columns = null;\\n    if ($auto_increment_columns === null) {\\n        $auto_increment_columns = playground_sync_get_autoincrement_columns();\\n    }\\n    $auto_increment_column = $auto_increment_columns[$table_name] ?? null;\\n\\n    $was_pk_generated = $query_type === 'INSERT' && $auto_increment_column && !in_array($auto_increment_column, $insert_columns, true);\\n    if ($was_pk_generated) {\\n        // If so, get the inserted rows.\\n        // It could be more than one, e.g. if the query was `INSERT INTO ... SELECT ...`.\\n        $rows = $GLOBALS['@pdo']->query(<<<SQL\\n            SELECT * FROM $table_name\\n            WHERE $auto_increment_column <= $last_insert_id\\n            ORDER BY $auto_increment_column DESC\\n            LIMIT $affected_rows\\n        SQL\\n        )->fetchAll(PDO::FETCH_ASSOC);\\n        // Finally, send each row to the JavaScript side.\\n        foreach ($rows as $row) {\\n            $row[$auto_increment_column] = (int) $row[$auto_increment_column];\\n            post_message_to_js(json_encode([\\n                'type' => 'sql',\\n                'subtype' => 'reconstruct-insert',\\n                'row' => $row,\\n                'query_type' => $query_type,\\n                'table_name' => $table_name,\\n                'auto_increment_column' => $auto_increment_column,\\n                'last_insert_id' => $last_insert_id,\\n            ]));\\n        }\\n        return;\\n    }\\n\\n    // Otherwise, simply send the query to the JavaScript side.\\n    post_message_to_js(json_encode([\\n        'type' => 'sql',\\n        'subtype' => 'replay-query',\\n        'query' => $query,\\n        'query_type' => $query_type,\\n        'table_name' => $table_name,\\n        'auto_increment_column' => $auto_increment_column,\\n        'last_insert_id' => $last_insert_id,\\n    ]));\\n}\\n\\n/**\\n * Emits a transaction-related query to the JavaScript side of the \\n * Playground Sync.\\n *\\n * @param string $command The SQL statement (one of \\\"START TRANSACTION\\\", \\\"COMMIT\\\", \\\"ROLLBACK\\\").\\n * @param bool $success Whether the SQL statement was successful or not.\\n * @param int $nesting_level The nesting level of the transaction.\\n * @return void\\n */\\nfunction playground_sync_emit_transaction_query($command, $success, $nesting_level)\\n{\\n    // If we're in a nested transaction, SQLite won't really\\n    // persist anything to the database. Let's ignore it and wait\\n    // for the outermost transaction to finish.\\n    if (0 !== $nesting_level) {\\n        return;\\n    }\\n\\n    post_message_to_js(json_encode([\\n        'type' => 'sql',\\n        'subtype' => 'transaction',\\n        'success' => $success,\\n        'command' => $command,\\n    ]));\\n}\\n\\n/**\\n * Replays a list of SQL queries on a local database.\\n * \\n * @param array $queries An array of SQL queries to run.\\n * @return void\\n */\\nfunction playground_sync_replay_sql_journal($queries)\\n{\\n    global $wpdb;\\n    $pdo = $GLOBALS['@pdo'];\\n    foreach ($queries as $query) {\\n        try {\\n            // If another peer assigned an autoincrement value, we don't get\\n            // the query but a key/value representation of the inserted row.\\n            // Let's reconstruct the INSERT query using that data.\\n            // Because we use prepared statements here, we cannot simply reconstruct the\\n            // insert on the other end.\\n            if ($query['subtype'] === 'reconstruct-insert') {\\n                $table_name = $query['table_name'];\\n                $columns = implode(', ', array_keys($query['row']));\\n                $placeholders = ':' . implode(', :', array_keys($query['row']));\\n\\n                $stmt = $pdo->prepare(\\\"INSERT INTO $table_name ($columns) VALUES ($placeholders)\\\");\\n                $stmt->execute($query['row']);\\n            } else {\\n                $wpdb->query($query['query']);\\n            }\\n        } catch (PDOException $e) {\\n            // Let's ignore errors related to UNIQUE constraints violation for now.\\n            // They often relate to transient data that is not relevant to the\\n            // synchronization process.\\n            //\\n            // This probably means we won't catch some legitimate issues.\\n            // Let's keep an eye on this and see if we can eventually remove it.\\n            // In the future, let's implement pattern matching on queries and\\n            // prevent synchronizing transient data. \\n\\n            // SQLSTATE[23000]: Integrity constraint violation: 19 UNIQUE constraint failed\\n            if ($e->getCode() === \\\"23000\\\") {\\n                continue;\\n            }\\n            throw $e;\\n        }\\n    }\\n}\\n\\n/**\\n * Sets up WordPress for a synchronized exchange of SQLite queries.\\n * \\n * @return void\\n */\\nfunction playground_sync_start()\\n{\\n    playground_sync_ensure_required_tables();\\n\\n    // Don't override the AUTOINCREMENT IDs when replaying queries from \\n    // another peer. The AFTER INSERT trigger will abstain from running\\n    // when `is_replaying` is set to \\\"yes\\\".\\n    $pdo = $GLOBALS['@pdo'];\\n    $stmt = $pdo->prepare(\\\"INSERT OR REPLACE INTO playground_variables VALUES ('is_replaying', :is_replaying);\\\");\\n    $is_replaying = defined('REPLAYING_SQL') && REPLAYING_SQL;\\n    $stmt->execute([':is_replaying' => $is_replaying ? 'yes' : 'no']);\\n\\n    // Don't emit SQL queries we're just replaying from another peer.\\n    if (!$is_replaying) {\\n        add_filter('sqlite_last_insert_id', 'playground_sync_get_actual_last_insert_id', 0, 2);\\n\\n        // Listens for SQL queries executed by WordPress and emit them to the JS side:\\n        // @todo – consider using SQLite's \\\"update hook\\\" instead of \\\"sqlite_post_query\\\" WordPress hook here.\\n        add_action('sqlite_translated_query_executed', 'playground_sync_emit_mysql_query', -1000, 6);\\n        add_action('sqlite_transaction_query_executed', 'playground_sync_emit_transaction_query', -1000, 3);\\n    }\\n\\n    add_filter('sqlite_translated_query_executed', 'playground_sync_override_autoincrement_on_newly_created_fields', -1000, 2);\\n}\\n\\nplayground_sync_start();\"","import type { PHPResponse, UniversalPHP } from '@php-wasm/universal';\nimport { logger } from '@php-wasm/logger';\n/** @ts-ignore */\nimport logSqlQueries from './sync-mu-plugin.php?raw';\nimport { phpVar, phpVars } from '@php-wasm/util';\n\nexport async function installSqlSyncMuPlugin(playground: UniversalPHP) {\n\tif (!(await playground.fileExists('/wordpress/wp-content/mu-plugins'))) {\n\t\tawait playground.mkdir('/wordpress/wp-content/mu-plugins');\n\t}\n\tawait playground.writeFile(\n\t\t`/wordpress/wp-content/mu-plugins/sync-mu-plugin.php`,\n\t\tlogSqlQueries\n\t);\n}\n\nexport async function overrideAutoincrementSequences(\n\tplayground: UniversalPHP,\n\tbaseOffset: number,\n\tknownIds: Record<string, number> = {}\n) {\n\tconst initializationResult = await playground.run({\n\t\tcode: `<?php\n        require '/wordpress/wp-load.php';\n        playground_sync_override_autoincrement_algorithm(\n\t\t\t${phpVar(baseOffset)},\n\t\t\t${phpVar(knownIds)}\n\t\t);\n\t    `,\n\t});\n\tassertEmptyOutput(initializationResult, 'Initialization failed.');\n\n\t// Get the current autoincrement ID value for all tables\n\tconst response = await playground.run({\n\t\tcode: `<?php\n        require '/wordpress/wp-load.php';\n\t\t$data = $GLOBALS['@pdo']\n\t\t\t->query('SELECT * FROM playground_sequence')\n\t\t\t->fetchAll(PDO::FETCH_KEY_PAIR);\n\t\techo json_encode($data);\n\t\t`,\n\t});\n\treturn response.json;\n}\n\n/**\n * Listens to SQL queries and transactions on a PlaygroundClient instance,\n * and records them in a journal. When a transaction is committed, the\n * provided callback is called for every query in the transaction.\n *\n * @param playground The PlaygroundClient instance to listen to.\n * @param onCommit The callback to invoke when a transaction is committed.\n */\nexport async function journalSQLQueries(\n\tplayground: UniversalPHP,\n\tonCommit: (queries: SQLJournalEntry) => void\n) {\n\tlet activeTransaction: SQLJournalEntry[] | null = null;\n\n\t// When PHP request terminates, any uncommitted\n\t// queries in the active transaction are rolled back.\n\tplayground.addEventListener('request.end', () => {\n\t\tactiveTransaction = null;\n\t});\n\tplayground.onMessage(async (messageString: string) => {\n\t\tconst message = JSON.parse(messageString) as any;\n\t\tif (message?.type !== 'sql') {\n\t\t\treturn;\n\t\t}\n\t\tif (message.subtype === 'transaction') {\n\t\t\tconst command = message as SQLTransactionCommand;\n\t\t\tif (!command.success) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch (command.command) {\n\t\t\t\tcase 'START TRANSACTION':\n\t\t\t\t\tactiveTransaction = [];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'COMMIT':\n\t\t\t\t\tif (activeTransaction?.length) {\n\t\t\t\t\t\tactiveTransaction.forEach(onCommit);\n\t\t\t\t\t}\n\t\t\t\t\tactiveTransaction = null;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ROLLBACK':\n\t\t\t\t\tactiveTransaction = null;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tmessage.subtype === 'replay-query' ||\n\t\t\tmessage.subtype === 'reconstruct-insert'\n\t\t) {\n\t\t\tconst entry = message as SQLJournalEntry;\n\t\t\tif (activeTransaction) {\n\t\t\t\tactiveTransaction.push(entry);\n\t\t\t} else {\n\t\t\t\tonCommit(entry);\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport async function replaySQLJournal(\n\tplayground: UniversalPHP,\n\tjournal: SQLJournalEntry[]\n) {\n\tconst js = phpVars({ journal });\n\tconst result = await playground.run({\n\t\tcode: `<?php\n\t\t// Prevent reporting changes from queries we're just replaying\n\t\tdefine('REPLAYING_SQL', true);\n\n\t\t// Only load WordPress and replay the SQL queries now\n\t\trequire '/wordpress/wp-load.php';\n\t\tplayground_sync_replay_sql_journal(${js.journal});\n\t`,\n\t});\n\tassertEmptyOutput(result, 'Replay error.');\n}\n\nfunction assertEmptyOutput(result: PHPResponse, errorMessage: string) {\n\tif (result.text.trim() || result.errors.trim()) {\n\t\tlogger.error({\n\t\t\ttext: result.text,\n\t\t\terrors: result.errors,\n\t\t});\n\t\tthrow new Error(`${errorMessage}. See the console for more details.`);\n\t}\n}\n\nexport type ReplayQuery = {\n\ttype: 'sql';\n\tsubtype: 'replay-query';\n\tquery: string;\n\tquery_type: string;\n\ttable_name: string;\n\tauto_increment_column: string;\n\tlast_insert_id: number;\n};\n\nexport type ReconstructInsert = {\n\ttype: 'sql';\n\tsubtype: 'reconstruct-insert';\n\tquery_type: 'INSERT';\n\trow: Record<string, string | number | null>;\n\ttable_name: string;\n\tauto_increment_column: string;\n\tlast_insert_id: number;\n};\n\nexport type SQLJournalEntry = ReplayQuery | ReconstructInsert;\n\nexport type SQLTransactionCommand =\n\t| {\n\t\t\ttype: 'sql';\n\t\t\tsubtype: 'transaction';\n\t\t\tcommand: 'START TRANSACTION';\n\t\t\tsuccess: boolean;\n\t  }\n\t| {\n\t\t\ttype: 'sql';\n\t\t\tsubtype: 'transaction';\n\t\t\tcommand: 'COMMIT';\n\t\t\tsuccess: boolean;\n\t  }\n\t| {\n\t\t\ttype: 'sql';\n\t\t\tsubtype: 'transaction';\n\t\t\tcommand: 'ROLLBACK';\n\t\t\tsuccess: boolean;\n\t  };\n","import type { FilesystemOperation } from '@php-wasm/fs-journal';\nimport type { PlaygroundClient } from '@wp-playground/client';\n\nexport async function journalFSOperations(\n\tplayground: PlaygroundClient,\n\tonEntry: (op: FilesystemOperation) => void\n) {\n\tawait playground.journalFSEvents(\n\t\t'/wordpress/wp-content',\n\t\tasync (entry: FilesystemOperation) => {\n\t\t\tif (\n\t\t\t\tentry.path.endsWith('/.ht.sqlite') ||\n\t\t\t\tentry.path.endsWith('/.ht.sqlite-journal')\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tonEntry(entry);\n\t\t}\n\t);\n}\n","import type { FilesystemOperation } from '@php-wasm/fs-journal';\nimport type { SQLJournalEntry } from './sql';\n\nexport type TransportEnvelope = {\n\tfs: FilesystemOperation[];\n\tsql: SQLJournalEntry[];\n};\n\nexport type ChangesCallback = (changes: TransportEnvelope) => void;\nexport interface PlaygroundSyncTransport {\n\tsendChanges(data: TransportEnvelope): void;\n\tonChangesReceived(fn: ChangesCallback): void;\n}\n\nexport class ParentWindowTransport implements PlaygroundSyncTransport {\n\tsendChanges(envelope: TransportEnvelope) {\n\t\twindow.top!.postMessage(\n\t\t\t{\n\t\t\t\ttype: 'playground-change',\n\t\t\t\tenvelope,\n\t\t\t},\n\t\t\t'*'\n\t\t);\n\t}\n\n\tonChangesReceived(fn: ChangesCallback): void {\n\t\twindow.addEventListener('message', (event) => {\n\t\t\tif (event.data.type !== 'playground-change') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfn(event.data.envelope);\n\t\t});\n\t}\n}\n\nexport class NoopTransport implements PlaygroundSyncTransport {\n\tsendChanges() {}\n\tonChangesReceived(callback: ChangesCallback) {\n\t\tthis.injectChanges = callback;\n\t}\n\tinjectChanges(changes: TransportEnvelope) {}\n}\n","import type { SyncMiddleware } from '.';\nimport { logger } from '@php-wasm/logger';\n\nexport function loggerMiddleware(clientId: string): SyncMiddleware {\n\treturn {\n\t\tbeforeSend: (envelope) => {\n\t\t\tif (envelope.sql.length > 0 || envelope.fs.length > 0) {\n\t\t\t\tlogger.log(`[${clientId}] Sending changes`, envelope);\n\t\t\t}\n\t\t\treturn envelope;\n\t\t},\n\t\tafterReceive: (envelope) => {\n\t\t\tlogger.log(`[${clientId}] Received changes`, envelope);\n\t\t\treturn envelope;\n\t\t},\n\t};\n}\n","import type { TransportEnvelope } from '../transports';\n\nexport const marshallSiteURLMiddleware = (\n\tlocalSiteUrl: string,\n\tplaceholderUrl = 'https://playground.wordpress.net'\n) => {\n\treturn {\n\t\tbeforeSend: siteURLMapper(localSiteUrl, placeholderUrl),\n\t\tafterReceive: siteURLMapper(placeholderUrl, localSiteUrl),\n\t};\n};\n\n/**\n * Maps the WordPress site URL from one value to another in SQL\n * query journal.\n *\n * @param fromURL - The original site URL to be replaced.\n * @param toURL - The new site URL to replace the original.\n * @returns Mapper function.\n */\nfunction siteURLMapper(fromURL: string, toURL: string) {\n\t// Remove trailing slashes for consistency\n\tfromURL = fromURL.replace(/\\/$/, '');\n\ttoURL = toURL.replace(/\\/$/, '');\n\n\tconst urlRegexp = new RegExp(\n\t\t`(^|[^0-9a-zA-Z])(?:${escapeRegex(fromURL)})($|[^0-9a-zA-Z])`,\n\t\t'g'\n\t);\n\tconst urlReplacement = `$1${toURL}$2`;\n\n\treturn (envelope: TransportEnvelope) => ({\n\t\t...envelope,\n\t\tsql: envelope.sql.map((entry) => {\n\t\t\tif (entry.subtype === 'replay-query') {\n\t\t\t\treturn {\n\t\t\t\t\t...entry,\n\t\t\t\t\tquery: entry.query.replace(fromURL, toURL),\n\t\t\t\t};\n\t\t\t} else if (entry.subtype === 'reconstruct-insert') {\n\t\t\t\tconst row = { ...entry.row };\n\t\t\t\tfor (const key in row) {\n\t\t\t\t\tif (typeof row[key] === 'string') {\n\t\t\t\t\t\trow[key] = (row[key] as string).replace(\n\t\t\t\t\t\t\turlRegexp,\n\t\t\t\t\t\t\turlReplacement\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t...entry,\n\t\t\t\t\trow,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn entry;\n\t\t}),\n\t});\n}\n\nfunction escapeRegex(string: string) {\n\treturn string.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n","import type { SyncMiddleware } from '.';\nimport type { SQLJournalEntry } from '../sql';\n\nexport const pruneSQLQueriesMiddleware = (): SyncMiddleware => ({\n\tbeforeSend: (envelope) => ({\n\t\t...envelope,\n\t\tsql: envelope.sql.filter(shouldSyncQuery),\n\t}),\n\tafterReceive: (envelope) => envelope,\n});\n\n/**\n * Determines whether a SQL query should be considered private\n * to the current site. Private queries are not synced with other\n * sites. For example:\n *\n * * SELECT queries\n * * Transients\n * * Session tokens\n *\n * ...and more.\n *\n * @param entry - The SQL Journal entry.\n * @returns Whether the query should be considered private.\n */\nconst shouldSyncQuery = (entry: SQLJournalEntry) => {\n\tif (entry.query_type === 'SELECT') {\n\t\treturn false;\n\t}\n\tconst queryType = entry.query_type;\n\tconst tableName = entry.table_name?.toLowerCase();\n\n\tif (entry.subtype === 'replay-query') {\n\t\tconst query = entry.query.trim();\n\t\t// Don't sync cron updates\n\t\tif (\n\t\t\tqueryType === 'UPDATE' &&\n\t\t\ttableName === 'wp_options' &&\n\t\t\tquery.endsWith(\"`option_name` = 'cron'\")\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (entry.subtype === 'reconstruct-insert') {\n\t\t// Don't sync transients\n\t\tif (tableName === 'wp_options') {\n\t\t\tconst optionName = entry.row.option_name + '';\n\t\t\tif (\n\t\t\t\toptionName.startsWith('_transient_') ||\n\t\t\t\toptionName.startsWith('_site_transient_')\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// Don't sync session tokens\n\t\tif (tableName === 'wp_usermeta') {\n\t\t\tif (entry.row.meta_key === 'session_tokens') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n};\n","import {\n\thydrateUpdateFileOps,\n\tnormalizeFilesystemOperations,\n} from '@php-wasm/fs-journal';\nimport type { SyncMiddleware } from '.';\nimport type { UniversalPHP } from '@php-wasm/universal';\n\nexport const hydrateFsWritesMiddleware = (\n\tphp: UniversalPHP\n): SyncMiddleware => ({\n\tbeforeSend: async (envelope) => ({\n\t\t...envelope,\n\t\tfs: await hydrateUpdateFileOps(\n\t\t\tphp,\n\t\t\tnormalizeFilesystemOperations(envelope.fs)\n\t\t),\n\t}),\n\tafterReceive: (envelopes) => envelopes,\n});\n","import type { PlaygroundClient } from '@wp-playground/remote';\nimport { installSqlSyncMuPlugin, overrideAutoincrementSequences } from './sql';\nimport { journalFSOperations } from './fs';\nimport type { SQLJournalEntry } from './sql';\nimport { journalSQLQueries, replaySQLJournal } from './sql';\nimport type { PlaygroundSyncTransport, TransportEnvelope } from './transports';\nimport type { FilesystemOperation } from '@php-wasm/fs-journal';\nimport type { SyncMiddleware } from './middleware';\nimport { marshallSiteURLMiddleware } from './middleware';\nimport { pruneSQLQueriesMiddleware } from './middleware/prune-sql-queries';\nimport { hydrateFsWritesMiddleware } from './middleware/hydrate-fs-writes';\n\nexport interface SyncOptions {\n\tautoincrementOffset: number;\n\ttransport: PlaygroundSyncTransport;\n\tmiddlewares?: SyncMiddleware[];\n}\n\nexport async function setupPlaygroundSync(\n\tplayground: PlaygroundClient,\n\t{ autoincrementOffset, transport, middlewares = [] }: SyncOptions\n) {\n\tmiddlewares = [\n\t\tpruneSQLQueriesMiddleware(),\n\t\tmarshallSiteURLMiddleware(await playground.absoluteUrl),\n\t\thydrateFsWritesMiddleware(playground),\n\t\t...middlewares,\n\t];\n\n\tawait installSqlSyncMuPlugin(playground);\n\tawait overrideAutoincrementSequences(playground, autoincrementOffset);\n\n\ttransport.onChangesReceived(async (changes) => {\n\t\tfor (const middleware of middlewares) {\n\t\t\tchanges = await middleware.afterReceive(changes);\n\t\t}\n\t\tawait playground.replayFSJournal(changes.fs);\n\t\tawait replaySQLJournal(playground, changes.sql);\n\t});\n\n\tlet localChanges: TransportEnvelope = { fs: [], sql: [] };\n\tjournalSQLQueries(playground, (query: SQLJournalEntry) => {\n\t\tlocalChanges.sql.push(query);\n\t});\n\tjournalFSOperations(playground, (op: FilesystemOperation) => {\n\t\tlocalChanges.fs.push(op);\n\t});\n\n\t// Flush the journal at most every 3 seconds\n\tconst flushJournal = async () => {\n\t\tlet flushedChanges = localChanges;\n\t\tlocalChanges = { fs: [], sql: [] };\n\t\tfor (const middleware of middlewares) {\n\t\t\tflushedChanges = await middleware.beforeSend(flushedChanges);\n\t\t}\n\t\tif (!flushedChanges.sql.length && !flushedChanges.fs.length) {\n\t\t\treturn;\n\t\t}\n\t\ttransport.sendChanges(flushedChanges);\n\t};\n\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n\tconst loopAfterInterval = async (f: Function, ms: number) => {\n\t\tawait f();\n\t\tsetTimeout(loopAfterInterval, ms, f, ms);\n\t};\n\n\tloopAfterInterval(flushJournal, 3000);\n}\n"],"names":["logSqlQueries","installSqlSyncMuPlugin","playground","overrideAutoincrementSequences","baseOffset","knownIds","initializationResult","phpVar","assertEmptyOutput","journalSQLQueries","onCommit","activeTransaction","messageString","message","command","entry","replaySQLJournal","journal","js","phpVars","result","errorMessage","logger","journalFSOperations","onEntry","ParentWindowTransport","envelope","fn","event","NoopTransport","callback","changes","loggerMiddleware","clientId","marshallSiteURLMiddleware","localSiteUrl","placeholderUrl","siteURLMapper","fromURL","toURL","urlRegexp","escapeRegex","urlReplacement","row","key","string","pruneSQLQueriesMiddleware","shouldSyncQuery","queryType","tableName","query","optionName","hydrateFsWritesMiddleware","php","hydrateUpdateFileOps","normalizeFilesystemOperations","envelopes","setupPlaygroundSync","autoincrementOffset","transport","middlewares","middleware","localChanges","op","flushJournal","flushedChanges","loopAfterInterval","f","ms"],"mappings":"4FAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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"}
{"version":3,"file":"sw.js","sources":["packages/php-wasm/scopes/src/index.ts","packages/php-wasm/node-polyfills/src/lib/current-js-runtime.ts","packages/php-wasm/node-polyfills/src/lib/blob.ts","packages/php-wasm/node-polyfills/src/lib/custom-event.ts","packages/php-wasm/logger/src/lib/handlers/log-event.ts","packages/php-wasm/logger/src/lib/handlers/log-to-console.ts","packages/php-wasm/logger/src/lib/handlers/log-to-memory.ts","packages/php-wasm/logger/src/lib/logger.ts","packages/php-wasm/logger/src/lib/collectors/collect-service-worker-metrics.ts","packages/php-wasm/util/src/lib/sleep.ts","packages/php-wasm/util/src/lib/semaphore.ts","packages/php-wasm/universal/src/lib/load-php-runtime.ts","packages/php-wasm/stream-compression/src/utils/iterable-stream-polyfill.ts","packages/php-wasm/stream-compression/src/zip/decode-remote-zip.ts","packages/php-wasm/universal/src/lib/php-request-handler.ts","packages/php-wasm/universal/src/lib/comlink-sync.ts","packages/php-wasm/universal/src/lib/serialize-error.ts","packages/php-wasm/universal/src/lib/api.ts","packages/php-wasm/web-service-worker/src/messaging.ts","packages/php-wasm/web-service-worker/src/utils.ts","packages/playground/wordpress/src/rewrite-rules.ts","packages/playground/remote/src/lib/offline-mode-cache.ts","packages/playground/remote/service-worker.ts"],"sourcesContent":["/**\n * Scopes are unique strings, like `my-site`, used to uniquely brand\n * the outgoing HTTP traffic from each browser tab. This helps the\n * main thread distinguish between the relevant and irrelevant\n * messages received from the Service Worker.\n *\n * Scopes are included in the `PHPRequestHandler.absoluteUrl` as follows:\n *\n * An **unscoped** URL: http://localhost:8778/wp-login.php\n * A **scoped** URL:    http://localhost:8778/scope:my-site/wp-login.php\n *\n * For more information, see the README section on scopes.\n */\n\n/**\n * Checks if the given URL contains scope information.\n *\n * @example\n * ```js\n * isURLScoped(new URL('http://localhost/scope:my-site/index.php'));\n * // true\n *\n * isURLScoped(new URL('http://localhost/index.php'));\n * // false\n * ```\n *\n * @param  url The URL to check.\n * @returns `true` if the URL contains scope information, `false` otherwise.\n */\nexport function isURLScoped(url: URL): boolean {\n\treturn url.pathname.startsWith(`/scope:`);\n}\n\n/**\n * Returns the scope stored in the given URL.\n *\n * @example\n * ```js\n * getScopeFromURL(new URL('http://localhost/scope:my-site/index.php'));\n * // '96253'\n *\n * getScopeFromURL(new URL('http://localhost/index.php'));\n * // null\n * ```\n *\n * @param  url The URL.\n * @returns The scope if the URL contains a scope, `null` otherwise.\n */\nexport function getURLScope(url: URL): string | null {\n\tif (isURLScoped(url)) {\n\t\treturn url.pathname.split('/')[1].split(':')[1];\n\t}\n\treturn null;\n}\n\n/**\n * Returns a new URL with the requested scope information.\n *\n * @example\n * ```js\n * setURLScope(new URL('http://localhost/index.php'), 'my-site');\n * // URL('http://localhost/scope:my-site/index.php')\n *\n * setURLScope(new URL('http://localhost/scope:my-site/index.php'), 'my-site');\n * // URL('http://localhost/scope:my-site/index.php')\n *\n * setURLScope(new URL('http://localhost/index.php'), null);\n * // URL('http://localhost/index.php')\n * ```\n *\n * @param  url   The URL to scope.\n * @param  scope The scope value.\n * @returns A new URL with the scope information in it.\n */\nexport function setURLScope(url: URL | string, scope: string | null): URL {\n\tlet newUrl = new URL(url);\n\n\tif (isURLScoped(newUrl)) {\n\t\tif (scope) {\n\t\t\tconst parts = newUrl.pathname.split('/');\n\t\t\tparts[1] = `scope:${scope}`;\n\t\t\tnewUrl.pathname = parts.join('/');\n\t\t} else {\n\t\t\tnewUrl = removeURLScope(newUrl);\n\t\t}\n\t} else if (scope) {\n\t\tconst suffix = newUrl.pathname === '/' ? '' : newUrl.pathname;\n\t\tnewUrl.pathname = `/scope:${scope}${suffix}`;\n\t}\n\n\treturn newUrl;\n}\n\n/**\n * Returns a new URL without any scope information.\n *\n * @example\n * ```js\n * removeURLScope(new URL('http://localhost/scope:my-site/index.php'));\n * // URL('http://localhost/index.php')\n *\n * removeURLScope(new URL('http://localhost/index.php'));\n * // URL('http://localhost/index.php')\n * ```\n *\n * @param  url The URL to remove scope information from.\n * @returns A new URL without the scope information.\n */\nexport function removeURLScope(url: URL): URL {\n\tif (!isURLScoped(url)) {\n\t\treturn url;\n\t}\n\tconst newUrl = new URL(url);\n\tconst parts = newUrl.pathname.split('/');\n\tnewUrl.pathname = '/' + parts.slice(2).join('/');\n\treturn newUrl;\n}\n","export const currentJsRuntime = (function () {\n\tif (typeof process !== 'undefined' && process.release?.name === 'node') {\n\t\treturn 'NODE';\n\t} else if (typeof window !== 'undefined') {\n\t\treturn 'WEB';\n\t} else if (\n\t\t// @ts-ignore\n\t\ttypeof WorkerGlobalScope !== 'undefined' &&\n\t\t// @ts-ignore\n\t\tself instanceof (WorkerGlobalScope as any)\n\t) {\n\t\treturn 'WORKER';\n\t} else {\n\t\treturn 'NODE';\n\t}\n})();\n","import { currentJsRuntime } from './current-js-runtime';\n\n// Without this check, the polyfills below would also be applied\n// in web browsers. Unfortunately, Safari doesn't sypport BYOB streams\n// and doesn't support the polyfill provided here. Let's only apply\n// those polyfills in Node.js environments.\nif (currentJsRuntime === 'NODE') {\n\t/**\n\t * WordPress Playground heavily realies on the File class. This module\n\t * polyfill the File class for the different environments where\n\t * WordPress Playground may run.\n\t */\n\tif (typeof File === 'undefined') {\n\t\t/**\n\t\t * Polyfill the File class that isn't shipped in Node.js version 18.\n\t\t *\n\t\t * Blob conveniently provides a lot of the same methods as File, we\n\t\t * just need to implement a few File-specific properties.\n\t\t */\n\t\tclass File extends Blob {\n\t\t\treadonly name: string;\n\t\t\treadonly lastModified: number;\n\t\t\treadonly lastModifiedDate: Date;\n\t\t\twebkitRelativePath: any;\n\t\t\tconstructor(\n\t\t\t\tsources: BlobPart[],\n\t\t\t\tfileName: string,\n\t\t\t\toptions?: FilePropertyBag\n\t\t\t) {\n\t\t\t\tsuper(sources);\n\t\t\t\t/*\n\t\t\t\t * Compute a valid last modified date as that's what the\n\t\t\t\t * browsers do:\n\t\t\t\t *\n\t\t\t\t * ```\n\t\t\t\t * > new File([], '').lastModifiedDate\n\t\t\t\t * Sat Dec 16 2023 10:07:53 GMT+0100 (czas środkowoeuropejski standardowy)\n\t\t\t\t *\n\t\t\t\t * > new File([], '', { lastModified: NaN }).lastModifiedDate\n\t\t\t\t * Thu Jan 01 1970 01:00:00 GMT+0100 (czas środkowoeuropejski standardowy)\n\t\t\t\t *\n\t\t\t\t * > new File([], '', { lastModified: 'string' }).lastModifiedDate\n\t\t\t\t * Thu Jan 01 1970 01:00:00 GMT+0100 (czas środkowoeuropejski standardowy)\n\t\t\t\t *\n\t\t\t\t * > new File([], '', { lastModified: {} }).lastModifiedDate\n\t\t\t\t * Thu Jan 01 1970 01:00:00 GMT+0100 (czas środkowoeuropejski standardowy)\n\t\t\t\t * ```\n\t\t\t\t */\n\t\t\t\tlet date;\n\t\t\t\tif (options?.lastModified) {\n\t\t\t\t\tdate = new Date();\n\t\t\t\t}\n\t\t\t\tif (!date || isNaN(date.getFullYear())) {\n\t\t\t\t\tdate = new Date();\n\t\t\t\t}\n\t\t\t\tthis.lastModifiedDate = date;\n\t\t\t\tthis.lastModified = date.getMilliseconds();\n\t\t\t\tthis.name = fileName || '';\n\t\t\t}\n\t\t}\n\t\tglobal.File = File;\n\t}\n\n\t// eslint-disable-next-line no-inner-declarations\n\tfunction asPromise<T>(obj: FileReader) {\n\t\treturn new Promise<T>(function (resolve, reject) {\n\t\t\tobj.onload = obj.onerror = function (event: Event) {\n\t\t\t\tobj.onload = obj.onerror = null;\n\n\t\t\t\tif (event.type === 'load') {\n\t\t\t\t\tresolve(obj.result as T);\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error('Failed to read the blob/file'));\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * File is a subclass of Blob. Let's polyfill the following Blob\n\t * methods that are missing in JSDOM:\n\t *\n\t * – Blob.text()\n\t * – Blob.stream()\n\t * – Blob.arrayBuffer()\n\t *\n\t * See the related JSDom issue:\n\t *\n\t * – [Implement Blob.stream, Blob.text and Blob.arrayBuffer](https://github.com/jsdom/jsdom/issues/2555).\n\t *\n\t * @source `blob-polyfill` npm package.\n\t * * By Eli Grey, https://eligrey.com\n\t * * By Jimmy Wärting, https://github.com/jimmywarting\n\t */\n\tif (typeof Blob.prototype.arrayBuffer === 'undefined') {\n\t\tBlob.prototype.arrayBuffer = function arrayBuffer() {\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer(this);\n\t\t\treturn asPromise<Uint8Array>(reader);\n\t\t};\n\t}\n\n\tif (typeof Blob.prototype.text === 'undefined') {\n\t\tBlob.prototype.text = function text() {\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsText(this);\n\t\t\treturn asPromise<string>(reader);\n\t\t};\n\t}\n\n\t/**\n\t * Detects if BYOB (Bring Your Own Buffer) streams are supported\n\t * in the current environment.\n\t *\n\t * BYOB is a new feature in the Streams API that allows reading\n\t * an arbitrary number of bytes from a stream. It's not supported\n\t * in older versions of Node.js.\n\t *\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader\n\t */\n\t// eslint-disable-next-line no-inner-declarations\n\tfunction isByobSupported() {\n\t\tconst inputBytes = new Uint8Array([1, 2, 3, 4]);\n\t\tconst file = new File([inputBytes], 'test');\n\t\tconst stream = file.stream();\n\t\ttry {\n\t\t\t// This throws on older versions of node:\n\t\t\tstream.getReader({ mode: 'byob' });\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Polyfill the stream() method if it either doesn't exist,\n\t * or is an older version shipped with e.g. Node.js 18 where\n\t * BYOB streams seem to be unsupported.\n\t */\n\tif (typeof Blob.prototype.stream === 'undefined' || !isByobSupported()) {\n\t\tBlob.prototype.stream = function () {\n\t\t\tlet position = 0;\n\t\t\t// eslint-disable-next-line\n\t\t\tconst blob = this;\n\t\t\treturn new ReadableStream({\n\t\t\t\ttype: 'bytes',\n\t\t\t\t// 0.5 MB seems like a reasonable chunk size, let's adjust\n\t\t\t\t// this if needed.\n\t\t\t\tautoAllocateChunkSize: 512 * 1024,\n\n\t\t\t\tasync pull(controller) {\n\t\t\t\t\tconst view = controller.byobRequest!.view;\n\n\t\t\t\t\t// Read the next chunk of data:\n\t\t\t\t\tconst chunk = blob.slice(\n\t\t\t\t\t\tposition,\n\t\t\t\t\t\tposition + view!.byteLength\n\t\t\t\t\t);\n\t\t\t\t\tconst buffer = await chunk.arrayBuffer();\n\t\t\t\t\tconst uint8array = new Uint8Array(buffer);\n\n\t\t\t\t\t// Emit that chunk:\n\t\t\t\t\tnew Uint8Array(view!.buffer).set(uint8array);\n\t\t\t\t\tconst bytesRead = uint8array.byteLength;\n\t\t\t\t\tcontroller.byobRequest!.respond(bytesRead);\n\n\t\t\t\t\t// Bump the position and close this stream once\n\t\t\t\t\t// we've read the entire blob.\n\t\t\t\t\tposition += bytesRead;\n\t\t\t\t\tif (position >= blob.size) {\n\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t});\n\t\t};\n\t}\n}\n\nexport default {};\n","import { currentJsRuntime } from './current-js-runtime';\n\nif (currentJsRuntime === 'NODE' && typeof CustomEvent === 'undefined') {\n\tclass CustomEvent<T = any> extends Event {\n\t\treadonly detail: T;\n\t\tconstructor(\n\t\t\tname: string,\n\t\t\toptions: {\n\t\t\t\tdetail?: T;\n\t\t\t\tbubbles?: boolean;\n\t\t\t\tcancellable?: boolean;\n\t\t\t\tcomposed?: boolean;\n\t\t\t} = {}\n\t\t) {\n\t\t\tsuper(name, options);\n\t\t\t/*\n\t\t\t * The bang symbol (`!`) here is a lie to make TypeScript happy.\n\t\t\t *\n\t\t\t * Without the bang TS has the following complaint:\n\t\t\t *\n\t\t\t * > T | undefined is not assignable to type T\n\t\t\t *\n\t\t\t * In reality, it's absolutely fine for T (or `options.detail`)\n\t\t\t * to be undefined. However, the CustomEvent interface shipped\n\t\t\t * with TypeScript doesn't think so and marks `this.details` as\n\t\t\t * a required property.\n\t\t\t *\n\t\t\t * This little and harmless trick silences that error.\n\t\t\t */\n\t\t\tthis.detail = options.detail!;\n\t\t}\n\t\tinitCustomEvent(): void {}\n\t}\n\tglobalThis.CustomEvent = CustomEvent;\n}\n","import type { LogHandler } from '../log-handlers';\nimport { type Log, logger } from '../logger';\n\nexport const logEventType = 'playground-log';\n\nexport const logEvent: LogHandler = (log: Log, ...args: any[]): void => {\n\tlogger.dispatchEvent(\n\t\tnew CustomEvent(logEventType, {\n\t\t\tdetail: {\n\t\t\t\tlog,\n\t\t\t\targs,\n\t\t\t},\n\t\t})\n\t);\n};\n","import type { LogHandler } from '../log-handlers';\nimport { type Log, LogSeverity, prepareLogMessage } from '../logger';\n\n/**\n * Log message to the console.\n */\nexport const logToConsole: LogHandler = (log: Log, ...args: any[]): void => {\n\tif (typeof log.message === 'string') {\n\t\t// Some errors have a read-only message property where direct\n\t\t// assignment will throw an error. The assignment is merely for\n\t\t// formatting, so let's assign with Reflect.set and avoid the error.\n\t\tReflect.set(log, 'message', prepareLogMessage(log.message));\n\t} else if (log.message.message && typeof log.message.message === 'string') {\n\t\t// Some errors have a read-only message property where direct\n\t\t// assignment will throw an error. The assignment is merely for\n\t\t// formatting, so let's assign with Reflect.set and avoid the error.\n\t\tReflect.set(\n\t\t\tlog.message,\n\t\t\t'message',\n\t\t\tprepareLogMessage(log.message.message)\n\t\t);\n\t}\n\t/* eslint-disable no-console */\n\tswitch (log.severity) {\n\t\tcase LogSeverity.Debug:\n\t\t\tconsole.debug(log.message, ...args);\n\t\t\tbreak;\n\t\tcase LogSeverity.Info:\n\t\t\tconsole.info(log.message, ...args);\n\t\t\tbreak;\n\t\tcase LogSeverity.Warn:\n\t\t\tconsole.warn(log.message, ...args);\n\t\t\tbreak;\n\t\tcase LogSeverity.Error:\n\t\t\tconsole.error(log.message, ...args);\n\t\t\tbreak;\n\t\tcase LogSeverity.Fatal:\n\t\t\tconsole.error(log.message, ...args);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconsole.log(log.message, ...args);\n\t}\n\t/* eslint-enable no-console */\n};\n","import type { LogHandler } from '../log-handlers';\nimport { formatLogEntry, type Log, LogPrefix } from '../logger';\n\nconst prepareLogMessage = (logMessage: object): string => {\n\tif (logMessage instanceof Error) {\n\t\treturn [logMessage.message, logMessage.stack].join('\\n');\n\t}\n\treturn JSON.stringify(logMessage, null, 2);\n};\n\nexport const logs: string[] = [];\n\nconst addToLogArray = (message: string): void => {\n\tlogs.push(message);\n};\n\n/**\n * Log to memory\n */\nexport const logToMemory: LogHandler = (log: Log): void => {\n\tif (log.raw === true) {\n\t\taddToLogArray(log.message);\n\t} else {\n\t\tconst message = formatLogEntry(\n\t\t\ttypeof log.message === 'object'\n\t\t\t\t? prepareLogMessage(log.message)\n\t\t\t\t: log.message,\n\t\t\tlog.severity,\n\t\t\tlog.prefix ?? LogPrefix.JS\n\t\t);\n\t\taddToLogArray(message);\n\t}\n};\n\nexport const clearMemoryLogs = (): void => {\n\tlogs.length = 0;\n};\n","import { logEvent } from './handlers/log-event';\nimport {\n\tlogToMemory,\n\tlogToConsole,\n\tlogs,\n\ttype LogHandler,\n} from './log-handlers';\n\nexport { logEventType } from './handlers/log-event';\n\nexport { errorLogPath } from './collectors/collect-php-logs';\n\nexport type Log = {\n\tmessage: any;\n\tseverity: LogSeverity;\n\tprefix?: LogPrefix;\n\traw?: boolean;\n};\n\n/**\n * Log severity levels.\n */\nexport const LogSeverity = {\n\tFatal: { name: 'fatal', level: 0 },\n\tError: { name: 'error', level: 1 },\n\tWarn: { name: 'warn', level: 2 },\n\tLog: { name: 'log', level: 3 },\n\tInfo: { name: 'info', level: 4 },\n\tDebug: { name: 'debug', level: 5 },\n} as const;\n\nexport type LogSeverity = (typeof LogSeverity)[keyof typeof LogSeverity];\n\n/**\n * Log prefix.\n */\nexport const LogPrefix = {\n\tWASM: 'Wasm Crash',\n\tPHP: 'PHP',\n\tJS: 'JavaScript',\n} as const;\n\nexport type LogPrefix = (typeof LogPrefix)[keyof typeof LogPrefix];\n\n/**\n * A logger for Playground.\n */\nexport class Logger extends EventTarget {\n\tpublic readonly fatalErrorEvent = 'playground-fatal-error';\n\tprivate readonly handlers: LogHandler[];\n\tprivate severity: LogSeverity = LogSeverity.Info;\n\n\t// constructor\n\tconstructor(\n\t\t// Log handlers\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n\t\thandlers: LogHandler[] = []\n\t) {\n\t\tsuper();\n\t\tthis.handlers = handlers;\n\t}\n\n\t/**\n\t * Get all logs.\n\t * @returns string[]\n\t */\n\tpublic getLogs(): string[] {\n\t\tif (!this.handlers.includes(logToMemory)) {\n\t\t\tthis\n\t\t\t\t.error(`Logs aren't stored because the logToMemory handler isn't registered.\n\t\t\t\tIf you're using a custom logger instance, make sure to register logToMemory handler.\n\t\t\t`);\n\t\t\treturn [];\n\t\t}\n\t\treturn [...logs];\n\t}\n\n\t/**\n\t * Log message with severity.\n\t *\n\t * @param log Log\n\t * @param args any\n\t */\n\tpublic logMessage(\n\t\tlog: Omit<Log, 'severity'> & { severity?: LogSeverity },\n\t\t...args: any[]\n\t): void {\n\t\tconst logWithSeverity: Log = {\n\t\t\t...log,\n\t\t\tseverity: log.severity ?? LogSeverity.Log,\n\t\t};\n\t\tfor (const handler of this.handlers) {\n\t\t\tif (logWithSeverity.severity.level <= this.severity.level) {\n\t\t\t\thandler(logWithSeverity, ...args);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Filter message based on severity\n\t * @param severity LogSeverity\n\t */\n\tpublic setSeverityFilterLevel(severity: LogSeverity): void {\n\t\tthis.severity = severity;\n\t}\n\n\t/**\n\t * Log message\n\t *\n\t * @param message any\n\t * @param args any\n\t */\n\tpublic log(message: any, ...args: any[]): void {\n\t\tthis.logMessage(\n\t\t\t{\n\t\t\t\tmessage,\n\t\t\t\tseverity: LogSeverity.Log,\n\t\t\t\tprefix: LogPrefix.JS,\n\t\t\t\traw: false,\n\t\t\t},\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * Log debug message\n\t *\n\t * @param message any\n\t * @param args any\n\t */\n\tpublic debug(message: any, ...args: any[]): void {\n\t\tthis.logMessage(\n\t\t\t{\n\t\t\t\tmessage,\n\t\t\t\tseverity: LogSeverity.Debug,\n\t\t\t\tprefix: LogPrefix.JS,\n\t\t\t\traw: false,\n\t\t\t},\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * Log info message\n\t *\n\t * @param message any\n\t * @param args any\n\t */\n\tpublic info(message: any, ...args: any[]): void {\n\t\tthis.logMessage(\n\t\t\t{\n\t\t\t\tmessage,\n\t\t\t\tseverity: LogSeverity.Info,\n\t\t\t\tprefix: LogPrefix.JS,\n\t\t\t\traw: false,\n\t\t\t},\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * Log warning message\n\t *\n\t * @param message any\n\t * @param args any\n\t */\n\tpublic warn(message: any, ...args: any[]): void {\n\t\tthis.logMessage(\n\t\t\t{\n\t\t\t\tmessage,\n\t\t\t\tseverity: LogSeverity.Warn,\n\t\t\t\tprefix: LogPrefix.JS,\n\t\t\t\traw: false,\n\t\t\t},\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * Log error message\n\t *\n\t * @param message any\n\t * @param args any\n\t */\n\tpublic error(message: any, ...args: any[]): void {\n\t\tthis.logMessage(\n\t\t\t{\n\t\t\t\tmessage,\n\t\t\t\tseverity: LogSeverity.Error,\n\t\t\t\tprefix: LogPrefix.JS,\n\t\t\t\traw: false,\n\t\t\t},\n\t\t\t...args\n\t\t);\n\t}\n}\n\nconst getDefaultHandlers = () => {\n\ttry {\n\t\tif (process.env['NODE_ENV'] === 'test') {\n\t\t\treturn [logToMemory, logEvent];\n\t\t}\n\t} catch {\n\t\t// Process.env is not available in the browser\n\t}\n\treturn [logToMemory, logToConsole, logEvent];\n};\n\n/**\n * The logger instance.\n */\nexport const logger: Logger = new Logger(getDefaultHandlers());\n\nexport const prepareLogMessage = (message: string) => {\n\treturn message.replace(/\\t/g, '');\n};\n\nexport const formatLogEntry = (\n\tmessage: string,\n\tseverity: LogSeverity,\n\tprefix: string\n): string => {\n\tconst date = new Date();\n\tconst formattedDate = new Intl.DateTimeFormat('en-GB', {\n\t\tyear: 'numeric',\n\t\tmonth: 'short',\n\t\tday: '2-digit',\n\t\ttimeZone: 'UTC',\n\t})\n\t\t.format(date)\n\t\t.replace(/ /g, '-');\n\n\tconst formattedTime = new Intl.DateTimeFormat('en-GB', {\n\t\thour: '2-digit',\n\t\tminute: '2-digit',\n\t\tsecond: '2-digit',\n\t\thour12: false,\n\t\ttimeZone: 'UTC',\n\t\ttimeZoneName: 'short',\n\t}).format(date);\n\tconst now = formattedDate + ' ' + formattedTime;\n\tmessage = prepareLogMessage(message);\n\treturn `[${now}] ${prefix} ${severity.name}: ${message}`;\n};\n\n/**\n * Add a listener for the Playground crashes.\n * These crashes include Playground errors like Asyncify errors.\n * The callback function will receive an Event object with logs in the detail\n * property.\n *\n * @param loggerInstance The logger instance\n * @param callback The callback function\n */\nexport const addCrashListener = (\n\tloggerInstance: Logger,\n\tcallback: EventListenerOrEventListenerObject\n) => {\n\tloggerInstance.addEventListener(loggerInstance.fatalErrorEvent, callback);\n};\n","/// <reference lib=\"WebWorker\" />\n\n/**\n * **Call this inside a service worker.**\n * These errors include Playground errors like Asyncify errors. PHP errors\n * won't trigger this event.\n *\n * Reports service worker metrics.\n * Allows the logger to request metrics from the service worker by sending a\n * message. The service worker will respond with the number of open Playground\n * tabs.\n *\n * @param worker The service worker\n */\nexport const reportServiceWorkerMetrics = (\n\tworker: ServiceWorkerGlobalScope\n) => {\n\tworker.addEventListener('activate', () => {\n\t\tworker.clients.matchAll().then((clients) => {\n\t\t\tconst metrics = {\n\t\t\t\tnumberOfOpenPlaygroundTabs: clients.filter(\n\t\t\t\t\t// Only count top-level frames to get the number of tabs.\n\t\t\t\t\t(c) => c.frameType === 'top-level'\n\t\t\t\t).length,\n\t\t\t};\n\t\t\tfor (const client of clients) {\n\t\t\t\tclient.postMessage(metrics);\n\t\t\t}\n\t\t});\n\t});\n};\n","export const SleepFinished = Symbol('SleepFinished');\n\nexport function sleep(ms: number): Promise<typeof SleepFinished> {\n\treturn new Promise((resolve) => {\n\t\tsetTimeout(() => resolve(SleepFinished), ms);\n\t});\n}\n","import { SleepFinished, sleep } from './sleep';\n\nexport interface SemaphoreOptions {\n\t/**\n\t * The maximum number of concurrent locks.\n\t */\n\tconcurrency: number;\n\t/**\n\t * The maximum time to wait for a lock to become available.\n\t */\n\ttimeout?: number;\n}\n\nexport class AcquireTimeoutError extends Error {\n\tconstructor() {\n\t\tsuper('Acquiring lock timed out');\n\t}\n}\n\nexport default class Semaphore {\n\tprivate _running = 0;\n\tprivate concurrency: number;\n\tprivate timeout?: number;\n\tprivate queue: (() => void)[];\n\n\tconstructor({ concurrency, timeout }: SemaphoreOptions) {\n\t\tthis.concurrency = concurrency;\n\t\tthis.timeout = timeout;\n\t\tthis.queue = [];\n\t}\n\n\tget remaining(): number {\n\t\treturn this.concurrency - this.running;\n\t}\n\n\tget running(): number {\n\t\treturn this._running;\n\t}\n\n\tasync acquire(): Promise<() => void> {\n\t\twhile (true) {\n\t\t\tif (this._running >= this.concurrency) {\n\t\t\t\t// Concurrency exhausted – wait until a lock is released:\n\t\t\t\tconst acquired = new Promise<void>((resolve) => {\n\t\t\t\t\tthis.queue.push(resolve);\n\t\t\t\t});\n\t\t\t\tif (this.timeout !== undefined) {\n\t\t\t\t\tawait Promise.race([acquired, sleep(this.timeout)]).then(\n\t\t\t\t\t\t(value) => {\n\t\t\t\t\t\t\tif (value === SleepFinished) {\n\t\t\t\t\t\t\t\tthrow new AcquireTimeoutError();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tawait acquired;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Acquire the lock:\n\t\t\t\tthis._running++;\n\t\t\t\tlet released = false;\n\t\t\t\treturn () => {\n\t\t\t\t\tif (released) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treleased = true;\n\t\t\t\t\tthis._running--;\n\t\t\t\t\t// Release the lock:\n\t\t\t\t\tif (this.queue.length > 0) {\n\t\t\t\t\t\tthis.queue.shift()!();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\tasync run<T>(fn: () => T | Promise<T>): Promise<T> {\n\t\tconst release = await this.acquire();\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\trelease();\n\t\t}\n\t}\n}\n","import { logger } from '@php-wasm/logger';\nimport type { IncomingMessage, Server, ServerResponse } from 'http';\n\nconst RuntimeId = Symbol('RuntimeId');\nconst loadedRuntimes: Map<number, PHPRuntime> = new Map();\nlet lastRuntimeId = 0;\n\n/**\n * Loads the PHP runtime with the given arguments and data dependencies.\n *\n * This function handles the entire PHP initialization pipeline. In particular,\n * it:\n *\n * * Instantiates the Emscripten PHP module\n * * Wires it together with the data dependencies and loads them\n * * Ensures is all happens in a correct order\n * * Waits until the entire loading sequence is finished\n *\n * Basic usage:\n *\n * ```js\n *  const phpLoaderModule = await getPHPLoaderModule(\"7.4\");\n *  const php = await loadPHPRuntime( phpLoaderModule );\n *  console.log(php.run(`<?php echo \"Hello, world!\"; `));\n *  // { stdout: ArrayBuffer containing the string \"Hello, world!\", stderr: [''], exitCode: 0 }\n * ```\n *\n * **The PHP loader module:**\n *\n * In the basic usage example, `phpLoaderModule` is **not** a vanilla\n * Emscripten module. Instead, it's an ESM module that wraps the regular\n * Emscripten output and adds some extra functionality. It's generated by the\n * Dockerfile shipped with this repo. Here's the API it provides:\n *\n * ```js\n * // php.wasm size in bytes:\n * export const dependenciesTotalSize = 5644199;\n *\n * // php.wasm filename:\n * export const dependencyFilename = 'php.wasm';\n *\n * // Run Emscripten's generated module:\n * export default function(jsEnv, emscriptenModuleArgs) {}\n * ```\n *\n * **PHP Filesystem:**\n *\n * Once initialized, the PHP has its own filesystem separate from the project\n * files. It's provided by [Emscripten and uses its FS library](https://emscripten.org/docs/api_reference/Filesystem-API.html).\n *\n * The API exposed to you via the PHP class is succinct and abstracts\n * certain unintuitive parts of low-level filesystem interactions.\n *\n * Here's how to use it:\n *\n * ```js\n * // Recursively create a /var/www directory\n * php.mkdirTree('/var/www');\n *\n * console.log(php.fileExists('/var/www/file.txt'));\n * // false\n *\n * php.writeFile('/var/www/file.txt', 'Hello from the filesystem!');\n *\n * console.log(php.fileExists('/var/www/file.txt'));\n * // true\n *\n * console.log(php.readFile('/var/www/file.txt'));\n * // \"Hello from the filesystem!\n *\n * // Delete the file:\n * php.unlink('/var/www/file.txt');\n * ```\n *\n * For more details consult the PHP class directly.\n *\n * **Data dependencies:**\n *\n * Using existing PHP packages by manually recreating them file-by-file would\n * be quite inconvenient. Fortunately, Emscripten provides a \"data dependencies\"\n * feature.\n *\n * Data dependencies consist of a `dependency.data` file and a `dependency.js`\n * loader and can be packaged with the [file_packager.py tool](\n * https://emscripten.org/docs/porting/files/packaging_files.html#packaging-using-the-file-packager-tool).\n * This project requires wrapping the Emscripten-generated `dependency.js` file\n * in an ES module as follows:\n *\n * 1. Prepend `export default function(emscriptenPHPModule) {'; `\n * 2. Prepend `export const dependencyFilename = '<DATA FILE NAME>'; `\n * 3. Prepend `export const dependenciesTotalSize = <DATA FILE SIZE>;`\n * 4. Append `}`\n *\n * Be sure to use the `--export-name=\"emscriptenPHPModule\"` file_packager.py\n * option.\n *\n * You want the final output to look as follows:\n *\n * ```js\n * export const dependenciesTotalSize = 5644199;\n * export const dependencyFilename = 'dependency.data';\n * export default function(emscriptenPHPModule) {\n *    // Emscripten-generated code:\n *    var Module = typeof emscriptenPHPModule !== 'undefined' ? emscriptenPHPModule : {};\n *    // ... the rest of it ...\n * }\n * ```\n *\n * Such a constructions enables loading the `dependency.js` as an ES Module\n * using `import(\"/dependency.js\")`.\n *\n * Once it's ready, you can load PHP and your data dependencies as follows:\n *\n * ```js\n *  const [phpLoaderModule, wordPressLoaderModule] = await Promise.all([\n *    getPHPLoaderModule(\"7.4\"),\n *    import(\"/wp.js\")\n *  ]);\n *  const php = await loadPHPRuntime(phpLoaderModule, {}, [wordPressLoaderModule]);\n * ```\n *\n * @public\n * @param  phpLoaderModule         - The ESM-wrapped Emscripten module. Consult the Dockerfile for the build process.\n * @param  options                 - The Emscripten module arguments, see https://emscripten.org/docs/api_reference/module.html#affecting-execution.\n * @returns Loaded runtime id.\n */\n\nexport async function loadPHPRuntime(\n\tphpLoaderModule: PHPLoaderModule,\n\t...options: EmscriptenOptions[]\n): Promise<number> {\n\tconst phpModuleArgs = Object.assign({}, ...options);\n\n\tconst [phpReady, resolvePHP, rejectPHP] = makePromise();\n\n\tconst PHPRuntime = phpLoaderModule.init(currentJsRuntime, {\n\t\tonAbort(reason) {\n\t\t\trejectPHP(reason);\n\t\t\t// This can happen after PHP has been initialized so\n\t\t\t// let's just log it.\n\t\t\tlogger.error(reason);\n\t\t},\n\t\tENV: {},\n\t\t// Emscripten sometimes prepends a '/' to the path, which\n\t\t// breaks vite dev mode. An identity `locateFile` function\n\t\t// fixes it.\n\t\tlocateFile: (path) => path,\n\t\t...phpModuleArgs,\n\t\tnoInitialRun: true,\n\t\tonRuntimeInitialized() {\n\t\t\tif (phpModuleArgs.onRuntimeInitialized) {\n\t\t\t\tphpModuleArgs.onRuntimeInitialized(PHPRuntime);\n\t\t\t}\n\t\t\tresolvePHP();\n\t\t},\n\t});\n\n\tawait phpReady;\n\n\tconst id = ++lastRuntimeId;\n\n\t// TODO: Ask @adamziel why this is here.\n\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions -- why is this here?\n\tPHPRuntime.FS;\n\tPHPRuntime.id = id;\n\tPHPRuntime.originalExit = PHPRuntime._exit;\n\n\tPHPRuntime._exit = function (code: number) {\n\t\tif (PHPRuntime.outboundNetworkProxyServer) {\n\t\t\tPHPRuntime.outboundNetworkProxyServer.close();\n\t\t\tPHPRuntime.outboundNetworkProxyServer.closeAllConnections();\n\t\t}\n\t\tloadedRuntimes.delete(id);\n\t\treturn PHPRuntime.originalExit(code);\n\t};\n\n\tPHPRuntime[RuntimeId] = id;\n\tloadedRuntimes.set(id, PHPRuntime);\n\treturn id;\n}\n\nexport type RuntimeType = 'NODE' | 'WEB' | 'WORKER';\n\ndeclare const self: WindowOrWorkerGlobalScope;\ndeclare const WorkerGlobalScope: object | undefined;\n\nexport type PHPRuntimeId = number;\n\nexport function getLoadedRuntime(id: PHPRuntimeId): PHPRuntime {\n\treturn loadedRuntimes.get(id);\n}\n\nexport const currentJsRuntime = (function () {\n\tif (typeof process !== 'undefined' && process.release?.name === 'node') {\n\t\treturn 'NODE';\n\t} else if (typeof window !== 'undefined') {\n\t\treturn 'WEB';\n\t} else if (\n\t\ttypeof WorkerGlobalScope !== 'undefined' &&\n\t\tself instanceof (WorkerGlobalScope as any)\n\t) {\n\t\treturn 'WORKER';\n\t} else {\n\t\treturn 'NODE';\n\t}\n})();\n\n/**\n * Creates and exposes Promise resolve/reject methods for later use.\n */\nconst makePromise = () => {\n\tconst methods: any = [];\n\n\tconst promise = new Promise((resolve, reject) => {\n\t\tmethods.push(resolve, reject);\n\t});\n\tmethods.unshift(promise);\n\n\treturn methods as [Promise<any>, (v?: any) => void, (e?: any) => void];\n};\n\nexport type PHPRuntime = any;\n\nexport type PHPLoaderModule = {\n\tdependencyFilename: string;\n\tdependenciesTotalSize: number;\n\tinit: (jsRuntime: string, options: EmscriptenOptions) => PHPRuntime;\n};\n\nexport type DataModule = {\n\tdependencyFilename: string;\n\tdependenciesTotalSize: number;\n\tdefault: (phpRuntime: PHPRuntime) => void;\n};\n\nexport type EmscriptenOptions = {\n\tonAbort?: (message: string) => void;\n\t/**\n\t * Set to true for debugging tricky WebAssembly errors.\n\t */\n\tdebug?: boolean;\n\tENV?: Record<string, string>;\n\tlocateFile?: (path: string) => string;\n\tnoInitialRun?: boolean;\n\tprint?: (message: string) => void;\n\tprintErr?: (message: string) => void;\n\tquit?: (status: number, toThrow: any) => void;\n\tonRuntimeInitialized?: (phpRuntime: PHPRuntime) => void;\n\tmonitorRunDependencies?: (left: number) => void;\n\tonMessage?: (listener: EmscriptenMessageListener) => void;\n\toutboundNetworkProxyServer?: Server<\n\t\ttypeof IncomingMessage,\n\t\ttypeof ServerResponse\n\t>;\n\tinstantiateWasm?: (\n\t\tinfo: WebAssembly.Imports,\n\t\treceiveInstance: (\n\t\t\tinstance: WebAssembly.Instance,\n\t\t\tmodule: WebAssembly.Module\n\t\t) => void\n\t) => void;\n} & Record<string, any>;\n\nexport type EmscriptenMessageListener = (type: string, data: string) => void;\n","/**\n * Polyfill for ReadableStream[Symbol.asyncIterator]\n * This enables the use of for-await-of loops with ReadableStreams\n *\n * @example\n * ```ts\n * for await (const entry of stream) {\n * \t   // ...\n * }\n * ```\n */\n// @ts-ignore\nif (!ReadableStream.prototype[Symbol.asyncIterator]) {\n\t// @ts-ignore\n\tReadableStream.prototype[Symbol.asyncIterator] = async function* () {\n\t\tconst reader = this.getReader();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tconst { done, value } = await reader.read();\n\t\t\t\tif (done) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tyield value;\n\t\t\t}\n\t\t} finally {\n\t\t\treader.releaseLock();\n\t\t}\n\t};\n\t// @ts-ignore\n\tReadableStream.prototype.iterate =\n\t\t// @ts-ignore\n\t\tReadableStream.prototype[Symbol.asyncIterator];\n}\n\nexport type IterableReadableStream<R> = ReadableStream<R> & AsyncIterable<R>;\n","import { Semaphore } from '@php-wasm/util';\nimport { filterStream } from '../utils/filter-stream';\nimport { concatUint8Array } from '../utils/concat-uint8-array';\nimport { collectBytes } from '../utils/collect-bytes';\nimport {\n\treadCentralDirectoryEntry,\n\treadFileEntry,\n\tdecodeZip,\n} from './decode-zip';\nimport type { CentralDirectoryEntry, FileEntry } from './types';\nimport { SIGNATURE_CENTRAL_DIRECTORY_END } from './types';\nimport type { IterableReadableStream } from '../utils/iterable-stream-polyfill';\n\nconst CENTRAL_DIRECTORY_END_SCAN_CHUNK_SIZE = 110 * 1024;\nconst BATCH_DOWNLOAD_OF_FILES_IF_CLOSER_THAN = 10 * 1024;\nconst PREFER_RANGES_IF_FILE_LARGER_THAN = 1024 * 1024 * 1;\nconst fetchSemaphore = new Semaphore({ concurrency: 10 });\n\nconst DEFAULT_PREDICATE = () => true;\n\n/**\n * Streams the contents of a remote zip file.\n *\n * If the zip is large and the predicate is filtering the zip contents,\n * only the matching files will be downloaded using the Range header\n * (if supported by the server).\n *\n * @param url The URL of the zip file.\n * @param predicate Optional. A function that returns true if the file should be downloaded.\n * @returns A stream of zip entries.\n */\nexport async function decodeRemoteZip(\n\turl: string,\n\tpredicate: (\n\t\tdirEntry: CentralDirectoryEntry | FileEntry\n\t) => boolean = DEFAULT_PREDICATE\n) {\n\tif (predicate === DEFAULT_PREDICATE) {\n\t\t// If we're not filtering the zip contents, let's just\n\t\t// grab the entire zip.\n\t\tconst response = await fetch(url);\n\t\treturn decodeZip(response.body!);\n\t}\n\n\tconst contentLength = await fetchContentLength(url);\n\tif (contentLength <= PREFER_RANGES_IF_FILE_LARGER_THAN) {\n\t\t// If the zip is small enough, let's just grab it.\n\t\tconst response = await fetch(url);\n\t\treturn decodeZip(response.body!);\n\t}\n\n\t// Ensure ranges query support:\n\t// Fetch one byte\n\tconst response = await fetch(url, {\n\t\theaders: {\n\t\t\t// 0-0 looks weird, doesn't it?\n\t\t\t// The Range header is inclusive so it's actually\n\t\t\t// a valid header asking for the first byte.\n\t\t\tRange: 'bytes=0-0',\n\t\t\t'Accept-Encoding': 'none',\n\t\t},\n\t});\n\n\t// Fork the stream so that we can reuse it in case\n\t// the Range header is unsupported and we're now streaming\n\t// the entire file\n\tconst [peekStream, responseStream] = response.body!.tee();\n\n\t// Read from the forked stream and close it.\n\tconst peekReader = peekStream.getReader();\n\tconst { value: peekBytes } = await peekReader.read();\n\tconst { done: peekDone } = await peekReader.read();\n\tpeekReader.releaseLock();\n\tpeekStream.cancel();\n\n\t// Confirm our Range query worked as intended:\n\tconst rangesSupported = peekBytes?.length === 1 && peekDone;\n\tif (!rangesSupported) {\n\t\t// Uh-oh, we're actually streaming the entire file.\n\t\t// Let's reuse the forked stream as our response stream.\n\t\treturn decodeZip(responseStream);\n\t}\n\n\t// We're good, let's clean up the other branch of the response stream.\n\tresponseStream.cancel();\n\tconst source = await createFetchSource(url, contentLength);\n\treturn streamCentralDirectoryEntries(source)\n\t\t.pipeThrough(filterStream(predicate))\n\t\t.pipeThrough(partitionNearbyEntries())\n\t\t.pipeThrough(\n\t\t\tfetchPartitionedEntries(source)\n\t\t) as IterableReadableStream<FileEntry>;\n}\n\n/**\n * Streams the central directory entries of a zip file.\n *\n * @param source\n * @returns\n */\nfunction streamCentralDirectoryEntries(source: BytesSource) {\n\tlet centralDirectoryStream: ReadableStream<Uint8Array>;\n\n\treturn new ReadableStream<CentralDirectoryEntry>({\n\t\tasync start() {\n\t\t\tcentralDirectoryStream = await streamCentralDirectoryBytes(source);\n\t\t},\n\t\tasync pull(controller) {\n\t\t\tconst entry = await readCentralDirectoryEntry(\n\t\t\t\tcentralDirectoryStream\n\t\t\t);\n\t\t\tif (!entry) {\n\t\t\t\tcontroller.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontroller.enqueue(entry);\n\t\t},\n\t});\n}\n\n/**\n * Streams the central directory bytes of a zip file.\n *\n * @param source\n * @returns\n */\nasync function streamCentralDirectoryBytes(source: BytesSource) {\n\tconst chunkSize = CENTRAL_DIRECTORY_END_SCAN_CHUNK_SIZE;\n\tlet centralDirectory: Uint8Array = new Uint8Array();\n\n\tlet chunkStart = source.length;\n\tdo {\n\t\tchunkStart = Math.max(0, chunkStart - chunkSize);\n\t\tconst chunkEnd = Math.min(\n\t\t\tchunkStart + chunkSize - 1,\n\t\t\tsource.length - 1\n\t\t);\n\t\tconst bytes = await collectBytes(\n\t\t\tawait source.streamBytes(chunkStart, chunkEnd)\n\t\t);\n\t\tcentralDirectory = concatUint8Array(bytes!, centralDirectory);\n\n\t\t// Scan the buffer for the signature\n\t\tconst view = new DataView(bytes!.buffer);\n\t\tfor (let i = view.byteLength - 4; i >= 0; i--) {\n\t\t\tif (view.getUint32(i, true) !== SIGNATURE_CENTRAL_DIRECTORY_END) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Confirm we have enough data to read the offset and the\n\t\t\t// length of the central directory.\n\t\t\tconst centralDirectoryLengthAt = i + 12;\n\t\t\tconst centralDirectoryOffsetAt = centralDirectoryLengthAt + 4;\n\t\t\tif (centralDirectory.byteLength < centralDirectoryOffsetAt + 4) {\n\t\t\t\tthrow new Error('Central directory not found');\n\t\t\t}\n\n\t\t\t// Read where the central directory starts\n\t\t\tconst dirStart = view.getUint32(centralDirectoryOffsetAt, true);\n\t\t\tif (dirStart < chunkStart) {\n\t\t\t\t// We're missing some bytes, let's grab them\n\t\t\t\tconst missingBytes = await collectBytes(\n\t\t\t\t\tawait source.streamBytes(dirStart, chunkStart - 1)\n\t\t\t\t);\n\t\t\t\tcentralDirectory = concatUint8Array(\n\t\t\t\t\tmissingBytes!,\n\t\t\t\t\tcentralDirectory\n\t\t\t\t);\n\t\t\t} else if (dirStart > chunkStart) {\n\t\t\t\t// We've read too many bytes, let's trim them\n\t\t\t\tcentralDirectory = centralDirectory.slice(\n\t\t\t\t\tdirStart - chunkStart\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn new Blob([centralDirectory]).stream();\n\t\t}\n\t} while (chunkStart >= 0);\n\n\tthrow new Error('Central directory not found');\n}\n\n/**\n * Partitions files that are no further apart in the zip\n * archive than BATCH_DOWNLOAD_OF_FILES_IF_CLOSER_THAN.\n * It may download some extra files living within the gaps\n * between the partitions.\n */\nfunction partitionNearbyEntries() {\n\tlet lastFileEndsAt = 0;\n\tlet currentChunk: CentralDirectoryEntry[] = [];\n\treturn new TransformStream<CentralDirectoryEntry, CentralDirectoryEntry[]>({\n\t\ttransform(zipEntry, controller) {\n\t\t\t// Byte distance too large, flush and start a new chunk\n\t\t\tif (\n\t\t\t\tzipEntry.firstByteAt >\n\t\t\t\tlastFileEndsAt + BATCH_DOWNLOAD_OF_FILES_IF_CLOSER_THAN\n\t\t\t) {\n\t\t\t\tcontroller.enqueue(currentChunk);\n\t\t\t\tcurrentChunk = [];\n\t\t\t}\n\t\t\tlastFileEndsAt = zipEntry.lastByteAt;\n\t\t\tcurrentChunk.push(zipEntry);\n\t\t},\n\t\tflush(controller) {\n\t\t\tcontroller.enqueue(currentChunk);\n\t\t},\n\t});\n}\n\n/**\n * Fetches a chunk of files from the zip archive.\n *\n * If any extra files are present in the received\n * bytes stream, they are filtered out.\n */\nfunction fetchPartitionedEntries(\n\tsource: BytesSource\n): ReadableWritablePair<FileEntry, CentralDirectoryEntry[]> {\n\t/**\n\t * This function implements a ReadableStream and a WritableStream\n\t * instead of a TransformStream. This is intentional.\n\t *\n\t * In TransformStream, the `transform` function may return a\n\t * promise. The next call to `transform` will be delayed until\n\t * the promise resolves. This is a problem for us because we\n\t * want to issue many fetch() requests in parallel.\n\t *\n\t * The only way to do that seems to be creating separate ReadableStream\n\t * and WritableStream implementations.\n\t */\n\tlet isWritableClosed = false;\n\tlet requestsInProgress = 0;\n\tlet readableController: ReadableStreamDefaultController<FileEntry>;\n\tconst byteStreams: Array<\n\t\t[CentralDirectoryEntry[], ReadableStream<Uint8Array>]\n\t> = [];\n\t/**\n\t * Receives chunks of CentralDirectoryEntries, and fetches\n\t * the corresponding byte ranges from the remote zip file.\n\t */\n\tconst writable = new WritableStream<CentralDirectoryEntry[]>({\n\t\twrite(zipEntries, controller) {\n\t\t\tif (!zipEntries.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t++requestsInProgress;\n\t\t\t// If the write() method returns a promise, the next\n\t\t\t// call will be delayed until the promise resolves.\n\t\t\t// Let's not return the promise, then.\n\t\t\t// This will effectively issue many requests in parallel.\n\t\t\trequestChunkRange(source, zipEntries)\n\t\t\t\t.then((byteStream) => {\n\t\t\t\t\tbyteStreams.push([zipEntries, byteStream]);\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\tcontroller.error(e);\n\t\t\t\t})\n\t\t\t\t.finally(() => {\n\t\t\t\t\t--requestsInProgress;\n\t\t\t\t});\n\t\t},\n\t\tabort() {\n\t\t\tisWritableClosed = true;\n\t\t\treadableController.close();\n\t\t},\n\t\tasync close() {\n\t\t\tisWritableClosed = true;\n\t\t},\n\t});\n\t/**\n\t * Decodes zipped bytes into FileEntry objects.\n\t */\n\tconst readable = new ReadableStream<FileEntry>({\n\t\tstart(controller) {\n\t\t\treadableController = controller;\n\t\t},\n\t\tasync pull(controller) {\n\t\t\twhile (true) {\n\t\t\t\tconst allChunksProcessed =\n\t\t\t\t\tisWritableClosed &&\n\t\t\t\t\t!byteStreams.length &&\n\t\t\t\t\trequestsInProgress === 0;\n\t\t\t\tif (allChunksProcessed) {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// There's no bytes available, but the writable\n\t\t\t\t// stream is still open or there are still requests\n\t\t\t\t// in progress. Let's wait for more bytes.\n\t\t\t\tconst waitingForMoreBytes = !byteStreams.length;\n\t\t\t\tif (waitingForMoreBytes) {\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 50));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst [requestedPaths, stream] = byteStreams[0];\n\t\t\t\tconst file = await readFileEntry(stream);\n\t\t\t\t// The stream is exhausted, let's remove it from the queue\n\t\t\t\t// and try the next one.\n\t\t\t\tconst streamExhausted = !file;\n\t\t\t\tif (streamExhausted) {\n\t\t\t\t\tbyteStreams.shift();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// There may be some extra files between the ones we're\n\t\t\t\t// interested in. Let's filter out any files that got\n\t\t\t\t// intertwined in the byte stream.\n\t\t\t\tconst isOneOfRequestedPaths = requestedPaths.find(\n\t\t\t\t\t(entry) => entry.path === file.path\n\t\t\t\t);\n\t\t\t\tif (!isOneOfRequestedPaths) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Finally! We've got a file we're interested in.\n\t\t\t\tcontroller.enqueue(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\t});\n\n\treturn {\n\t\treadable,\n\t\twritable,\n\t};\n}\n\n/**\n * Requests a chunk of bytes from the bytes source.\n *\n * @param source\n * @param zipEntries\n */\nasync function requestChunkRange(\n\tsource: BytesSource,\n\tzipEntries: CentralDirectoryEntry[]\n) {\n\tconst release = await fetchSemaphore.acquire();\n\ttry {\n\t\tconst lastZipEntry = zipEntries[zipEntries.length - 1];\n\t\tconst substream = await source.streamBytes(\n\t\t\tzipEntries[0].firstByteAt,\n\t\t\tlastZipEntry.lastByteAt\n\t\t);\n\t\treturn substream;\n\t} finally {\n\t\trelease();\n\t}\n}\n\n/**\n * Fetches the Content-Length header from a remote URL.\n */\nasync function fetchContentLength(url: string) {\n\treturn await fetch(url, { method: 'HEAD' })\n\t\t.then((response) => response.headers.get('Content-Length'))\n\t\t.then((contentLength) => {\n\t\t\tif (!contentLength) {\n\t\t\t\tthrow new Error('Content-Length header is missing');\n\t\t\t}\n\n\t\t\tconst parsedLength = parseInt(contentLength, 10);\n\t\t\tif (isNaN(parsedLength) || parsedLength < 0) {\n\t\t\t\tthrow new Error('Content-Length header is invalid');\n\t\t\t}\n\t\t\treturn parsedLength;\n\t\t});\n}\n\n/**\n * Private and experimental API: Range-based data sources.\n *\n * The idea is that if we can read arbitrary byte ranges from\n * a file, we can retrieve a specific subset of a zip file.\n */\ntype BytesSource = {\n\tlength: number;\n\tstreamBytes: (\n\t\tstart: number,\n\t\tend: number\n\t) => Promise<ReadableStream<Uint8Array>>;\n};\n\n/**\n * Creates a BytesSource enabling fetching ranges of bytes\n * from a remote URL.\n */\nasync function createFetchSource(\n\turl: string,\n\tcontentLength?: number\n): Promise<BytesSource> {\n\tif (contentLength === undefined) {\n\t\tcontentLength = await fetchContentLength(url);\n\t}\n\n\treturn {\n\t\tlength: contentLength,\n\t\tstreamBytes: async (from: number, to: number) =>\n\t\t\tawait fetch(url, {\n\t\t\t\theaders: {\n\t\t\t\t\t// The Range header is inclusive, so we need to subtract 1\n\t\t\t\t\tRange: `bytes=${from}-${to - 1}`,\n\t\t\t\t\t'Accept-Encoding': 'none',\n\t\t\t\t},\n\t\t\t}).then((response) => response.body!),\n\t};\n}\n","import { dirname, joinPaths } from '@php-wasm/util';\nimport {\n\tensurePathPrefix,\n\ttoRelativeUrl,\n\tremovePathPrefix,\n\tDEFAULT_BASE_URL,\n} from './urls';\nimport type { PHP, PHPExecutionFailureError } from './php';\nimport { normalizeHeaders } from './php';\nimport { PHPResponse } from './php-response';\nimport type { PHPRequest, PHPRunOptions } from './universal-php';\nimport { encodeAsMultipart } from './encode-as-multipart';\nimport type { PHPFactoryOptions, SpawnedPHP } from './php-process-manager';\nimport { MaxPhpInstancesError, PHPProcessManager } from './php-process-manager';\nimport { HttpCookieStore } from './http-cookie-store';\nimport mimeTypes from './mime-types.json';\n\nexport type RewriteRule = {\n\tmatch: RegExp;\n\treplacement: string;\n};\n\nexport type FileNotFoundToResponse = {\n\ttype: 'response';\n\tresponse: PHPResponse;\n};\nexport type FileNotFoundToInternalRedirect = {\n\ttype: 'internal-redirect';\n\turi: string;\n};\nexport type FileNotFoundTo404 = { type: '404' };\n\nexport type FileNotFoundAction =\n\t| FileNotFoundToResponse\n\t| FileNotFoundToInternalRedirect\n\t| FileNotFoundTo404;\n\nexport type FileNotFoundGetActionCallback = (\n\trelativePath: string\n) => FileNotFoundAction;\n\n/**\n * Interface for cookie storage implementations.\n * This allows different cookie handling strategies to be used with the PHP request handler.\n */\nexport interface CookieStore {\n\t/**\n\t * Processes and stores cookies from response headers\n\t * @param headers Response headers containing Set-Cookie directives\n\t */\n\trememberCookiesFromResponseHeaders(headers: Record<string, string[]>): void;\n\n\t/**\n\t * Gets the cookie header string for the next request\n\t * @returns Formatted cookie header string\n\t */\n\tgetCookieRequestHeader(): string;\n}\n\ninterface BaseConfiguration {\n\t/**\n\t * The directory in the PHP filesystem where the server will look\n\t * for the files to serve. Default: `/var/www`.\n\t */\n\tdocumentRoot?: string;\n\t/**\n\t * Request Handler URL. Used to populate $_SERVER details like HTTP_HOST.\n\t */\n\tabsoluteUrl?: string;\n\n\t/**\n\t * Rewrite rules\n\t */\n\trewriteRules?: RewriteRule[];\n\n\t/**\n\t * A callback that decides how to handle a file-not-found condition for a\n\t * given request URI.\n\t */\n\tgetFileNotFoundAction?: FileNotFoundGetActionCallback;\n}\n\nexport type PHPRequestHandlerFactoryArgs = PHPFactoryOptions & {\n\trequestHandler: PHPRequestHandler;\n};\n\nexport type PHPRequestHandlerConfiguration = BaseConfiguration &\n\t(\n\t\t| {\n\t\t\t\t/**\n\t\t\t\t * PHPProcessManager is required because the request handler needs\n\t\t\t\t * to make a decision for each request.\n\t\t\t\t *\n\t\t\t\t * Static assets are served using the primary PHP's filesystem, even\n\t\t\t\t * when serving 100 static files concurrently. No new PHP interpreter\n\t\t\t\t * is ever created as there's no need for it.\n\t\t\t\t *\n\t\t\t\t * Dynamic PHP requests, however, require grabbing an available PHP\n\t\t\t\t * interpreter, and that's where the PHPProcessManager comes in.\n\t\t\t\t */\n\t\t\t\tprocessManager: PHPProcessManager;\n\t\t  }\n\t\t| {\n\t\t\t\tphpFactory: (\n\t\t\t\t\trequestHandler: PHPRequestHandlerFactoryArgs\n\t\t\t\t) => Promise<PHP>;\n\t\t\t\t/**\n\t\t\t\t * The maximum number of PHP instances that can exist at\n\t\t\t\t * the same time.\n\t\t\t\t */\n\t\t\t\tmaxPhpInstances?: number;\n\t\t  }\n\t) & {\n\t\tcookieStore?: CookieStore | false;\n\t};\n\n/**\n * Handles HTTP requests using PHP runtime as a backend.\n *\n * @public\n * @example Use PHPRequestHandler implicitly with a new PHP instance:\n * ```js\n * import { PHP } from '@php-wasm/web';\n *\n * const php = await PHP.load( '7.4', {\n *     requestHandler: {\n *         // PHP FS path to serve the files from:\n *         documentRoot: '/www',\n *\n *         // Used to populate $_SERVER['SERVER_NAME'] etc.:\n *         absoluteUrl: 'http://127.0.0.1'\n *     }\n * } );\n *\n * php.mkdirTree('/www');\n * php.writeFile('/www/index.php', '<?php echo \"Hi from PHP!\"; ');\n *\n * const response = await php.request({ path: '/index.php' });\n * console.log(response.text);\n * // \"Hi from PHP!\"\n * ```\n *\n * @example Explicitly create a PHPRequestHandler instance and run a PHP script:\n * ```js\n * import {\n *   loadPHPRuntime,\n *   PHP,\n *   PHPRequestHandler,\n *   getPHPLoaderModule,\n * } from '@php-wasm/web';\n *\n * const runtime = await loadPHPRuntime( await getPHPLoaderModule('7.4') );\n * const php = new PHP( runtime );\n *\n * php.mkdirTree('/www');\n * php.writeFile('/www/index.php', '<?php echo \"Hi from PHP!\"; ');\n *\n * const server = new PHPRequestHandler(php, {\n *     // PHP FS path to serve the files from:\n *     documentRoot: '/www',\n *\n *     // Used to populate $_SERVER['SERVER_NAME'] etc.:\n *     absoluteUrl: 'http://127.0.0.1'\n * });\n *\n * const response = server.request({ path: '/index.php' });\n * console.log(response.text);\n * // \"Hi from PHP!\"\n * ```\n */\nexport class PHPRequestHandler implements AsyncDisposable {\n\t#DOCROOT: string;\n\t#PROTOCOL: string;\n\t#HOSTNAME: string;\n\t#PORT: number;\n\t#HOST: string;\n\t#PATHNAME: string;\n\t#ABSOLUTE_URL: string;\n\t#cookieStore: CookieStore | false;\n\trewriteRules: RewriteRule[];\n\tprocessManager: PHPProcessManager;\n\tgetFileNotFoundAction: FileNotFoundGetActionCallback;\n\n\t/**\n\t * The request handler needs to decide whether to serve a static asset or\n\t * run the PHP interpreter. For static assets it should just reuse the primary\n\t * PHP even if there's 50 concurrent requests to serve. However, for\n\t * dynamic PHP requests, it needs to grab an available interpreter.\n\t * Therefore, it cannot just accept PHP as an argument as serving requests\n\t * requires access to ProcessManager.\n\t *\n\t * @param  php    - The PHP instance.\n\t * @param  config - Request Handler configuration.\n\t */\n\tconstructor(config: PHPRequestHandlerConfiguration) {\n\t\tconst {\n\t\t\tdocumentRoot = '/www/',\n\t\t\tabsoluteUrl = typeof location === 'object'\n\t\t\t\t? location.href\n\t\t\t\t: DEFAULT_BASE_URL,\n\t\t\trewriteRules = [],\n\t\t\tgetFileNotFoundAction = () => ({ type: '404' }),\n\t\t} = config;\n\n\t\tif ('processManager' in config) {\n\t\t\tthis.processManager = config.processManager;\n\t\t} else {\n\t\t\tthis.processManager = new PHPProcessManager({\n\t\t\t\tphpFactory: async (info) => {\n\t\t\t\t\tconst php = await config.phpFactory!({\n\t\t\t\t\t\t...info,\n\t\t\t\t\t\trequestHandler: this,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Always set managed PHP's cwd to the document root.\n\t\t\t\t\tif (!php.isDir(documentRoot)) {\n\t\t\t\t\t\tphp.mkdir(documentRoot);\n\t\t\t\t\t}\n\t\t\t\t\tphp.chdir(documentRoot);\n\n\t\t\t\t\t// @TODO: Decouple PHP and request handler\n\t\t\t\t\t(php as any).requestHandler = this;\n\t\t\t\t\treturn php;\n\t\t\t\t},\n\t\t\t\tmaxPhpInstances: config.maxPhpInstances,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * By default, config.cookieStore is undefined, so we use the\n\t\t * HttpCookieStore implementation, otherwise we use the one\n\t\t * provided in the config.\n\t\t *\n\t\t * By explicitly checking for `undefined` we allow the user to pass\n\t\t * `null` as config.cookieStore and disable the cookie store.\n\t\t */\n\t\tthis.#cookieStore =\n\t\t\tconfig.cookieStore === undefined\n\t\t\t\t? new HttpCookieStore()\n\t\t\t\t: config.cookieStore;\n\t\tthis.#DOCROOT = documentRoot;\n\n\t\tconst url = new URL(absoluteUrl);\n\t\tthis.#HOSTNAME = url.hostname;\n\t\tthis.#PORT = url.port\n\t\t\t? Number(url.port)\n\t\t\t: url.protocol === 'https:'\n\t\t\t? 443\n\t\t\t: 80;\n\t\tthis.#PROTOCOL = (url.protocol || '').replace(':', '');\n\t\tconst isNonStandardPort = this.#PORT !== 443 && this.#PORT !== 80;\n\t\tthis.#HOST = [\n\t\t\tthis.#HOSTNAME,\n\t\t\tisNonStandardPort ? `:${this.#PORT}` : '',\n\t\t].join('');\n\t\tthis.#PATHNAME = url.pathname.replace(/\\/+$/, '');\n\t\tthis.#ABSOLUTE_URL = [\n\t\t\t`${this.#PROTOCOL}://`,\n\t\t\tthis.#HOST,\n\t\t\tthis.#PATHNAME,\n\t\t].join('');\n\t\tthis.rewriteRules = rewriteRules;\n\t\tthis.getFileNotFoundAction = getFileNotFoundAction;\n\t}\n\n\tasync getPrimaryPhp() {\n\t\treturn await this.processManager.getPrimaryPhp();\n\t}\n\n\t/**\n\t * Converts a path to an absolute URL based at the PHPRequestHandler\n\t * root.\n\t *\n\t * @param  path The server path to convert to an absolute URL.\n\t * @returns The absolute URL.\n\t */\n\tpathToInternalUrl(path: string): string {\n\t\tif (!path.startsWith('/')) {\n\t\t\tpath = `/${path}`;\n\t\t}\n\t\treturn `${this.absoluteUrl}${path}`;\n\t}\n\n\t/**\n\t * Converts an absolute URL based at the PHPRequestHandler to a relative path\n\t * without the server pathname and scope.\n\t *\n\t * @param  internalUrl An absolute URL based at the PHPRequestHandler root.\n\t * @returns The relative path.\n\t */\n\tinternalUrlToPath(internalUrl: string): string {\n\t\tconst url = new URL(internalUrl, 'https://playground.internal');\n\t\tif (url.pathname.startsWith(this.#PATHNAME)) {\n\t\t\turl.pathname = url.pathname.slice(this.#PATHNAME.length);\n\t\t}\n\t\treturn toRelativeUrl(url);\n\t}\n\n\t/**\n\t * The absolute URL of this PHPRequestHandler instance.\n\t */\n\tget absoluteUrl() {\n\t\treturn this.#ABSOLUTE_URL;\n\t}\n\n\t/**\n\t * The directory in the PHP filesystem where the server will look\n\t * for the files to serve. Default: `/var/www`.\n\t */\n\tget documentRoot() {\n\t\treturn this.#DOCROOT;\n\t}\n\n\t/**\n\t * Serves the request – either by serving a static file, or by\n\t * dispatching it to the PHP runtime.\n\t *\n\t * The request() method mode behaves like a web server and only works if\n\t * the PHP was initialized with a `requestHandler` option (which the online\n\t * version of WordPress Playground does by default).\n\t *\n\t * In the request mode, you pass an object containing the request information\n\t * (method, headers, body, etc.) and the path to the PHP file to run:\n\t *\n\t * ```ts\n\t * const php = PHP.load('7.4', {\n\t * \trequestHandler: {\n\t * \t\tdocumentRoot: \"/www\"\n\t * \t}\n\t * })\n\t * php.writeFile(\"/www/index.php\", `<?php echo file_get_contents(\"php://input\");`);\n\t * const result = await php.request({\n\t * \tmethod: \"GET\",\n\t * \theaders: {\n\t * \t\t\"Content-Type\": \"text/plain\"\n\t * \t},\n\t * \tbody: \"Hello world!\",\n\t * \tpath: \"/www/index.php\"\n\t * });\n\t * // result.text === \"Hello world!\"\n\t * ```\n\t *\n\t * The `request()` method cannot be used in conjunction with `cli()`.\n\t *\n\t * @example\n\t * ```js\n\t * const output = await php.request({\n\t * \tmethod: 'GET',\n\t * \turl: '/index.php',\n\t * \theaders: {\n\t * \t\t'X-foo': 'bar',\n\t * \t},\n\t * \tbody: {\n\t * \t\tfoo: 'bar',\n\t * \t},\n\t * });\n\t * console.log(output.stdout); // \"Hello world!\"\n\t * ```\n\t *\n\t * @param  request - PHP Request data.\n\t */\n\tasync request(request: PHPRequest): Promise<PHPResponse> {\n\t\tconst isAbsolute = looksLikeAbsoluteUrl(request.url);\n\t\tconst originalRequestUrl = new URL(\n\t\t\t// Remove the hash part of the URL as it's not meant for the server.\n\t\t\trequest.url.split('#')[0],\n\t\t\tisAbsolute ? undefined : DEFAULT_BASE_URL\n\t\t);\n\n\t\tconst rewrittenRequestUrl = this.#applyRewriteRules(originalRequestUrl);\n\t\tconst primaryPhp = await this.getPrimaryPhp();\n\t\tlet fsPath = joinPaths(\n\t\t\tthis.#DOCROOT,\n\t\t\t/**\n\t\t\t * Turn a URL such as `https://playground/scope:my-site/wp-admin/index.php`\n\t\t\t * into a site-relative path, such as `/wp-admin/index.php`.\n\t\t\t */\n\t\t\tremovePathPrefix(\n\t\t\t\t/**\n\t\t\t\t * URL.pathname returns a URL-encoded path. We need to decode it\n\t\t\t\t * before using it as a filesystem path.\n\t\t\t\t */\n\t\t\t\tdecodeURIComponent(rewrittenRequestUrl.pathname),\n\t\t\t\tthis.#PATHNAME\n\t\t\t)\n\t\t);\n\t\tif (primaryPhp.isDir(fsPath)) {\n\t\t\t// Ensure directory URIs have a trailing slash. Otherwise,\n\t\t\t// relative URIs in index.php or index.html files are relative\n\t\t\t// to the next directory up.\n\t\t\t//\n\t\t\t// Example:\n\t\t\t// For an index page served for URI \"/settings\", we naturally expect\n\t\t\t// links to be relative to \"/settings\", but without the trailing\n\t\t\t// slash, a relative link \"edit.php\" resolves to \"/edit.php\"\n\t\t\t// rather than \"/settings/edit.php\".\n\t\t\t//\n\t\t\t// This treatment of relative links is correct behavior for the browser:\n\t\t\t// https://www.rfc-editor.org/rfc/rfc3986#section-5.2.3\n\t\t\t//\n\t\t\t// But user intent for `/settings/index.php` is that its relative\n\t\t\t// URIs are relative to `/settings/`. So we redirect to add a\n\t\t\t// trailing slash to directory URIs to meet this expecatation.\n\t\t\t//\n\t\t\t// This behavior is also necessary for WordPress to function properly.\n\t\t\t// Otherwise, when viewing the WP admin dashboard at `/wp-admin`,\n\t\t\t// links to other admin pages like `edit.php` will incorrectly\n\t\t\t// resolve to `/edit.php` rather than `/wp-admin/edit.php`.\n\t\t\tif (!fsPath.endsWith('/')) {\n\t\t\t\treturn new PHPResponse(\n\t\t\t\t\t301,\n\t\t\t\t\t{ Location: [`${rewrittenRequestUrl.pathname}/`] },\n\t\t\t\t\tnew Uint8Array(0)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// We can only satisfy requests for directories with a default file\n\t\t\t// so let's first resolve to a default path when available.\n\t\t\tfor (const possibleIndexFile of ['index.php', 'index.html']) {\n\t\t\t\tconst possibleIndexPath = joinPaths(fsPath, possibleIndexFile);\n\t\t\t\tif (primaryPhp.isFile(possibleIndexPath)) {\n\t\t\t\t\tfsPath = possibleIndexPath;\n\n\t\t\t\t\t// Include the resolved index file in the final rewritten request URL.\n\t\t\t\t\trewrittenRequestUrl.pathname = joinPaths(\n\t\t\t\t\t\trewrittenRequestUrl.pathname,\n\t\t\t\t\t\tpossibleIndexFile\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!primaryPhp.isFile(fsPath)) {\n\t\t\t/**\n\t\t\t * Try resolving a partial path.\n\t\t\t *\n\t\t\t * Example:\n\t\t\t *\n\t\t\t * – Request URL: /file.php/index.php\n\t\t\t * – Document Root: /var/www\n\t\t\t *\n\t\t\t * If /var/www/file.php/index.php does not exist, but /var/www/file.php does,\n\t\t\t * use /var/www/file.php. This is also what Apache and PHP Dev Server do.\n\t\t\t */\n\t\t\tlet pathToTry = rewrittenRequestUrl.pathname;\n\t\t\twhile (\n\t\t\t\tpathToTry.startsWith('/') &&\n\t\t\t\tpathToTry !== dirname(pathToTry)\n\t\t\t) {\n\t\t\t\tpathToTry = dirname(pathToTry);\n\t\t\t\tconst resolvedPathToTry = joinPaths(this.#DOCROOT, pathToTry);\n\t\t\t\tif (\n\t\t\t\t\tprimaryPhp.isFile(resolvedPathToTry) &&\n\t\t\t\t\t// Only run partial path resolution for PHP files.\n\t\t\t\t\tresolvedPathToTry.endsWith('.php')\n\t\t\t\t) {\n\t\t\t\t\tfsPath = joinPaths(this.#DOCROOT, pathToTry);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!primaryPhp.isFile(fsPath)) {\n\t\t\tconst fileNotFoundAction = this.getFileNotFoundAction(\n\t\t\t\trewrittenRequestUrl.pathname\n\t\t\t);\n\t\t\tswitch (fileNotFoundAction.type) {\n\t\t\t\tcase 'response':\n\t\t\t\t\treturn fileNotFoundAction.response;\n\t\t\t\tcase 'internal-redirect':\n\t\t\t\t\tfsPath = joinPaths(this.#DOCROOT, fileNotFoundAction.uri);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '404':\n\t\t\t\t\treturn PHPResponse.forHttpCode(404);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Unsupported file-not-found action type: ' +\n\t\t\t\t\t\t\t// Cast because TS asserts the remaining possibility is `never`\n\t\t\t\t\t\t\t`'${\n\t\t\t\t\t\t\t\t(fileNotFoundAction as FileNotFoundAction).type\n\t\t\t\t\t\t\t}'`\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// We need to confirm that the current target file exists because\n\t\t// file-not-found fallback actions may redirect to non-existent files.\n\t\tif (primaryPhp.isFile(fsPath)) {\n\t\t\tif (fsPath.endsWith('.php')) {\n\t\t\t\tconst response = await this.#spawnPHPAndDispatchRequest(\n\t\t\t\t\trequest,\n\t\t\t\t\toriginalRequestUrl,\n\t\t\t\t\trewrittenRequestUrl,\n\t\t\t\t\tfsPath\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * If the response is but the exit code is non-zero, let's rewrite the\n\t\t\t\t * HTTP status code as 500. We're acting as a HTTP server here and\n\t\t\t\t * this behavior is in line with what Nginx and Apache do.\n\t\t\t\t */\n\t\t\t\tif (response.ok() && response.exitCode !== 0) {\n\t\t\t\t\treturn new PHPResponse(\n\t\t\t\t\t\t500,\n\t\t\t\t\t\tresponse.headers,\n\t\t\t\t\t\tresponse.bytes,\n\t\t\t\t\t\tresponse.errors,\n\t\t\t\t\t\tresponse.exitCode\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn response;\n\t\t\t} else {\n\t\t\t\treturn this.#serveStaticFile(primaryPhp, fsPath);\n\t\t\t}\n\t\t} else {\n\t\t\treturn PHPResponse.forHttpCode(404);\n\t\t}\n\t}\n\n\t/**\n\t * Apply the rewrite rules to the original request URL.\n\t *\n\t * @param originalRequestUrl - The original request URL.\n\t * @returns The rewritten request URL.\n\t */\n\t#applyRewriteRules(originalRequestUrl: URL): URL {\n\t\tconst siteRelativePath = removePathPrefix(\n\t\t\tdecodeURIComponent(originalRequestUrl.pathname),\n\t\t\tthis.#PATHNAME\n\t\t);\n\t\tconst rewrittenRequestPath = applyRewriteRules(\n\t\t\tsiteRelativePath,\n\t\t\tthis.rewriteRules\n\t\t);\n\t\tconst rewrittenRequestUrl = new URL(\n\t\t\tjoinPaths(this.#PATHNAME, rewrittenRequestPath),\n\t\t\toriginalRequestUrl.toString()\n\t\t);\n\t\t// Merge the query string parameters from the original request URL.\n\t\tfor (const [key, value] of originalRequestUrl.searchParams.entries()) {\n\t\t\trewrittenRequestUrl.searchParams.append(key, value);\n\t\t}\n\t\treturn rewrittenRequestUrl;\n\t}\n\n\t/**\n\t * Serves a static file from the PHP filesystem.\n\t *\n\t * @param  fsPath - Absolute path of the static file to serve.\n\t * @returns The response.\n\t */\n\t#serveStaticFile(php: PHP, fsPath: string): PHPResponse {\n\t\tconst arrayBuffer = php.readFileAsBuffer(fsPath);\n\t\treturn new PHPResponse(\n\t\t\t200,\n\t\t\t{\n\t\t\t\t'content-length': [`${arrayBuffer.byteLength}`],\n\t\t\t\t// @TODO: Infer the content-type from the arrayBuffer instead of the\n\t\t\t\t// file path. The code below won't return the correct mime-type if the\n\t\t\t\t// extension was tampered with.\n\t\t\t\t'content-type': [inferMimeType(fsPath)],\n\t\t\t\t'accept-ranges': ['bytes'],\n\t\t\t\t'cache-control': ['public, max-age=0'],\n\t\t\t},\n\t\t\tarrayBuffer\n\t\t);\n\t}\n\n\t/**\n\t * Spawns a new PHP instance and dispatches a request to it.\n\t */\n\tasync #spawnPHPAndDispatchRequest(\n\t\trequest: PHPRequest,\n\t\toriginalRequestUrl: URL,\n\t\trewrittenRequestUrl: URL,\n\t\tscriptPath: string\n\t): Promise<PHPResponse> {\n\t\tlet spawnedPHP: SpawnedPHP | undefined = undefined;\n\t\ttry {\n\t\t\tspawnedPHP = await this.processManager!.acquirePHPInstance({\n\t\t\t\tconsiderPrimary: true,\n\t\t\t});\n\t\t} catch (e) {\n\t\t\tif (e instanceof MaxPhpInstancesError) {\n\t\t\t\treturn PHPResponse.forHttpCode(502);\n\t\t\t} else {\n\t\t\t\treturn PHPResponse.forHttpCode(500);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\treturn await this.#dispatchToPHP(\n\t\t\t\tspawnedPHP.php,\n\t\t\t\trequest,\n\t\t\t\toriginalRequestUrl,\n\t\t\t\trewrittenRequestUrl,\n\t\t\t\tscriptPath\n\t\t\t);\n\t\t} finally {\n\t\t\tspawnedPHP.reap();\n\t\t}\n\t}\n\n\t/**\n\t * Runs the requested PHP file with all the request and $_SERVER\n\t * superglobals populated.\n\t *\n\t * @param  request - The request.\n\t * @returns The response.\n\t */\n\tasync #dispatchToPHP(\n\t\tphp: PHP,\n\t\trequest: PHPRequest,\n\t\toriginalRequestUrl: URL,\n\t\trewrittenRequestUrl: URL,\n\t\tscriptPath: string\n\t): Promise<PHPResponse> {\n\t\tlet preferredMethod: PHPRunOptions['method'] = 'GET';\n\n\t\tconst headers: Record<string, string> = {\n\t\t\thost: this.#HOST,\n\t\t\t...normalizeHeaders(request.headers || {}),\n\t\t};\n\t\tif (this.#cookieStore) {\n\t\t\theaders['cookie'] = this.#cookieStore.getCookieRequestHeader();\n\t\t}\n\n\t\tlet body = request.body;\n\t\tif (typeof body === 'object' && !(body instanceof Uint8Array)) {\n\t\t\tpreferredMethod = 'POST';\n\t\t\tconst { bytes, contentType } = await encodeAsMultipart(body);\n\t\t\tbody = bytes;\n\t\t\theaders['content-type'] = contentType;\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await php.run({\n\t\t\t\trelativeUri: ensurePathPrefix(\n\t\t\t\t\ttoRelativeUrl(new URL(rewrittenRequestUrl.toString())),\n\t\t\t\t\tthis.#PATHNAME\n\t\t\t\t),\n\t\t\t\tprotocol: this.#PROTOCOL,\n\t\t\t\tmethod: request.method || preferredMethod,\n\t\t\t\t$_SERVER: this.prepare_$_SERVER_superglobal(\n\t\t\t\t\toriginalRequestUrl,\n\t\t\t\t\trewrittenRequestUrl,\n\t\t\t\t\tscriptPath\n\t\t\t\t),\n\t\t\t\tbody,\n\t\t\t\tscriptPath,\n\t\t\t\theaders,\n\t\t\t});\n\t\t\tif (this.#cookieStore) {\n\t\t\t\tthis.#cookieStore.rememberCookiesFromResponseHeaders(\n\t\t\t\t\tresponse.headers\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\tconst executionError = error as PHPExecutionFailureError;\n\t\t\tif (executionError?.response) {\n\t\t\t\treturn executionError.response;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\t/**\n\t * Computes the essential $_SERVER entries for a request.\n\t *\n\t * php_wasm.c sets some defaults, assuming it runs as a CLI script.\n\t * This function overrides them with the values correct in the request\n\t * context.\n\t *\n\t * @TODO: Consolidate the $_SERVER setting logic into a single place instead\n\t *        of splitting it between the C SAPI and the TypeScript code. The PHP\n\t *        class has a `.cli()` method that could take care of the CLI-specific\n\t *        $_SERVER values.\n\t *\n\t * Path and URL-related $_SERVER entries are theoretically documented\n\t * at https://www.php.net/manual/en/reserved.variables.server.php,\n\t * but that page is not very helpful in practice. Here are tables derived\n\t * by interacting with PHP servers:\n\t *\n\t * ## PHP Dev Server\n\t *\n\t * Setup:\n\t *   – `/home/adam/subdir/script.php` file contains `<?php phpinfo(); ?>`\n\t *   – `php -S 127.0.0.1:8041` running in `/home/adam` directory\n\t *   – A request is sent to `http://127.0.0.1:8041/subdir/script.php/b.php/c.php`\n\t *\n\t * Results:\n\t *\n\t * $_SERVER['REQUEST_URI']    | `/subdir/script.php/b.php/c.php`\n\t * $_SERVER['SCRIPT_NAME']    | `/subdir/script.php`\n\t * $_SERVER['SCRIPT_FILENAME']| `/home/adam/subdir/script.php`\n\t * $_SERVER['PATH_INFO']      | `/b.php/c.php`\n\t * $_SERVER['PHP_SELF']       | `/subdir/script.php/b.php/c.php`\n\t *\n\t * ## Apache – rewriting rules\n\t *\n\t * Setup:\n\t *   – `/var/www/html/subdir/script.php` file contains `<?php phpinfo(); ?>`\n\t *   – Apache is listening on port 8041\n\t *   – The document root is `/var/www/html`\n\t *   – A request is sent to `http://127.0.0.1:8041/api/v1/user/123`\n\t *\n\t * .htaccess file:\n\t *\n\t * ```apache\n\t * RewriteEngine On\n\t * RewriteRule ^api/v1/user/([0-9]+)$ /subdir/script.php?endpoint=user&id=$1 [L,QSA]\n\t * ```\n\t *\n\t * Results:\n\t *\n\t * ```\n\t * $_SERVER['REQUEST_URI']             | /api/v1/user/123\n\t * $_SERVER['SCRIPT_NAME']             | /subdir/script.php\n\t * $_SERVER['SCRIPT_FILENAME']         | /var/www/html/subdir/script.php\n\t * $_SERVER['PATH_INFO']               | (key not set)\n\t * $_SERVER['PHP_SELF']                | /subdir/script.php\n\t * $_SERVER['QUERY_STRING']            | endpoint=user&id=123\n\t * $_SERVER['REDIRECT_STATUS']         | 200\n\t * $_SERVER['REDIRECT_URL']            | /api/v1/user/123\n\t * $_SERVER['REDIRECT_QUERY_STRING']   | endpoint=user&id=123\n\t * === $_GET Variables ===\n\t * $_GET['endpoint']                   | user\n\t * $_GET['id']                         | 123\n\t * ```\n\t *\n\t * ## Apache – vanilla request\n\t *\n\t * Setup:\n\t *    – The same as above.\n\t *    – A request sent http://localhost:8041/subdir/script.php?param=value\n\t *\n\t * Results:\n\t *\n\t * ```\n\t * $_SERVER['REQUEST_URI']     | /subdir/script.php?param=value\n\t * $_SERVER['SCRIPT_NAME']     | /subdir/script.php\n\t * $_SERVER['SCRIPT_FILENAME'] | /var/www/html/subdir/script.php\n\t * $_SERVER['PATH_INFO']       | (key not set)\n\t * $_SERVER['PHP_SELF']        | /subdir/script.php\n\t * $_SERVER['REDIRECT_URL']    | (key not set)\n\t * $_SERVER['REDIRECT_STATUS'] | (key not set)\n\t * $_SERVER['QUERY_STRING']    | param=value\n\t * $_SERVER['REQUEST_METHOD']  | GET\n\t * $_SERVER['DOCUMENT_ROOT']   | /var/www/html\n\t *\n\t * === $_GET Variables ===\n\t * $_GET['param']              | value\n\t * ```\n\t */\n\tprivate prepare_$_SERVER_superglobal(\n\t\toriginalRequestUrl: URL,\n\t\trewrittenRequestUrl: URL,\n\t\tresolvedScriptPath: string\n\t): Record<string, string> {\n\t\tconst $_SERVER: Record<string, string> = {\n\t\t\tREMOTE_ADDR: '127.0.0.1',\n\t\t\tDOCUMENT_ROOT: this.#DOCROOT,\n\t\t\tHTTPS: this.#ABSOLUTE_URL.startsWith('https://') ? 'on' : '',\n\t\t};\n\n\t\t/**\n\t\t * REQUEST_URI\n\t\t *\n\t\t * The original path + query string extracted from the requested URL\n\t\t * **before** applying any URL rewriting.\n\t\t */\n\t\t$_SERVER['REQUEST_URI'] =\n\t\t\toriginalRequestUrl.pathname + originalRequestUrl.search;\n\n\t\tif (resolvedScriptPath.startsWith(this.#DOCROOT)) {\n\t\t\t/**\n\t\t\t * SCRIPT_NAME\n\t\t\t *\n\t\t\t * > Contains the current script's path. This is useful for pages\n\t\t\t * > which need to point to themselves.\n\t\t\t *\n\t\t\t * Filesystem path of the script relative to the document root.\n\t\t\t * Note this is a filesystem path so URL rewriting is not applicable here.\n\t\t\t */\n\t\t\t$_SERVER['SCRIPT_NAME'] = resolvedScriptPath.substring(\n\t\t\t\tthis.#DOCROOT.length\n\t\t\t);\n\n\t\t\t/**\n\t\t\t * PHP_SELF – the path sourced from the final **request URL** after the\n\t\t\t * rewrite rules have been applied.\n\t\t\t *\n\t\t\t * php.net documentation is very misleading on this one:\n\t\t\t *\n\t\t\t * > The filename of the currently executing script, relative\n\t\t\t * > to the document root. For instance, $_SERVER['PHP_SELF']\n\t\t\t * > in a script at the address http://example.com/foo/bar.php\n\t\t\t * > would be /foo/bar.php.\n\t\t\t *\n\t\t\t * @see https://www.php.net/manual/en/reserved.variables.server.php#:~:text=PHP_SELF\n\t\t\t *\n\t\t\t * This is not what Apache, nor what the PHP dev server do:\n\t\t\t *\n\t\t\t * – Document Root: /var/www\n\t\t\t * – Script file:   /var/www/subdir/script.php\n\t\t\t * – Requesting     /subdir/script.php/b.php/c.php\n\t\t\t *\n\t\t\t *   $_SERVER['PHP_SELF'] = \"/subdir/script.php/b.php/c.php\"\n\t\t\t *\n\t\t\t * So, in that regard, it is a URL path, not a filesystem path.\n\t\t\t *\n\t\t\t * When URL rewriting is involved, it's the same.\n\t\t\t *\n\t\t\t * Consider this Apache example from above:\n\t\t\t *\n\t\t\t * – Document Root: /var/www/html\n\t\t\t * – Script file:   /var/www/html/subdir/script.php\n\t\t\t * – Rewrite rule:  ^api/v1/user/([0-9]+)$ /subdir/script.php?endpoint=user&id=$1 [L,QSA]\n\t\t\t * – Requesting     /api/v1/user/123\n\t\t\t *\n\t\t\t *   $_SERVER['PHP_SELF'] = \"/subdir/script.php\"\n\t\t\t *\n\t\t\t * So, on the face value, this is a filesystem path. However, see\n\t\t\t * what happens if we slightly modify that rewrite rule to:\n\t\t\t *\n\t\t\t * – Rewrite rule:  ^api/v1/user/([0-9]+)$ /subdir/script.php/next.php\n\t\t\t *                                                           ^^^^^^^^^\n\t\t\t * – Requesting     /api/v1/user/123\n\t\t\t *\n\t\t\t *   $_SERVER['PHP_SELF'] = \"/subdir/script.php/next.php\"\n\t\t\t *\n\t\t\t * So:\n\t\t\t * * PHP_SELF is not sourced from the filesystem path.\n\t\t\t * * PHP_SELF is sourced from the final request URL after the\n\t\t\t *   rewrite rules have been applied.\n\t\t\t */\n\t\t\t$_SERVER['PHP_SELF'] = rewrittenRequestUrl.pathname;\n\n\t\t\t/**\n\t\t\t * PATH_INFO\n\t\t\t *\n\t\t\t * > Contains any client-provided pathname information trailing the actual\n\t\t\t * > script filename but preceding the query string, if available. For instance,\n\t\t\t * > if the current script was accessed via the URI http://www.example.com/php/path_info.php/some/stuff?foo=bar,\n\t\t\t * > then $_SERVER['PATH_INFO'] would contain /some/stuff.\n\t\t\t *\n\t\t\t * This **does not** include the query string.\n\t\t\t *\n\t\t\t * @see https://www.php.net/manual/en/reserved.variables.server.php#:~:text=PATH_INFO\n\t\t\t */\n\t\t\tif ($_SERVER['REQUEST_URI'].startsWith($_SERVER['SCRIPT_NAME'])) {\n\t\t\t\t$_SERVER['PATH_INFO'] = $_SERVER['REQUEST_URI'].substring(\n\t\t\t\t\t$_SERVER['SCRIPT_NAME'].length\n\t\t\t\t);\n\t\t\t\t// Remove the query string if present.\n\t\t\t\tif ($_SERVER['PATH_INFO'].includes('?')) {\n\t\t\t\t\t$_SERVER['PATH_INFO'] = $_SERVER['PATH_INFO'].substring(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t$_SERVER['PATH_INFO'].indexOf('?')\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * QUERY_STRING\n\t\t *\n\t\t * The query string from the original and rewritten request URLs.\n\t\t * Does not include the leading question mark.\n\t\t *\n\t\t * Note it contains all the query parameters from the original\n\t\t * URL merged with the new parameters from the rewritten request URLs.\n\t\t *\n\t\t * Example:\n\t\t *    – Original request URL: /pretty/url?foo=bar&page=different-value\n\t\t *    – Rewritten request URL: /pretty/url?page=pretty\n\t\t *    – QUERY_STRING: page=pretty&foo=bar&page=different-value\n\t\t */\n\t\t$_SERVER['QUERY_STRING'] = rewrittenRequestUrl.search.substring(1);\n\n\t\t/**\n\t\t * There's a few relevant entries we are NOT setting here:\n\t\t *\n\t\t *    – SCRIPT_FILENAME: Absolute path to the script file. It is set by\n\t\t *      php_wasm.c.\n\t\t *    – REDIRECT_STATUS: Apache sets it, but it's optional so we skip it.\n\t\t *    – REDIRECT_URL: Apache sets it, but it's optional so we skip it.\n\t\t *    – REDIRECT_QUERY_STRING: Apache sets it, but it's optional so we skip it.\n\t\t */\n\t\treturn $_SERVER;\n\t}\n\n\tasync [Symbol.asyncDispose]() {\n\t\tawait this.processManager[Symbol.asyncDispose]();\n\t}\n}\n\n/**\n * Naively infer a file mime type from its path.\n *\n * @todo Infer the mime type based on the file contents.\n *       A naive function like this one can be inaccurate\n *       and potentially have negative security consequences.\n *\n * @param  path - The file path\n * @returns The inferred mime type.\n */\nexport function inferMimeType(path: string): string {\n\tconst extension = path.split('.').pop() as keyof typeof mimeTypes;\n\t// @TODO: Consider not sending a default mime type to let the browser guess\n\treturn mimeTypes[extension] || mimeTypes['_default'];\n}\n\n/**\n * Applies the given rewrite rules to the given path.\n *\n * @param  path  The path to apply the rules to.\n * @param  rules The rules to apply.\n * @returns The path with the rules applied.\n */\nexport function applyRewriteRules(path: string, rules: RewriteRule[]): string {\n\tfor (const rule of rules) {\n\t\tif (new RegExp(rule.match).test(path)) {\n\t\t\tpath = path.replace(rule.match, rule.replacement);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn path;\n}\n\n/**\n * Checks if the given URL looks like an absolute URL.\n *\n * @param url - The URL to check.\n * @returns `true` if the URL looks like an absolute URL, `false` otherwise.\n */\nfunction looksLikeAbsoluteUrl(url: string): boolean {\n\ttry {\n\t\t// NOTE: We could just use URL.canParse() but are avoiding it here\n\t\t// because we've seen users with older Safari versions that don't support it.\n\t\t// Maybe Playground will break in other ways for them,\n\t\t// but since this is an easy, low-risk change, let's give it a try.\n\t\tnew URL(url);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-function-type */\n/* eslint-disable @typescript-eslint/no-misused-new */\n/* eslint-disable @typescript-eslint/no-empty-object-type */\nimport type { MessagePort as NodeMessagePort } from 'worker_threads';\n\n/**\n * Comlink library protocol extension to use synchronous messaging.\n *\n * Debugging Asyncify is too much of a burden. This extension enables exchanging\n * messages between threads synchronously so that we don't need to rely on Asyncify.\n *\n * Upsides:\n *\n * * Saves dozens-to-hundreds of hours on debugging Asyncify issues\n * * Increased reliability\n * * Useful stack traces when errors do happen.\n *\n * Downsides:\n *\n * * Fragmentation: Both synchronous and asynchronous handlers exist to get the best our of both\n * Asyncify and JSPI. * Node.js-only: This extension does not implement a Safari-friendly\n * transport. SharedArrayBuffer is an option, but\n *                 it requires more restrictive CORP+COEP headers which breaks, e.g., YouTube\n *                 embeds. Synchronous XHR might work if we really need Safari support for one of\n *                 the new asynchronous features, but other than that let's just skip adding new\n *                 asynchronous WASM features to Safari until WebKit supports stack switching.\n * * Message passing between workers is slow. Avoid using synchronous messaging for syscalls that\n * are invoked frequently and\n *   handled asynchronously in the same worker.\n *\n * @see https://github.com/adamziel/js-synchronous-messaging for additional ideas.\n * @see https://github.com/WordPress/wordpress-playground/blob/9a9262cc62cc161d220a9992706b9ed2817f2eb5/packages/docs/site/docs/developers/23-architecture/07-wasm-asyncify.md\n */\ninterface SyncMessage {\n\t/** original Comlink envelope            */\n\tid?: string;\n\ttype: MessageType;\n\t/** existing Comlink fields …            */\n\t[k: string]: any;\n\t/** new part that carries the latch      */\n\tnotifyBuffer?: SharedArrayBuffer;\n}\n\ninterface SyncTransport {\n\tafterResponseSent(ev: MessageEvent): void;\n\tsend(\n\t\tep: IsomorphicMessagePort,\n\t\tmsg: Omit<SyncMessage, 'id' | 'notifyBuffer'>,\n\t\ttransferables?: Transferable[]\n\t): WireValue;\n}\n\nexport function exposeSync(\n\tobj: any,\n\tep: Endpoint,\n\ttransport: SyncTransport,\n\tallowedOrigins: (string | RegExp)[] = ['*']\n) {\n\treturn expose(obj, ep, allowedOrigins, transport.afterResponseSent);\n}\n\n//////////////////////////////\n// 3. Consumer side         //\n//////////////////////////////\n\nfunction createSyncProxy<T>(\n\tep: IsomorphicMessagePort,\n\tpath: (string | number | symbol)[] = [],\n\ttransport: SyncTransport\n): T {\n\treturn new Proxy(() => {}, {\n\t\tget(_t, prop) {\n\t\t\tif (prop === 'then') {\n\t\t\t\t// allow await‑usage without deadlocking\n\t\t\t\tif (!path.length)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tthen: (_: any, res: any) =>\n\t\t\t\t\t\t\tres(createSyncProxy(ep, [], transport)),\n\t\t\t\t\t};\n\t\t\t}\n\t\t\treturn createSyncProxy(ep, [...path, prop], transport);\n\t\t},\n\n\t\tset(_t, prop, value) {\n\t\t\tconst [v, xfer] = toWireValue(value);\n\t\t\ttransport.send(\n\t\t\t\tep,\n\t\t\t\t{\n\t\t\t\t\ttype: MessageType.SET,\n\t\t\t\t\tpath: [...path, prop].map(String),\n\t\t\t\t\tvalue: v,\n\t\t\t\t},\n\t\t\t\txfer\n\t\t\t);\n\t\t\treturn true;\n\t\t},\n\n\t\tapply(_t, _thisArg, rawArgs) {\n\t\t\t// Special cases\n\t\t\tconst last = path.at(-1);\n\t\t\tif (last === 'bind')\n\t\t\t\treturn createSyncProxy(ep, path.slice(0, -1), transport);\n\n\t\t\tconst [argList, xfer] = processArguments(rawArgs);\n\t\t\tconst wire = transport.send(\n\t\t\t\tep,\n\t\t\t\t{\n\t\t\t\t\ttype: MessageType.APPLY,\n\t\t\t\t\tpath: path.map(String),\n\t\t\t\t\targumentList: argList,\n\t\t\t\t},\n\t\t\t\txfer\n\t\t\t);\n\n\t\t\treturn fromWireValue(wire);\n\t\t},\n\n\t\tconstruct(_t, rawArgs) {\n\t\t\tconst [argList, xfer] = processArguments(rawArgs);\n\t\t\tconst wire = transport.send(\n\t\t\t\tep,\n\t\t\t\t{\n\t\t\t\t\ttype: MessageType.CONSTRUCT,\n\t\t\t\t\tpath: path.map(String),\n\t\t\t\t\targumentList: argList,\n\t\t\t\t},\n\t\t\t\txfer\n\t\t\t);\n\t\t\treturn fromWireValue(wire);\n\t\t},\n\t}) as unknown as T;\n}\n\nexport function wrapSync<T>(\n\tep: IsomorphicMessagePort,\n\ttransport: SyncTransport\n): T {\n\treturn createSyncProxy<T>(ep, [], transport);\n}\n\n/// Transport ///\n\nexport type IsomorphicMessagePort = MessagePort | NodeMessagePort;\n\nexport class NodeSABSyncReceiveMessageTransport {\n\tprivate static receiveMessageOnPort: any;\n\n\tstatic async create() {\n\t\tif (!NodeSABSyncReceiveMessageTransport.receiveMessageOnPort) {\n\t\t\ttry {\n\t\t\t\tNodeSABSyncReceiveMessageTransport.receiveMessageOnPort =\n\t\t\t\t\trequire('worker_threads').receiveMessageOnPort;\n\t\t\t} catch {\n\t\t\t\tNodeSABSyncReceiveMessageTransport.receiveMessageOnPort =\n\t\t\t\t\tawait import('worker_threads').then(\n\t\t\t\t\t\t(m) => m.receiveMessageOnPort\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn new NodeSABSyncReceiveMessageTransport();\n\t}\n\n\tprivate constructor() {}\n\n\tafterResponseSent(ev: MessageEvent) {\n\t\tconst { notifyBuffer } = ev.data as SyncMessage;\n\t\tif (notifyBuffer) {\n\t\t\tconst view = new Int32Array(notifyBuffer);\n\t\t\tview[0] = 1;\n\t\t\tAtomics.notify(view, 0);\n\t\t}\n\t}\n\tsend(\n\t\tep: IsomorphicMessagePort,\n\t\tmsg: Omit<SyncMessage, 'id' | 'notifyBuffer'>,\n\t\ttransferables?: Transferable[]\n\t): WireValue {\n\t\t// SharedArrayBuffer = one 32‑bit cell that starts at 0.\n\t\t// The other worker will set this to 1 when it has sent the response.\n\t\tconst latch = new SharedArrayBuffer(4);\n\t\tconst view = new Int32Array(latch);\n\t\tview[0] = 0;\n\n\t\tconst id = generateUUID();\n\t\tep.postMessage(\n\t\t\t{ ...msg, id, notifyBuffer: latch },\n\t\t\ttransferables as any\n\t\t);\n\n\t\t// Synchronous pull; Node.js-only. Browsers don't support receiveMessageOnPort.\n\t\tconst timeoutMs = 5000;\n\t\tconst result = Atomics.wait(view, 0, 0, timeoutMs);\n\t\tif (result === 'timed-out') {\n\t\t\tthrow new Error('Timeout waiting for response');\n\t\t}\n\t\twhile (true) {\n\t\t\tconst res =\n\t\t\t\tNodeSABSyncReceiveMessageTransport.receiveMessageOnPort(ep);\n\t\t\tif (res.message?.id === id) {\n\t\t\t\treturn res.message;\n\t\t\t} else if (!res) {\n\t\t\t\tthrow new Error('No response received');\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Original, unmodified Comlink library from Google:\n *\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport const proxyMarker = Symbol('Comlink.proxy');\nexport const createEndpoint = Symbol('Comlink.endpoint');\nexport const releaseProxy = Symbol('Comlink.releaseProxy');\nexport const finalizer = Symbol('Comlink.finalizer');\n\nconst throwMarker = Symbol('Comlink.thrown');\n\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport interface EventSource {\n\taddEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject,\n\t\toptions?: object\n\t): void;\n\n\tremoveEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject,\n\t\toptions?: object\n\t): void;\n}\n\nexport interface PostMessageWithOrigin {\n\tpostMessage(\n\t\tmessage: any,\n\t\ttargetOrigin: string,\n\t\ttransfer?: Transferable[]\n\t): void;\n}\n\nexport interface Endpoint extends EventSource {\n\tpostMessage(message: any, transfer?: Transferable[]): void;\n\n\tstart?: () => void;\n}\n\nexport const WireValueType = {\n\tRAW: 'RAW',\n\tPROXY: 'PROXY',\n\tTHROW: 'THROW',\n\tHANDLER: 'HANDLER',\n} as const;\n\nexport type WireValueType = typeof WireValueType;\n\nexport interface RawWireValue {\n\tid?: string;\n\ttype: WireValueType['RAW'];\n\tvalue: any;\n}\n\nexport interface HandlerWireValue {\n\tid?: string;\n\ttype: WireValueType['HANDLER'];\n\tname: string;\n\tvalue: unknown;\n}\n\nexport type WireValue = RawWireValue | HandlerWireValue;\n\nexport type MessageID = string;\n\nexport const MessageType = {\n\tGET: 'GET',\n\tSET: 'SET',\n\tAPPLY: 'APPLY',\n\tCONSTRUCT: 'CONSTRUCT',\n\tENDPOINT: 'ENDPOINT',\n\tRELEASE: 'RELEASE',\n} as const;\nexport type MessageType = typeof MessageType;\n\nexport interface GetMessage {\n\tid?: MessageID;\n\ttype: MessageType['GET'];\n\tpath: string[];\n}\n\nexport interface SetMessage {\n\tid?: MessageID;\n\ttype: MessageType['SET'];\n\tpath: string[];\n\tvalue: WireValue;\n}\n\nexport interface ApplyMessage {\n\tid?: MessageID;\n\ttype: MessageType['APPLY'];\n\tpath: string[];\n\targumentList: WireValue[];\n}\n\nexport interface ConstructMessage {\n\tid?: MessageID;\n\ttype: MessageType['CONSTRUCT'];\n\tpath: string[];\n\targumentList: WireValue[];\n}\n\nexport interface EndpointMessage {\n\tid?: MessageID;\n\ttype: MessageType['ENDPOINT'];\n}\n\nexport interface ReleaseMessage {\n\tid?: MessageID;\n\ttype: MessageType['RELEASE'];\n}\n\nexport type Message =\n\t| GetMessage\n\t| SetMessage\n\t| ApplyMessage\n\t| ConstructMessage\n\t| EndpointMessage\n\t| ReleaseMessage;\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n\t[proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread\n * on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n\t// If the value is a method, comlink will proxy it automatically.\n\t// Objects are only proxied if they are marked to be proxied.\n\t// Otherwise, the property is converted to a Promise that resolves the cloned value.\n\tT extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n\t? Local<T>\n\t: Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and\n * transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n\t? Local<T>\n\t: T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible\n * to the local thread when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in\n * as a function argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n\t[createEndpoint]: () => Promise<MessagePort>;\n\t[releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the\n * type as it is visible to the local thread from the proxy return value of `Comlink.wrap()` or\n * `Comlink.proxy()`.\n */\nexport type Remote<T> =\n\t// Handle properties\n\tRemoteObject<T> &\n\t\t// Handle call signature (if present)\n\t\t(T extends (...args: infer TArguments) => infer TReturn\n\t\t\t? (\n\t\t\t\t\t...args: {\n\t\t\t\t\t\t[I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n\t\t\t\t\t}\n\t\t\t  ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n\t\t\t: unknown) &\n\t\t// Handle construct signature (if present)\n\t\t// The return of construct signatures is always proxied (whether marked or not)\n\t\t(T extends { new (...args: infer TArguments): infer TInstance }\n\t\t\t? {\n\t\t\t\t\tnew (\n\t\t\t\t\t\t...args: {\n\t\t\t\t\t\t\t[I in keyof TArguments]: UnproxyOrClone<\n\t\t\t\t\t\t\t\tTArguments[I]\n\t\t\t\t\t\t\t>;\n\t\t\t\t\t\t}\n\t\t\t\t\t): Promisify<Remote<TInstance>>;\n\t\t\t  }\n\t\t\t: unknown) &\n\t\t// Include additional special comlink methods available on the proxy.\n\t\tProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through\n * a proxy (e.g. when passed in as a function argument) and returns the type the local thread has\n * to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n\t// Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n\tOmit<LocalObject<T>, keyof ProxyMethods> &\n\t\t// Handle call signatures (if present)\n\t\t(T extends (...args: infer TArguments) => infer TReturn\n\t\t\t? (\n\t\t\t\t\t...args: {\n\t\t\t\t\t\t[I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n\t\t\t\t\t}\n\t\t\t  ) => // The raw function could either be sync or async, but is always proxied automatically\n\t\t\t  MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n\t\t\t: unknown) &\n\t\t// Handle construct signature (if present)\n\t\t// The return of construct signatures is always proxied (whether marked or not)\n\t\t(T extends { new (...args: infer TArguments): infer TInstance }\n\t\t\t? {\n\t\t\t\t\tnew (\n\t\t\t\t\t\t...args: {\n\t\t\t\t\t\t\t[I in keyof TArguments]: ProxyOrClone<\n\t\t\t\t\t\t\t\tTArguments[I]\n\t\t\t\t\t\t\t>;\n\t\t\t\t\t\t}\n\t\t\t\t\t): // The raw constructor could either be sync or async, but is always proxied automatically\n\t\t\t\t\tMaybePromise<Local<Unpromisify<TInstance>>>;\n\t\t\t  }\n\t\t\t: unknown);\n\nconst isObject = (val: unknown): val is object =>\n\t(typeof val === 'object' && val !== null) || typeof val === 'function';\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n\t/**\n\t * Gets called for every value to determine whether this transfer handler\n\t * should serialize the value, which includes checking that it is of the right\n\t * type (but can perform checks beyond that as well).\n\t */\n\tcanHandle(value: unknown): value is T;\n\n\t/**\n\t * Gets called with the value if `canHandle()` returned `true` to produce a\n\t * value that can be sent in a message, consisting of structured-cloneable\n\t * values and/or transferrable objects.\n\t */\n\tserialize(value: T): [S, Transferable[]];\n\n\t/**\n\t * Gets called to deserialize an incoming value that was serialized in the\n\t * other thread with this transfer handler (known through the name it was\n\t * registered under).\n\t */\n\tdeserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n\tcanHandle: (val): val is ProxyMarked =>\n\t\tisObject(val) && (val as ProxyMarked)[proxyMarker],\n\tserialize(obj) {\n\t\tconst { port1, port2 } = new MessageChannel();\n\t\texpose(obj, port1);\n\t\treturn [port2, [port2]];\n\t},\n\tdeserialize(port) {\n\t\tport.start();\n\t\treturn wrap(port);\n\t},\n};\n\ninterface ThrownValue {\n\t[throwMarker]: unknown; // just needs to be present\n\tvalue: unknown;\n}\ntype SerializedThrownValue =\n\t| { isError: true; value: Error }\n\t| { isError: false; value: unknown };\ntype PendingListenersMap = Map<\n\tstring,\n\t(value: WireValue | PromiseLike<WireValue>) => void\n>;\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n\tThrownValue,\n\tSerializedThrownValue\n> = {\n\tcanHandle: (value): value is ThrownValue =>\n\t\tisObject(value) && throwMarker in value,\n\tserialize({ value }) {\n\t\tlet serialized: SerializedThrownValue;\n\t\tif (value instanceof Error) {\n\t\t\tserialized = {\n\t\t\t\tisError: true,\n\t\t\t\tvalue: {\n\t\t\t\t\tmessage: value.message,\n\t\t\t\t\tname: value.name,\n\t\t\t\t\tstack: value.stack,\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tserialized = { isError: false, value };\n\t\t}\n\t\treturn [serialized, []];\n\t},\n\tdeserialize(serialized) {\n\t\tif (serialized.isError) {\n\t\t\tthrow Object.assign(\n\t\t\t\tnew Error(serialized.value.message),\n\t\t\t\tserialized.value\n\t\t\t);\n\t\t}\n\t\tthrow serialized.value;\n\t},\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n\tstring,\n\tTransferHandler<unknown, unknown>\n>([\n\t['proxy', proxyTransferHandler],\n\t['throw', throwTransferHandler],\n]);\n\nfunction isAllowedOrigin(\n\tallowedOrigins: (string | RegExp)[],\n\torigin: string\n): boolean {\n\tfor (const allowedOrigin of allowedOrigins) {\n\t\tif (origin === allowedOrigin || allowedOrigin === '*') {\n\t\t\treturn true;\n\t\t}\n\t\tif (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport function expose(\n\tobj: any,\n\tep: Endpoint = globalThis as any,\n\tallowedOrigins: (string | RegExp)[] = ['*'],\n\tafterResponseSent?: (ev: MessageEvent) => void\n) {\n\tep.addEventListener('message', function callback(ev: MessageEvent) {\n\t\tif (!ev || !ev.data) {\n\t\t\treturn;\n\t\t}\n\t\tif (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n\t\t\treturn;\n\t\t}\n\t\tconst { id, type, path } = {\n\t\t\tpath: [] as string[],\n\t\t\t...(ev.data as Message),\n\t\t};\n\t\tconst argumentList = (ev.data.argumentList || []).map(fromWireValue);\n\t\tlet returnValue;\n\t\ttry {\n\t\t\tconst parent = path\n\t\t\t\t.slice(0, -1)\n\t\t\t\t.reduce((obj, prop) => obj[prop], obj);\n\t\t\tconst rawValue = path.reduce((obj, prop) => obj[prop], obj);\n\t\t\tswitch (type) {\n\t\t\t\tcase MessageType.GET:\n\t\t\t\t\t{\n\t\t\t\t\t\treturnValue = rawValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MessageType.SET:\n\t\t\t\t\t{\n\t\t\t\t\t\tparent[path.slice(-1)[0]] = fromWireValue(\n\t\t\t\t\t\t\tev.data.value\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturnValue = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MessageType.APPLY:\n\t\t\t\t\t{\n\t\t\t\t\t\treturnValue = rawValue.apply(parent, argumentList);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MessageType.CONSTRUCT:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst value = new rawValue(...argumentList);\n\t\t\t\t\t\treturnValue = proxy(value);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MessageType.ENDPOINT:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { port1, port2 } = new MessageChannel();\n\t\t\t\t\t\texpose(obj, port2);\n\t\t\t\t\t\treturnValue = transfer(port1, [port1]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MessageType.RELEASE:\n\t\t\t\t\t{\n\t\t\t\t\t\treturnValue = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t} catch (value) {\n\t\t\treturnValue = { value, [throwMarker]: 0 };\n\t\t}\n\t\tPromise.resolve(returnValue)\n\t\t\t.catch((value) => {\n\t\t\t\treturn { value, [throwMarker]: 0 };\n\t\t\t})\n\t\t\t.then((returnValue) => {\n\t\t\t\tconst [wireValue, transferables] = toWireValue(returnValue);\n\t\t\t\tep.postMessage({ ...wireValue, id }, transferables);\n\t\t\t\tif (type === MessageType.RELEASE) {\n\t\t\t\t\t// detach and deactive after sending release response above.\n\t\t\t\t\tep.removeEventListener('message', callback as any);\n\t\t\t\t\tcloseEndPoint(ep);\n\t\t\t\t\tif (\n\t\t\t\t\t\tfinalizer in obj &&\n\t\t\t\t\t\ttypeof obj[finalizer] === 'function'\n\t\t\t\t\t) {\n\t\t\t\t\t\tobj[finalizer]();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(() => {\n\t\t\t\t// Send Serialization Error To Caller\n\t\t\t\tconst [wireValue, transferables] = toWireValue({\n\t\t\t\t\tvalue: new TypeError('Unserializable return value'),\n\t\t\t\t\t[throwMarker]: 0,\n\t\t\t\t});\n\t\t\t\tep.postMessage({ ...wireValue, id }, transferables);\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\tafterResponseSent?.(ev);\n\t\t\t});\n\t} as any);\n\tif (ep.start) {\n\t\tep.start();\n\t}\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n\treturn endpoint.constructor.name === 'MessagePort';\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n\tif (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n\tconst pendingListeners: PendingListenersMap = new Map();\n\n\tep.addEventListener('message', function handleMessage(ev: Event) {\n\t\tconst { data } = ev as MessageEvent;\n\t\tif (!data || !data.id) {\n\t\t\treturn;\n\t\t}\n\t\tconst resolver = pendingListeners.get(data.id);\n\t\tif (!resolver) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tresolver(data);\n\t\t} finally {\n\t\t\tpendingListeners.delete(data.id);\n\t\t}\n\t});\n\n\treturn createProxy<T>(ep, pendingListeners, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n\tif (isReleased) {\n\t\tthrow new Error('Proxy has been released and is not useable');\n\t}\n}\n\nfunction releaseEndpoint(ep: Endpoint) {\n\treturn requestResponseMessage(ep, new Map(), {\n\t\ttype: MessageType.RELEASE,\n\t}).then(() => {\n\t\tcloseEndPoint(ep);\n\t});\n}\n\ninterface FinalizationRegistry<T> {\n\t// @ts-ignore\n\tnew (cb: (heldValue: T) => void): FinalizationRegistry<T>;\n\tregister(\n\t\tweakItem: object,\n\t\theldValue: T,\n\t\tunregisterToken?: object | undefined\n\t): void;\n\tunregister(unregisterToken: object): void;\n}\ndeclare const FinalizationRegistry: FinalizationRegistry<Endpoint>;\n\nconst proxyCounter = new WeakMap<Endpoint, number>();\nconst proxyFinalizers =\n\t'FinalizationRegistry' in globalThis &&\n\tnew FinalizationRegistry((ep: Endpoint) => {\n\t\tconst newCount = (proxyCounter.get(ep) || 0) - 1;\n\t\tproxyCounter.set(ep, newCount);\n\t\tif (newCount === 0) {\n\t\t\treleaseEndpoint(ep);\n\t\t}\n\t});\n\nfunction registerProxy(proxy: object, ep: Endpoint) {\n\tconst newCount = (proxyCounter.get(ep) || 0) + 1;\n\tproxyCounter.set(ep, newCount);\n\tif (proxyFinalizers) {\n\t\tproxyFinalizers.register(proxy, ep, proxy);\n\t}\n}\n\nfunction unregisterProxy(proxy: object) {\n\tif (proxyFinalizers) {\n\t\tproxyFinalizers.unregister(proxy);\n\t}\n}\n\nfunction createProxy<T>(\n\tep: Endpoint,\n\tpendingListeners: PendingListenersMap,\n\tpath: (string | number | symbol)[] = [],\n\ttarget: object = function () {}\n): Remote<T> {\n\tlet isProxyReleased = false;\n\tconst proxy = new Proxy(target, {\n\t\tget(_target, prop) {\n\t\t\tthrowIfProxyReleased(isProxyReleased);\n\t\t\tif (prop === releaseProxy) {\n\t\t\t\treturn () => {\n\t\t\t\t\tunregisterProxy(proxy);\n\t\t\t\t\treleaseEndpoint(ep);\n\t\t\t\t\tpendingListeners.clear();\n\t\t\t\t\tisProxyReleased = true;\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (prop === 'then') {\n\t\t\t\tif (path.length === 0) {\n\t\t\t\t\treturn { then: () => proxy };\n\t\t\t\t}\n\t\t\t\tconst r = requestResponseMessage(ep, pendingListeners, {\n\t\t\t\t\ttype: MessageType.GET,\n\t\t\t\t\tpath: path.map((p) => p.toString()),\n\t\t\t\t}).then(fromWireValue);\n\t\t\t\treturn r.then.bind(r);\n\t\t\t}\n\t\t\treturn createProxy(ep, pendingListeners, [...path, prop]);\n\t\t},\n\t\tset(_target, prop, rawValue) {\n\t\t\tthrowIfProxyReleased(isProxyReleased);\n\t\t\t// FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n\t\t\t// boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n\t\t\tconst [value, transferables] = toWireValue(rawValue);\n\t\t\treturn requestResponseMessage(\n\t\t\t\tep,\n\t\t\t\tpendingListeners,\n\t\t\t\t{\n\t\t\t\t\ttype: MessageType.SET,\n\t\t\t\t\tpath: [...path, prop].map((p) => p.toString()),\n\t\t\t\t\tvalue,\n\t\t\t\t},\n\t\t\t\ttransferables\n\t\t\t).then(fromWireValue) as any;\n\t\t},\n\t\tapply(_target, _thisArg, rawArgumentList) {\n\t\t\tthrowIfProxyReleased(isProxyReleased);\n\t\t\tconst last = path[path.length - 1];\n\t\t\tif ((last as any) === createEndpoint) {\n\t\t\t\treturn requestResponseMessage(ep, pendingListeners, {\n\t\t\t\t\ttype: MessageType.ENDPOINT,\n\t\t\t\t}).then(fromWireValue);\n\t\t\t}\n\t\t\t// We just pretend that `bind()` didn’t happen.\n\t\t\tif (last === 'bind') {\n\t\t\t\treturn createProxy(ep, pendingListeners, path.slice(0, -1));\n\t\t\t}\n\t\t\tconst [argumentList, transferables] =\n\t\t\t\tprocessArguments(rawArgumentList);\n\t\t\treturn requestResponseMessage(\n\t\t\t\tep,\n\t\t\t\tpendingListeners,\n\t\t\t\t{\n\t\t\t\t\ttype: MessageType.APPLY,\n\t\t\t\t\tpath: path.map((p) => p.toString()),\n\t\t\t\t\targumentList,\n\t\t\t\t},\n\t\t\t\ttransferables\n\t\t\t).then(fromWireValue);\n\t\t},\n\t\tconstruct(_target, rawArgumentList) {\n\t\t\tthrowIfProxyReleased(isProxyReleased);\n\t\t\tconst [argumentList, transferables] =\n\t\t\t\tprocessArguments(rawArgumentList);\n\t\t\treturn requestResponseMessage(\n\t\t\t\tep,\n\t\t\t\tpendingListeners,\n\t\t\t\t{\n\t\t\t\t\ttype: MessageType.CONSTRUCT,\n\t\t\t\t\tpath: path.map((p) => p.toString()),\n\t\t\t\t\targumentList,\n\t\t\t\t},\n\t\t\t\ttransferables\n\t\t\t).then(fromWireValue);\n\t\t},\n\t});\n\tregisterProxy(proxy, ep);\n\treturn proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n\treturn Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n\tconst processed = argumentList.map(toWireValue);\n\treturn [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n\ttransferCache.set(obj, transfers);\n\treturn obj;\n}\n\nexport function proxy<T extends object>(obj: T): T & ProxyMarked {\n\treturn Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n\tw: PostMessageWithOrigin,\n\tcontext: EventSource = globalThis,\n\ttargetOrigin = '*'\n): Endpoint {\n\treturn {\n\t\tpostMessage: (msg: any, transferables: Transferable[]) =>\n\t\t\tw.postMessage(msg, targetOrigin, transferables),\n\t\taddEventListener: context.addEventListener.bind(context),\n\t\tremoveEventListener: context.removeEventListener.bind(context),\n\t};\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n\tfor (const [name, handler] of transferHandlers) {\n\t\tif (handler.canHandle(value)) {\n\t\t\tconst [serializedValue, transferables] = handler.serialize(value);\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\ttype: WireValueType.HANDLER,\n\t\t\t\t\tname,\n\t\t\t\t\tvalue: serializedValue,\n\t\t\t\t},\n\t\t\t\ttransferables,\n\t\t\t];\n\t\t}\n\t}\n\treturn [\n\t\t{\n\t\t\ttype: WireValueType.RAW,\n\t\t\tvalue,\n\t\t},\n\t\ttransferCache.get(value) || [],\n\t];\n}\n\nfunction fromWireValue(value: WireValue): any {\n\tswitch (value.type) {\n\t\tcase WireValueType.HANDLER:\n\t\t\treturn transferHandlers.get(value.name)!.deserialize(value.value);\n\t\tcase WireValueType.RAW:\n\t\t\treturn value.value;\n\t}\n}\n\nfunction requestResponseMessage(\n\tep: Endpoint,\n\tpendingListeners: PendingListenersMap,\n\tmsg: Message,\n\ttransfers?: Transferable[]\n): Promise<WireValue> {\n\treturn new Promise((resolve) => {\n\t\tconst id = generateUUID();\n\t\tpendingListeners.set(id, resolve);\n\t\tif (ep.start) {\n\t\t\tep.start();\n\t\t}\n\t\tep.postMessage({ id, ...msg }, transfers);\n\t});\n}\n\nfunction generateUUID(): string {\n\treturn new Array(4)\n\t\t.fill(0)\n\t\t.map(() =>\n\t\t\tMath.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)\n\t\t)\n\t\t.join('-');\n}\n\n// node-adapter.ts:\n\nexport interface NodeEndpoint {\n\tpostMessage(message: any, transfer?: any[]): void;\n\ton(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject,\n\t\toptions?: object\n\t): void;\n\toff(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject,\n\t\toptions?: object\n\t): void;\n\tstart?: () => void;\n}\n\nexport function nodeEndpoint(nep: NodeEndpoint): Endpoint {\n\tconst listeners = new WeakMap();\n\treturn {\n\t\tpostMessage: nep.postMessage.bind(nep),\n\t\taddEventListener: (_, eh) => {\n\t\t\tconst l = (data: any) => {\n\t\t\t\tif ('handleEvent' in eh) {\n\t\t\t\t\teh.handleEvent({ data } as MessageEvent);\n\t\t\t\t} else {\n\t\t\t\t\teh({ data } as MessageEvent);\n\t\t\t\t}\n\t\t\t};\n\t\t\tnep.on('message', l);\n\t\t\tlisteners.set(eh, l);\n\t\t},\n\t\tremoveEventListener: (_, eh) => {\n\t\t\tconst l = listeners.get(eh);\n\t\t\tif (!l) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnep.off('message', l);\n\t\t\tlisteners.delete(eh);\n\t\t},\n\t\tstart: nep.start && nep.start.bind(nep),\n\t};\n}\n","/**\n * `serialize-error` package wrapped as a single file for compatibility\n * with both CJS and ESM.\n *\n * @see https://github.com/sindresorhus/serialize-error\n */\nconst list = [\n\t// Native ES errors https://262.ecma-international.org/12.0/#sec-well-known-intrinsic-objects\n\tError,\n\tEvalError,\n\tRangeError,\n\tReferenceError,\n\tSyntaxError,\n\tTypeError,\n\tURIError,\n\tAggregateError,\n\n\t// Built-in errors\n\tglobalThis.DOMException,\n\n\t// Node-specific errors\n\t// https://nodejs.org/api/errors.html\n\t(globalThis as any).AssertionError,\n\t(globalThis as any).SystemError,\n]\n\t// Non-native Errors are used with `globalThis` because they might be missing. This filter drops\n\t// them when undefined.\n\t.filter(Boolean)\n\t.map((constructor) => [constructor.name, constructor]);\n\nexport type ErrorObject = {\n\tname?: string;\n\tmessage?: string;\n\tstack?: string;\n\tcause?: unknown;\n\tcode?: string;\n} & Record<string, unknown>;\n\nexport const errorConstructors = new Map(list as any);\n\nexport function addKnownErrorConstructor(constructor: any) {\n\tconst { name } = constructor;\n\tif (errorConstructors.has(name)) {\n\t\tthrow new Error(`The error constructor \"${name}\" is already known.`);\n\t}\n\n\ttry {\n\t\t// eslint-disable-next-line no-new -- It just needs to be verified\n\t\tnew constructor();\n\t} catch (error) {\n\t\tthrow new Error(`The error constructor \"${name}\" is not compatible`, {\n\t\t\tcause: error,\n\t\t});\n\t}\n\n\terrorConstructors.set(name, constructor);\n}\n\nexport class NonError extends Error {\n\toverride name = 'NonError';\n\n\tconstructor(message: any) {\n\t\tsuper(NonError._prepareSuperMessage(message));\n\t}\n\n\tstatic _prepareSuperMessage(message: any) {\n\t\ttry {\n\t\t\treturn JSON.stringify(message);\n\t\t} catch {\n\t\t\treturn String(message);\n\t\t}\n\t}\n}\n\nconst errorProperties = [\n\t{\n\t\tproperty: 'name',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'message',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'stack',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'code',\n\t\tenumerable: true,\n\t},\n\t{\n\t\tproperty: 'cause',\n\t\tenumerable: false,\n\t},\n\t{\n\t\tproperty: 'errors',\n\t\tenumerable: false,\n\t},\n];\n\nconst toJsonWasCalled = new WeakSet();\n\nconst toJSON = (from: any) => {\n\ttoJsonWasCalled.add(from);\n\tconst json = from.toJSON();\n\ttoJsonWasCalled.delete(from);\n\treturn json;\n};\n\nconst newError = (name: any) => {\n\tconst ErrorConstructor = errorConstructors.get(name) ?? (Error as any);\n\treturn ErrorConstructor === AggregateError\n\t\t? new ErrorConstructor([])\n\t\t: new ErrorConstructor();\n};\n\n// eslint-disable-next-line complexity\nconst destroyCircular = ({\n\tfrom,\n\tseen,\n\tto,\n\tforceEnumerable,\n\tmaxDepth,\n\tdepth,\n\tuseToJSON,\n\tserialize,\n}: {\n\tfrom?: any;\n\tseen: any[];\n\tto?: any;\n\tforceEnumerable: boolean;\n\tmaxDepth: number;\n\tdepth: number;\n\tuseToJSON: boolean;\n\tserialize: boolean;\n}) => {\n\tif (!to) {\n\t\tif (Array.isArray(from)) {\n\t\t\tto = [];\n\t\t} else if (!serialize && isErrorLike(from)) {\n\t\t\tto = newError(from.name);\n\t\t} else {\n\t\t\tto = {};\n\t\t}\n\t}\n\n\tseen.push(from);\n\n\tif (depth >= maxDepth) {\n\t\treturn to;\n\t}\n\n\tif (\n\t\tuseToJSON &&\n\t\ttypeof from.toJSON === 'function' &&\n\t\t!toJsonWasCalled.has(from)\n\t) {\n\t\treturn toJSON(from);\n\t}\n\n\tconst continueDestroyCircular = (value: any) =>\n\t\tdestroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [...seen],\n\t\t\tforceEnumerable,\n\t\t\tmaxDepth,\n\t\t\tdepth,\n\t\t\tuseToJSON,\n\t\t\tserialize,\n\t\t});\n\n\tfor (const [key, value] of Object.entries(from)) {\n\t\tif (\n\t\t\tvalue &&\n\t\t\tvalue instanceof Uint8Array &&\n\t\t\tvalue.constructor.name === 'Buffer'\n\t\t) {\n\t\t\tto[key] = '[object Buffer]';\n\t\t\tcontinue;\n\t\t}\n\n\t\t// TODO: Use `stream.isReadable()` when targeting Node.js 18.\n\t\tif (\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof (value as any).pipe === 'function'\n\t\t) {\n\t\t\tto[key] = '[object Stream]';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (typeof value === 'function') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value || typeof value !== 'object') {\n\t\t\t// Gracefully handle non-configurable errors like `DOMException`.\n\t\t\ttry {\n\t\t\t\tto[key] = value;\n\t\t\t} catch {\n\t\t\t\t// ignore\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!seen.includes(from[key])) {\n\t\t\tdepth++;\n\t\t\tto[key] = continueDestroyCircular(from[key]);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tto[key] = '[Circular]';\n\t}\n\n\tif (serialize || to instanceof Error) {\n\t\tfor (const { property, enumerable } of errorProperties) {\n\t\t\tif (from[property] !== undefined && from[property] !== null) {\n\t\t\t\tObject.defineProperty(to, property, {\n\t\t\t\t\tvalue:\n\t\t\t\t\t\tisErrorLike(from[property]) ||\n\t\t\t\t\t\tArray.isArray(from[property])\n\t\t\t\t\t\t\t? continueDestroyCircular(from[property])\n\t\t\t\t\t\t\t: from[property],\n\t\t\t\t\tenumerable: forceEnumerable ? true : enumerable,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\nexport function serializeError(value: any, options: any = {}) {\n\tconst { maxDepth = Number.POSITIVE_INFINITY, useToJSON = true } = options;\n\n\tif (typeof value === 'object' && value !== null) {\n\t\treturn destroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tforceEnumerable: true,\n\t\t\tmaxDepth,\n\t\t\tdepth: 0,\n\t\t\tuseToJSON,\n\t\t\tserialize: true,\n\t\t});\n\t}\n\n\t// People sometimes throw things besides Error objects…\n\tif (typeof value === 'function') {\n\t\t// `JSON.stringify()` discards functions. We do too, unless a function is thrown directly.\n\t\t// We intentionally use `||` because `.name` is an empty string for anonymous functions.\n\t\treturn `[Function: ${value.name || 'anonymous'}]`;\n\t}\n\n\treturn value;\n}\n\nexport function deserializeError(value: any, options: any = {}) {\n\tconst { maxDepth = Number.POSITIVE_INFINITY } = options;\n\n\tif (value instanceof Error) {\n\t\treturn value;\n\t}\n\n\tif (isMinimumViableSerializedError(value)) {\n\t\treturn destroyCircular({\n\t\t\tfrom: value,\n\t\t\tseen: [],\n\t\t\tto: newError(value.name),\n\t\t\tmaxDepth,\n\t\t\tdepth: 0,\n\t\t\tserialize: false,\n\t\t} as any);\n\t}\n\n\treturn new NonError(value);\n}\n\nexport function isErrorLike(value: any) {\n\treturn (\n\t\tBoolean(value) &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.name === 'string' &&\n\t\ttypeof value.message === 'string' &&\n\t\ttypeof value.stack === 'string'\n\t);\n}\n\n// Used as a weak check for immediately-passed objects, whereas `isErrorLike` is used for nested\n// values to avoid bad detection\nfunction isMinimumViableSerializedError(value: any) {\n\t// @ts-ignore\n\treturn (\n\t\tBoolean(value) &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.message === 'string' &&\n\t\t!Array.isArray(value)\n\t);\n}\n","import type { PHPResponseData } from './php-response';\nimport { PHPResponse, StreamedPHPResponse } from './php-response';\nimport * as Comlink from './comlink-sync';\nimport {\n\tNodeSABSyncReceiveMessageTransport,\n\tnodeEndpoint,\n\ttype NodeEndpoint,\n\ttype Remote,\n\ttype Endpoint,\n\ttype IsomorphicMessagePort,\n} from './comlink-sync';\nimport * as ErrorSerializer from './serialize-error';\n\nexport type WithAPIState = {\n\t/**\n\t * Resolves to true when the remote API is ready for\n\t * Comlink communication, but not necessarily fully initialized yet.\n\t */\n\tisConnected: () => Promise<void>;\n\t/**\n\t * Resolves to true when the remote API is declares it's\n\t * fully loaded and ready to be used.\n\t */\n\tisReady: () => Promise<void>;\n};\nexport type RemoteAPI<T> = Remote<T> & WithAPIState;\n\nexport async function consumeAPISync<APIType>(\n\tremote: IsomorphicMessagePort\n): Promise<APIType> {\n\tsetupTransferHandlers();\n\tconst transport = await NodeSABSyncReceiveMessageTransport.create();\n\treturn Comlink.wrapSync<APIType>(remote, transport);\n}\n\nexport function consumeAPI<APIType>(\n\tremote: Worker | Window | NodeEndpoint,\n\tcontext: undefined | EventTarget = undefined\n): RemoteAPI<APIType> {\n\tsetupTransferHandlers();\n\n\tlet endpoint;\n\tconst appearsToBeNodeEnvironment = import.meta.url.startsWith('file://');\n\tif (appearsToBeNodeEnvironment) {\n\t\tendpoint = nodeEndpoint(remote as NodeEndpoint);\n\t} else {\n\t\tendpoint =\n\t\t\tremote instanceof Worker\n\t\t\t\t? remote\n\t\t\t\t: Comlink.windowEndpoint(remote as Window, context);\n\t}\n\n\t/**\n\t * This shouldn't be necessary, but Comlink doesn't seem to\n\t * handle the initial isConnected() call correctly unless it's\n\t * explicitly provided here. This is especially weird\n\t * since the only thing this proxy does is to call the\n\t * isConnected() method on the remote API.\n\t *\n\t * @TODO: Remove this workaround.\n\t */\n\tconst api = Comlink.wrap<APIType & WithAPIState>(endpoint);\n\tconst methods = proxyClone(api);\n\treturn new Proxy(methods, {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'isConnected') {\n\t\t\t\treturn async () => {\n\t\t\t\t\t// Keep retrying until the remote API confirms it's connected.\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait runWithTimeout(api.isConnected(), 200);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\t// Timeout exceeded, try again. We can't just use a single\n\t\t\t\t\t\t\t// `runWithTimeout` call because it won't reach the remote API\n\t\t\t\t\t\t\t// if it's not connected yet. Instead, we need to keep retrying\n\t\t\t\t\t\t\t// until the remote API is connected and registers a handler\n\t\t\t\t\t\t\t// for the `isConnected` method.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn (api as any)[prop];\n\t\t},\n\t}) as unknown as RemoteAPI<APIType>;\n}\n\nasync function runWithTimeout<T>(\n\tpromise: Promise<T>,\n\ttimeout: number\n): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tsetTimeout(reject, timeout);\n\t\tpromise.then(resolve);\n\t});\n}\n\nexport type PublicAPI<Methods, PipedAPI = unknown> = RemoteAPI<\n\tMethods & PipedAPI\n>;\n\nexport function exposeAPI<Methods, PipedAPI>(\n\tapiMethods?: Methods,\n\tpipedApi?: PipedAPI,\n\ttargetWorker?: NodeEndpoint\n): [() => void, (e: Error) => void, PublicAPI<Methods, PipedAPI>] {\n\tconst { setReady, setFailed, exposedApi } = prepareForExpose(\n\t\tapiMethods,\n\t\tpipedApi\n\t);\n\tlet endpoint: Endpoint | undefined;\n\tif (targetWorker) {\n\t\t// NOTE: If there are other target types, we could expand this later,\n\t\t// but for now, we only need support for NodeEndpoints.\n\t\tendpoint = nodeEndpoint(targetWorker);\n\t} else {\n\t\tendpoint =\n\t\t\ttypeof window !== 'undefined'\n\t\t\t\t? Comlink.windowEndpoint(self.parent)\n\t\t\t\t: undefined;\n\t}\n\tComlink.expose(exposedApi, endpoint);\n\treturn [setReady, setFailed, exposedApi as PublicAPI<Methods, PipedAPI>];\n}\n\nexport async function exposeSyncAPI<Methods>(\n\tapiMethods: Methods,\n\tport: IsomorphicMessagePort\n): Promise<[() => void, (e: Error) => void, Methods]> {\n\tconst { setReady, setFailed, exposedApi } = prepareForExpose(apiMethods);\n\tconst transport = await NodeSABSyncReceiveMessageTransport.create();\n\tconst endpoint = nodeEndpoint(port as any);\n\tComlink.exposeSync(exposedApi, endpoint, transport);\n\treturn [setReady, setFailed, exposedApi as Methods];\n}\n\nfunction prepareForExpose<Methods, PipedAPI>(\n\tapiMethods?: Methods,\n\tpipedApi?: PipedAPI\n) {\n\tsetupTransferHandlers();\n\n\tconst connected = Promise.resolve();\n\n\tlet setReady: any;\n\tlet setFailed: any;\n\tconst ready = new Promise((resolve, reject) => {\n\t\tsetReady = resolve;\n\t\tsetFailed = reject;\n\t});\n\n\tconst methods = proxyClone(apiMethods);\n\tconst exposedApi = new Proxy(methods, {\n\t\tget: (target, prop) => {\n\t\t\tif (prop === 'isConnected') {\n\t\t\t\treturn () => connected;\n\t\t\t} else if (prop === 'isReady') {\n\t\t\t\treturn () => ready;\n\t\t\t} else if (prop in target) {\n\t\t\t\treturn target[prop];\n\t\t\t}\n\t\t\treturn (pipedApi as any)?.[prop];\n\t\t},\n\t}) as unknown as PublicAPI<Methods, PipedAPI>;\n\n\treturn { setReady, setFailed, exposedApi };\n}\n\nlet isTransferHandlersSetup = false;\nfunction setupTransferHandlers() {\n\tif (isTransferHandlersSetup) {\n\t\treturn;\n\t}\n\tisTransferHandlersSetup = true;\n\tComlink.transferHandlers.set('EVENT', {\n\t\tcanHandle: (obj): obj is CustomEvent => obj instanceof CustomEvent,\n\t\tserialize: (ev: CustomEvent) => {\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\tdetail: ev.detail,\n\t\t\t\t},\n\t\t\t\t[],\n\t\t\t];\n\t\t},\n\t\tdeserialize: (obj) => obj,\n\t});\n\tComlink.transferHandlers.set('FUNCTION', {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n\t\tcanHandle: (obj: unknown): obj is Function => typeof obj === 'function',\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n\t\tserialize(obj: Function) {\n\t\t\tconst { port1, port2 } = new MessageChannel();\n\t\t\tComlink.expose(obj, port1);\n\t\t\treturn [port2, [port2]];\n\t\t},\n\t\tdeserialize(port: any) {\n\t\t\tport.start();\n\t\t\treturn Comlink.wrap(port);\n\t\t},\n\t});\n\tComlink.transferHandlers.set('MESSAGE_PORT', {\n\t\tcanHandle: (obj: unknown): obj is MessagePort =>\n\t\t\tobj instanceof MessagePort,\n\t\tserialize(port: MessagePort): [MessagePort, Transferable[]] {\n\t\t\treturn [port, [port]];\n\t\t},\n\t\tdeserialize(port: MessagePort): MessagePort {\n\t\t\treturn port;\n\t\t},\n\t});\n\tComlink.transferHandlers.set('PHPResponse', {\n\t\tcanHandle: (obj: unknown): obj is PHPResponseData =>\n\t\t\ttypeof obj === 'object' &&\n\t\t\tobj !== null &&\n\t\t\t'headers' in obj &&\n\t\t\t'bytes' in obj &&\n\t\t\t'errors' in obj &&\n\t\t\t'exitCode' in obj &&\n\t\t\t'httpStatusCode' in obj,\n\t\tserialize(obj: PHPResponse): [PHPResponseData, Transferable[]] {\n\t\t\treturn [obj.toRawData(), []];\n\t\t},\n\t\tdeserialize(responseData: PHPResponseData): PHPResponse {\n\t\t\treturn PHPResponse.fromRawData(responseData);\n\t\t},\n\t});\n\t// Augment Comlink's throw handler to include Error the response and source\n\t// information in the serialized error object. BasePHP may throw\n\t// PHPExecutionFailureError which includes those information and we'll want to\n\t// display them for the user.\n\tconst throwHandler = Comlink.transferHandlers.get('throw')!;\n\tconst originalSerialize = throwHandler?.serialize;\n\tthrowHandler.serialize = ({ value }: any) => {\n\t\tconst serialized = originalSerialize({ value }) as any;\n\t\tif (value.response) {\n\t\t\tserialized[0].value.response = value.response;\n\t\t}\n\t\tif (value.source) {\n\t\t\tserialized[0].value.source = value.source;\n\t\t}\n\t\treturn serialized;\n\t};\n\n\tComlink.transferHandlers.set('StreamedPHPResponse', {\n\t\tcanHandle: (obj: unknown): obj is StreamedPHPResponse =>\n\t\t\tobj instanceof StreamedPHPResponse,\n\t\tserialize(obj: StreamedPHPResponse): [any, Transferable[]] {\n\t\t\tconst supportsStreams = supportsTransferableStreams();\n\t\t\tconst exitCodePort = promiseToPort(obj.exitCode);\n\t\t\tif (supportsStreams) {\n\t\t\t\tconst payload = {\n\t\t\t\t\t__type: 'StreamedPHPResponse',\n\t\t\t\t\theaders: (obj as any)['headersStream'],\n\t\t\t\t\tstdout: obj.stdout,\n\t\t\t\t\tstderr: obj.stderr,\n\t\t\t\t\texitCodePort,\n\t\t\t\t};\n\t\t\t\treturn [payload, [exitCodePort]];\n\t\t\t}\n\t\t\t// Fallback: bridge streams via MessagePorts\n\t\t\tconst headersPort = streamToPort((obj as any)['headersStream']);\n\t\t\tconst stdoutPort = streamToPort(obj.stdout);\n\t\t\tconst stderrPort = streamToPort(obj.stderr);\n\t\t\tconst payload = {\n\t\t\t\t__type: 'StreamedPHPResponse',\n\t\t\t\theadersPort,\n\t\t\t\tstdoutPort,\n\t\t\t\tstderrPort,\n\t\t\t\texitCodePort,\n\t\t\t};\n\t\t\treturn [\n\t\t\t\tpayload,\n\t\t\t\t[headersPort, stdoutPort, stderrPort, exitCodePort],\n\t\t\t];\n\t\t},\n\t\tdeserialize(data: any): StreamedPHPResponse {\n\t\t\tif (data.headers && data.stdout && data.stderr) {\n\t\t\t\tconst exitCode = portToPromise(\n\t\t\t\t\tdata.exitCodePort as MessagePort\n\t\t\t\t);\n\t\t\t\treturn new StreamedPHPResponse(\n\t\t\t\t\tdata.headers as ReadableStream<Uint8Array>,\n\t\t\t\t\tdata.stdout as ReadableStream<Uint8Array>,\n\t\t\t\t\tdata.stderr as ReadableStream<Uint8Array>,\n\t\t\t\t\texitCode\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst headers = portToStream(data.headersPort as MessagePort);\n\t\t\tconst stdout = portToStream(data.stdoutPort as MessagePort);\n\t\t\tconst stderr = portToStream(data.stderrPort as MessagePort);\n\t\t\tconst exitCode = portToPromise(data.exitCodePort as MessagePort);\n\t\t\treturn new StreamedPHPResponse(headers, stdout, stderr, exitCode);\n\t\t},\n\t});\n}\n\n// Utilities for transferring ReadableStreams and Promises via MessagePorts:\n\n/**\n * Safari does not support transferable streams, so we need to fallback to\n * MessagePorts.\n * Feature-detects whether this runtime supports transferring ReadableStreams\n * directly through postMessage (aka \"transferable streams\"). When false,\n * we must fall back to port-bridged streaming.\n */\nfunction supportsTransferableStreams(): boolean {\n\ttry {\n\t\tif (typeof ReadableStream === 'undefined') return false;\n\t\tconst { port1 } = new MessageChannel();\n\t\tconst rs = new ReadableStream();\n\t\tport1.postMessage(rs as any);\n\t\ttry {\n\t\t\tport1.close();\n\t\t} catch (_e) {\n\t\t\tvoid _e;\n\t\t}\n\t\treturn true;\n\t} catch (_e) {\n\t\tvoid _e;\n\t\treturn false;\n\t}\n}\n\n/**\n * Bridges a ReadableStream to a MessagePort by reading chunks and posting\n * messages to the port. Used as a fallback when transferable streams are not\n * supported (e.g., Safari).\n *\n * Protocol of the returned MessagePort:\n *\n *   { t: 'chunk', b: ArrayBuffer } – next binary chunk\n *   { t: 'close' }                 – end of stream\n *   { t: 'error', m: string }      – terminal error\n */\nfunction streamToPort(stream: ReadableStream<Uint8Array>): MessagePort {\n\tconst { port1, port2 } = new MessageChannel();\n\t(async () => {\n\t\tconst reader = stream.getReader();\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tconst { done, value } = await reader.read();\n\t\t\t\tif (done) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tport1.postMessage({ t: 'close' });\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Ignore error\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tport1.close();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Ignore error\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (value) {\n\t\t\t\t\t// Ensure we transfer an owned buffer\n\t\t\t\t\tconst owned =\n\t\t\t\t\t\tvalue.byteOffset === 0 &&\n\t\t\t\t\t\tvalue.byteLength === value.buffer.byteLength\n\t\t\t\t\t\t\t? value\n\t\t\t\t\t\t\t: value.slice();\n\t\t\t\t\tconst buf = owned.buffer;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tport1.postMessage({ t: 'chunk', b: buf }, [\n\t\t\t\t\t\t\tbuf as unknown as Transferable,\n\t\t\t\t\t\t]);\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tport1.postMessage({\n\t\t\t\t\t\t\tt: 'chunk',\n\t\t\t\t\t\t\tb: owned.buffer.slice(0),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e: any) {\n\t\t\ttry {\n\t\t\t\tport1.postMessage({ t: 'error', m: e?.message || String(e) });\n\t\t\t} catch {\n\t\t\t\t// Ignore error\n\t\t\t}\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tport1.close();\n\t\t\t} catch {\n\t\t\t\t// Ignore error\n\t\t\t}\n\t\t}\n\t})();\n\treturn port2;\n}\n\n/**\n * Reconstructs a ReadableStream from a MessagePort using the inverse of the\n * streamToPort protocol. Each message enqueues data, closes, or errors.\n */\nfunction portToStream(port: MessagePort): ReadableStream<Uint8Array> {\n\treturn new ReadableStream<Uint8Array>({\n\t\tstart(controller) {\n\t\t\tconst onMessage = (ev: MessageEvent) => {\n\t\t\t\tconst data: any = (ev as any).data;\n\t\t\t\tif (!data) return;\n\t\t\t\tswitch (data.t) {\n\t\t\t\t\tcase 'chunk':\n\t\t\t\t\t\tcontroller.enqueue(new Uint8Array(data.b));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'close':\n\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\tcontroller.error(new Error(data.m || 'Stream error'));\n\t\t\t\t\t\tcleanup();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst cleanup = () => {\n\t\t\t\ttry {\n\t\t\t\t\tport.removeEventListener?.('message', onMessage as any);\n\t\t\t\t} catch {\n\t\t\t\t\t// Ignore error\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tport.onmessage = null;\n\t\t\t\t} catch {\n\t\t\t\t\t// Ignore error\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tport.close();\n\t\t\t\t} catch {\n\t\t\t\t\t// Ignore error\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (port.addEventListener) {\n\t\t\t\tport.addEventListener('message', onMessage as any);\n\t\t\t} else if ((port as any).on) {\n\t\t\t\t(port as any).on('message', (data: any) =>\n\t\t\t\t\tonMessage({ data } as any)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tport.onmessage = onMessage as any;\n\t\t\t}\n\t\t\tif (typeof port.start === 'function') {\n\t\t\t\tport.start();\n\t\t\t}\n\t\t},\n\t\tcancel() {\n\t\t\ttry {\n\t\t\t\tport.close();\n\t\t\t} catch {\n\t\t\t\t// Ignore error\n\t\t\t}\n\t\t},\n\t});\n}\n\n/**\n * Bridges a Promise to a MessagePort so it can be delivered across threads.\n *\n * Protocol of the returned MessagePort:\n *\n *   { t: 'resolve', v: any } – promise resolved with value v\n *   { t: 'reject',  m: str } – promise rejected with message m\n */\nfunction promiseToPort(promise: Promise<any>): MessagePort {\n\tconst { port1, port2 } = new MessageChannel();\n\tpromise\n\t\t.then((value) => {\n\t\t\ttry {\n\t\t\t\tport1.postMessage({ t: 'resolve', v: value });\n\t\t\t} catch {\n\t\t\t\t// Ignore error\n\t\t\t}\n\t\t})\n\t\t.catch((err) => {\n\t\t\ttry {\n\t\t\t\tport1.postMessage({\n\t\t\t\t\tt: 'reject',\n\t\t\t\t\tm: (err as any)?.message || String(err),\n\t\t\t\t});\n\t\t\t} catch {\n\t\t\t\t// Ignore error\n\t\t\t}\n\t\t})\n\t\t.finally(() => {\n\t\t\ttry {\n\t\t\t\tport1.close();\n\t\t\t} catch {\n\t\t\t\t// Ignore error\n\t\t\t}\n\t\t});\n\treturn port2;\n}\n\n/**\n * Reconstructs a Promise from a MessagePort using the inverse of\n * promiseToPort. Resolves or rejects when the corresponding message arrives.\n */\nfunction portToPromise(port: MessagePort): Promise<any> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst onMessage = (ev: MessageEvent) => {\n\t\t\tconst data: any = (ev as any).data;\n\t\t\tif (!data) return;\n\t\t\tif (data.t === 'resolve') {\n\t\t\t\tcleanup();\n\t\t\t\tresolve(data.v);\n\t\t\t} else if (data.t === 'reject') {\n\t\t\t\tcleanup();\n\t\t\t\treject(new Error(data.m || ''));\n\t\t\t}\n\t\t};\n\t\tconst cleanup = () => {\n\t\t\ttry {\n\t\t\t\tport.removeEventListener?.('message', onMessage as any);\n\t\t\t} catch {\n\t\t\t\t// Ignore error\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tport.onmessage = null;\n\t\t\t} catch {\n\t\t\t\t// Ignore error\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tport.close();\n\t\t\t} catch {\n\t\t\t\t// Ignore error\n\t\t\t}\n\t\t};\n\t\tif (port.addEventListener) {\n\t\t\tport.addEventListener('message', onMessage as any);\n\t\t} else if ((port as any).on) {\n\t\t\t(port as any).on('message', (data: any) =>\n\t\t\t\tonMessage({ data } as any)\n\t\t\t);\n\t\t} else {\n\t\t\tport.onmessage = onMessage as any;\n\t\t}\n\t\tif (typeof port.start === 'function') {\n\t\t\tport.start();\n\t\t}\n\t});\n}\n\n// Augment Comlink's throw handler to include all the information carried by\n// the thrown object, including the cause, additional properties, etc.\ninterface UnserializedError {\n\tvalue: unknown;\n}\ntype SerializedError =\n\t| { isError: true; value: ErrorSerializer.ErrorObject }\n\t| { isError: false; value: unknown };\n\nconst throwTransferHandler = Comlink.transferHandlers.get(\n\t'throw'\n) as Comlink.TransferHandler<UnserializedError, SerializedError>;\n\nconst throwTransferHandlerCustom: Comlink.TransferHandler<\n\tUnserializedError,\n\tSerializedError\n> = {\n\tcanHandle: throwTransferHandler.canHandle,\n\tserialize: ({ value }) => {\n\t\tlet serialized: SerializedError;\n\t\tif (value instanceof Error) {\n\t\t\tserialized = {\n\t\t\t\tisError: true,\n\t\t\t\tvalue: ErrorSerializer.serializeError(value),\n\t\t\t};\n\t\t\t// The error class name is not serialized by serialize-error, let's add it manually.\n\t\t\tserialized.value['originalErrorClassName'] = value.constructor.name;\n\t\t} else {\n\t\t\tserialized = { isError: false, value };\n\t\t}\n\t\treturn [serialized, []];\n\t},\n\tdeserialize: (serialized) => {\n\t\tif (serialized.isError) {\n\t\t\tconst error = ErrorSerializer.deserializeError(serialized.value);\n\t\t\t/**\n\t\t\t * The original error from the web worker does not include any call\n\t\t\t * stack from the Playground web app. Let's include that information\n\t\t\t * in the error chain.\n\t\t\t *\n\t\t\t * We'll place it at the bottom of the error chain. This way the API\n\t\t\t * consumer gets the original error object and not an opaque\n\t\t\t * \"Comlink method call failed\" error, but they can still inspect\n\t\t\t * it further to see the full call stack.\n\t\t\t */\n\t\t\tconst additionalCallStack = new Error('Comlink method call failed');\n\t\t\tlet deepestError = error;\n\t\t\twhile (deepestError.cause) {\n\t\t\t\tdeepestError = deepestError.cause;\n\t\t\t}\n\t\t\tdeepestError.cause = additionalCallStack;\n\t\t\tthrow error;\n\t\t}\n\t\tthrow serialized.value;\n\t},\n};\n\nComlink.transferHandlers.set('throw', throwTransferHandlerCustom);\n\nfunction proxyClone(object: any): any {\n\treturn new Proxy(object, {\n\t\tget(target, prop) {\n\t\t\tswitch (typeof target[prop]) {\n\t\t\t\tcase 'function':\n\t\t\t\t\treturn (...args: any[]) => target[prop](...args);\n\t\t\t\tcase 'object':\n\t\t\t\t\tif (target[prop] === null) {\n\t\t\t\t\t\treturn target[prop];\n\t\t\t\t\t}\n\t\t\t\t\treturn proxyClone(target[prop]);\n\t\t\t\tcase 'undefined':\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'string':\n\t\t\t\t\treturn target[prop];\n\t\t\t\tdefault:\n\t\t\t\t\treturn Comlink.proxy(target[prop]);\n\t\t\t}\n\t\t},\n\t});\n}\n","const DEFAULT_RESPONSE_TIMEOUT = 25000;\n\nlet lastRequestId = 0;\n\n/**\n * Posts a message branded with a unique `requestId` to the given `target`.\n * Then returns the `requestId` so it can be used to await a reply.\n * Effectively, it implements the request/response dynamics on\n * of JavaScript's `postMessage`\n *\n * @example\n *\n * In the main app:\n *\n * ```js\n * import { postMessageExpectReply, awaitReply } from 'php-wasm-browser';\n * const iframeWindow = iframe.contentWindow;\n * const requestId = postMessageExpectReply(iframeWindow, {\n *    type: \"get_php_version\"\n * });\n * const response = await awaitReply(iframeWindow, requestId);\n * console.log(response);\n * // \"8.0.24\"\n * ```\n *\n * In the iframe:\n *\n * ```js\n * import { responseTo } from 'php-wasm-browser';\n * window.addEventListener('message', (event) => {\n *    let response = '8.0.24';\n *    if(event.data.type === 'get_php_version') {\n *       response = '8.0.24';\n *    } else {\n *       throw new Error(`Unexpected message type: ${event.data.type}`);\n *    }\n *\n *    // When `requestId` is present, the other thread expects a response:\n *    if (event.data.requestId) {\n *       const response = responseTo(event.data.requestId, response);\n *       window.parent.postMessage(response, event.origin);\n *    }\n * });\n * ```\n *\n * @param  target          An object that has a `postMessage` method.\n * @param  message         A key-value object that can be serialized to JSON.\n * @param  postMessageArgs Additional arguments to pass to `postMessage`.\n * @returns The message ID for awaitReply().\n */\nexport function postMessageExpectReply(\n\ttarget: PostMessageTarget,\n\tmessage: Record<string, any>,\n\t...postMessageArgs: any[]\n): number {\n\tconst requestId = getNextRequestId();\n\ttarget.postMessage(\n\t\t{\n\t\t\t...message,\n\t\t\trequestId,\n\t\t},\n\t\t...postMessageArgs\n\t);\n\treturn requestId;\n}\n\nexport function getNextRequestId() {\n\treturn ++lastRequestId;\n}\n\n/**\n * Awaits a reply to the message with the given ID.\n *\n * @see postMessageExpectReply\n * @throws {@link Error} If the reply is not received within the timeout.\n * @param  messageTarget EventEmitter emitting `message` events, e.g. `window`\n *                       or a `Worker` instance.\n * @param  requestId     The message ID returned by postMessageExpectReply().\n * @param  timeout       The number of milliseconds to wait for a reply before\n *                       throwing an error.\n * @returns The reply from the messageTarget.\n */\nexport function awaitReply(\n\tmessageTarget: IsomorphicEventTarget,\n\trequestId: number,\n\ttimeout: number = DEFAULT_RESPONSE_TIMEOUT\n): Promise<any> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst responseHandler = (event: MessageEvent) => {\n\t\t\tif (\n\t\t\t\tevent.data.type === 'response' &&\n\t\t\t\tevent.data.requestId === requestId\n\t\t\t) {\n\t\t\t\tmessageTarget.removeEventListener('message', responseHandler);\n\t\t\t\tclearTimeout(failOntimeout);\n\t\t\t\tresolve(event.data.response);\n\t\t\t}\n\t\t};\n\n\t\tconst failOntimeout = setTimeout(() => {\n\t\t\treject(new Error('Request timed out'));\n\t\t\tmessageTarget.removeEventListener('message', responseHandler);\n\t\t}, timeout);\n\n\t\tmessageTarget.addEventListener('message', responseHandler);\n\t});\n}\n\n/**\n * Creates a response message to the given message ID.\n *\n * @see postMessageExpectReply\n * @param  requestId The message ID sent from the other thread by\n *                   `postMessageExpectReply` in the `message` event.\n * @param  response  The response to send back to the messageTarget.\n * @returns A message object that can be sent back to the other thread.\n */\nexport function responseTo<T>(\n\trequestId: number,\n\tresponse: T\n): MessageResponse<T> {\n\treturn {\n\t\ttype: 'response',\n\t\trequestId,\n\t\tresponse,\n\t};\n}\n\nexport interface MessageResponse<T> {\n\ttype: 'response';\n\trequestId: number;\n\tresponse: T;\n}\n\ninterface PostMessageTarget {\n\tpostMessage(message: any, ...args: any[]): void;\n}\n\ninterface IsomorphicEventTarget {\n\taddEventListener(type: string, listener: (event: any) => void): void;\n\tremoveEventListener(type: string, listener: (event: any) => void): void;\n}\n","/// <reference lib=\"WebWorker\" />\ndeclare const self: ServiceWorkerGlobalScope;\n\nimport { awaitReply, getNextRequestId } from './messaging';\nimport { getURLScope, isURLScoped, setURLScope } from '@php-wasm/scopes';\n\nexport async function convertFetchEventToPHPRequest(event: FetchEvent) {\n\tlet url = new URL(event.request.url);\n\n\tif (!isURLScoped(url)) {\n\t\ttry {\n\t\t\tconst referrerUrl = new URL(event.request.referrer);\n\t\t\turl = setURLScope(url, getURLScope(referrerUrl)!);\n\t\t} catch {\n\t\t\t// ignore\n\t\t}\n\t}\n\n\tconst contentType = event.request.headers.get('content-type')!;\n\tconst body =\n\t\tevent.request.method === 'POST'\n\t\t\t? new Uint8Array(await event.request.clone().arrayBuffer())\n\t\t\t: undefined;\n\tconst requestHeaders: Record<string, string> = {};\n\tfor (const pair of (event.request.headers as any).entries()) {\n\t\trequestHeaders[pair[0]] = pair[1];\n\t}\n\n\tlet phpResponse;\n\ttry {\n\t\tconst message = {\n\t\t\tmethod: 'request',\n\t\t\targs: [\n\t\t\t\t{\n\t\t\t\t\tbody,\n\t\t\t\t\turl: url.toString(),\n\t\t\t\t\tmethod: event.request.method,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t...requestHeaders,\n\t\t\t\t\t\tHost: url.host,\n\t\t\t\t\t\t// Safari and Firefox don't make the User-Agent header\n\t\t\t\t\t\t// available in the fetch event. Let's add it manually:\n\t\t\t\t\t\t'User-agent': self.navigator.userAgent,\n\t\t\t\t\t\t'Content-type': contentType,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\t\tconst scope = getURLScope(url);\n\t\tif (scope === null) {\n\t\t\tthrow new Error(\n\t\t\t\t`The URL ${url.toString()} is not scoped. This should not happen.`\n\t\t\t);\n\t\t}\n\t\tconst requestId = await broadcastMessageExpectReply(message, scope);\n\t\tphpResponse = await awaitReply(self, requestId);\n\n\t\t// X-frame-options gets in a way when PHP is\n\t\t// being displayed in an iframe.\n\t\tdelete phpResponse.headers['x-frame-options'];\n\t} catch (e) {\n\t\tconsole.error(e, { url: url.toString() });\n\t\tthrow e;\n\t}\n\n\t/**\n\t * Safari has a bug that prevents Service Workers from redirecting relative URLs.\n\t * When attempting to redirect to a relative URL, the network request will return an error.\n\t * See the Webkit bug for details: https://bugs.webkit.org/show_bug.cgi?id=282427.\n\t *\n\t * Because PHP and WordPress can redirect to both relative and absolute URLs\n\t * using the `location` header we need to ensure redirects are processed\n\t * correctly by the Service Worker.\n\t *\n\t * As a workaround for Safari Service Workers, we use `Response.redirect()`\n\t * for all redirect responses (300-399 status codes) coming from PHP.\n\t * This solution was suggested in the Webkit bug comment:\n\t * https://bugs.webkit.org/show_bug.cgi?id=282427#c2\n\t */\n\tif (\n\t\tphpResponse.httpStatusCode >= 300 &&\n\t\tphpResponse.httpStatusCode <= 399 &&\n\t\tphpResponse.headers['location']\n\t) {\n\t\treturn Response.redirect(\n\t\t\tnew URL(phpResponse.headers['location'][0], url.toString()),\n\t\t\tphpResponse.httpStatusCode\n\t\t);\n\t}\n\t/**\n\t * Make sure we don't pass an actual body string to new Response()\n\t * if the status is a null body status (101, 103, 204, 205, or 304).\n\t * new Response() throws a TypeError in that case, as the fetch() spec\n\t * requires.\n\t *\n\t * @see https://fetch.spec.whatwg.org/#statuses\n\t */\n\tconst isNullBodyCode = [101, 103, 204, 205, 304].includes(\n\t\tphpResponse.httpStatusCode\n\t);\n\tconst responseBody = isNullBodyCode ? null : phpResponse.bytes;\n\treturn new Response(responseBody, {\n\t\theaders: phpResponse.headers,\n\t\tstatus: phpResponse.httpStatusCode,\n\t});\n}\n\n/**\n * Sends the message to all the controlled clients\n * of this service worker.\n *\n * This used to be implemented with a BroadcastChannel, but\n * it didn't work in Safari. BroadcastChannel breaks iframe\n * embedding the playground in Safari.\n *\n * Weirdly, Safari does not pass any messages from the ServiceWorker\n * to Window if the page is rendered inside an iframe. Window to Service\n * Worker communication works just fine.\n *\n * The regular client.postMessage() communication works perfectly, so that's\n * what this function uses to broadcast the message.\n *\n * @param  message The message to broadcast.\n * @param  scope   Target web worker scope.\n * @returns The request ID to receive the reply.\n */\nexport async function broadcastMessageExpectReply(message: any, scope: string) {\n\tconst requestId = getNextRequestId();\n\tfor (const client of await self.clients.matchAll({\n\t\t// Sometimes the client that triggered the current fetch()\n\t\t// event is considered uncontrolled in Google Chrome. This\n\t\t// only happens on the first few fetches() after the initial\n\t\t// registration of the service worker.\n\t\tincludeUncontrolled: true,\n\t})) {\n\t\tclient.postMessage({\n\t\t\t...message,\n\t\t\t/**\n\t\t\t * Attach the scope with a URL starting with `/scope:` to this message.\n\t\t\t *\n\t\t\t * We need this mechanics because this worker broadcasts\n\t\t\t * events to all the listeners across all browser tabs. Scopes\n\t\t\t * helps WASM workers ignore requests meant for other WASM workers.\n\t\t\t */\n\t\t\tscope,\n\t\t\trequestId,\n\t\t});\n\t}\n\treturn requestId;\n}\n\n/**\n * Copy a request with custom overrides.\n *\n * This function is only needed because Request properties\n * are read-only. The only way to change e.g. a URL is to\n * create an entirely new request:\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Request\n *\n * @param  request\n * @param  overrides\n * @returns The new request.\n */\nexport async function cloneRequest(\n\trequest: Request,\n\toverrides: Record<string, any>\n): Promise<Request> {\n\tlet body: Blob | ReadableStream | undefined;\n\n\tif (['GET', 'HEAD'].includes(request.method) || 'body' in overrides) {\n\t\tbody = undefined;\n\t} else if (!request.bodyUsed && request.body) {\n\t\t// If the body hasn't been consumed yet, we can reuse the stream directly\n\t\t// This avoids the hang that occurs when trying to read from a stream\n\t\t// that's still waiting for more data\n\t\tbody = request.body;\n\t} else {\n\t\t// Otherwise, we need to read the body as a blob\n\t\tbody = await request.blob();\n\t}\n\n\treturn new Request(overrides['url'] || request.url, {\n\t\tbody,\n\t\tmethod: request.method,\n\t\theaders: request.headers,\n\t\treferrer: request.referrer,\n\t\treferrerPolicy: request.referrerPolicy,\n\t\tmode: request.mode === 'navigate' ? 'same-origin' : request.mode,\n\t\tcredentials: request.credentials,\n\t\tcache: request.cache,\n\t\tredirect: request.redirect,\n\t\tintegrity: request.integrity,\n\t\t...(body && { duplex: 'half' }),\n\t\t...overrides,\n\t});\n}\n\n/**\n * Tee a request to ensure the body stream is not consumed\n * when executing or cloning the request.\n *\n * @param request\n * @returns\n */\nexport async function teeRequest(\n\trequest: Request\n): Promise<[Request, Request]> {\n\tif (!request.body) {\n\t\treturn [request, request];\n\t}\n\tconst [body1, body2] = request.body.tee();\n\treturn [\n\t\tawait cloneRequest(request, { body: body1, duplex: 'half' }),\n\t\tawait cloneRequest(request, { body: body2, duplex: 'half' }),\n\t];\n}\n\n/**\n * Extracts headers from a Request as a plain key->value JS object.\n *\n * @param request\n * @returns\n */\nexport function getRequestHeaders(request: Request) {\n\tconst headers: Record<string, string> = {};\n\trequest.headers.forEach((value: string, key: string) => {\n\t\theaders[key] = value;\n\t});\n\treturn headers;\n}\n","import type { RewriteRule } from '@php-wasm/universal';\n\n/**\n * WordPress rewrite rules adapted for Playground.\n *\n * These rules are matched against the requested path without the site path prefix.\n *\n * For example:\n *\n *     * The site URL is `https://playground.wordpress.net/scope:ambitious-chic-country/`.\n *     * The site path prefix is `/scope:ambitious-chic-country/`.\n *     * The requested URL is `https://playground.wordpress.net/scope:ambitious-chic-country/wp-admin/index.php`,\n *     * The requested path without the site path prefix is `/wp-admin/index.php`.\n *\n * And so, the rewrite rules are matched against `/wp-admin/index.php`.\n * This is similar to setting the `RewriteBase` to `/scope:ambitious-chic-country`.\n *\n * ## Rationale\n *\n * WordPress does not use a single, static set of rewrite rules. Rather, it generates\n * its own .htaccess file based on the current configuration using the save_mod_rewrite_rules()\n * function:\n *\n * https://developer.wordpress.org/reference/functions/save_mod_rewrite_rules/\n *\n * Here's a few examples of what that .htaccess might look like for different\n * WordPress configurations:\n *\n * ### Vanilla WordPress single-site installation\n *\n * ```apache\n * RewriteBase /\n * RewriteRule ^index\\.php$ - [L]\n * RewriteCond %{REQUEST_FILENAME} !-f\n * RewriteCond %{REQUEST_FILENAME} !-d\n * RewriteRule . /index.php [L]\n * ```\n *\n * ### Single-site installation living at a /subdirectory/\n *\n * ```apache\n * # https://developer.wordpress.org/advanced-administration/server/wordpress-in-directory/:\n * RewriteCond %{REQUEST_URI} !^/subdirectory/\n * RewriteCond %{REQUEST_FILENAME} !-f\n * RewriteCond %{REQUEST_FILENAME} !-d\n * RewriteRule ^(.*)$ /subdirectory/$1\n * RewriteRule ^(/)?$ subdirectory/index.php [L]\n * ```\n *\n * Some sources also set the RewriteBase to `/subdirectory/`.\n *\n * ### Multisite installation using subfolder network type\n *\n * ```apache\n * # https://wordpress.org/documentation/article/htaccess/#multisite\n *\n * RewriteBase /\n * RewriteRule ^index\\.php$ - [L]\n *\n * // add a trailing slash to /wp-admin\n * RewriteRule ^([_0-9a-zA-Z-]+/)?wp-admin$ $1wp-admin/ [R=301,L]\n *\n * RewriteCond %{REQUEST_FILENAME} -f [OR]\n * RewriteCond %{REQUEST_FILENAME} -d\n * RewriteRule ^ - [L]\n * RewriteRule ^([_0-9a-zA-Z-]+/)?(wp-(content|admin|includes).*) $2 [L]\n * RewriteRule ^([_0-9a-zA-Z-]+/)?(.*\\.php)$ $2 [L]\n * RewriteRule . index.php [L]\n * ```\n *\n * # Multisite living at /scope:ambitious-chic-country/\n *\n * ```apache\n * RewriteBase /scope:ambitious-chic-country/\n * RewriteRule ^index\\.php$ - [L]\n *\n * // Add a trailing slash to /wp-admin\n * RewriteRule ^([_0-9a-zA-Z-]+/)?wp-admin$ $1wp-admin/ [R=301,L]\n *\n * RewriteCond %{REQUEST_FILENAME} -f [OR]\n * RewriteCond %{REQUEST_FILENAME} -d\n * RewriteRule ^ - [L]\n *\n * // The `wordpress/` prefix matches the document root, but seeing\n * // it here is unexpected. @TODO: Why is it being added by WordPress?\n * RewriteRule ^([_0-9a-zA-Z-]+/)?(wp-(content|admin|includes).*) wordpress/$2 [L]\n * RewriteRule ^([_0-9a-zA-Z-]+/)?(.*\\.php)$ wordpress/$2 [L]\n * RewriteRule . index.php [L]\n * ```\n *\n * ## .htaccess syntax\n *\n * Here's an excerpt/summary from the .htaccess documentation [^1][^2] for\n * convenience:\n *\n *     The mod_rewrite module uses a rule-based rewriting engine, based\n *     on a PCRE regular-expression parser, to rewrite requested URLs on\n *     the fly. By default, mod_rewrite maps a URL to a filesystem path.\n *     However, it can also be used to redirect one URL to another URL,\n *     or to invoke an internal proxy fetch.\n *\n *     ## RewriteBase Directive\n *\n *     The RewriteBase directive specifies the URL prefix to be used for\n *     per-directory (htaccess) RewriteRule directives that substitute a\n *     relative path.\n *\n *     Syntax:\n *          RewriteBase URL-path\n *\n *     (Setting RewriteBase to \"/\" makes it possible to use RewriteRule\n *      patterns that **do not** start with a slash.)\n *\n *     ## RewriteRule Directive\n *\n *     Defines rules for the rewriting engine.\n *\n *     Syntax:\n *          RewriteRule Pattern Substitution [flags]\n *\n *     ## Flags\n *\n *        - L|Last\n *            Stop processing the rule set. In most contexts, this means\n *            that if the rule matches, no further rules will be processed\n *\n *        - NC|No Case\n *            Ignore case when matching.\n *\n *        - R|Redirect\n *            Causes a HTTP redirect to be issued to the browser.\n *\n *        (Note that Playground does not implement analogs of these flags as\n *         there was no need for them yet. They're only described here for\n *         convenience to help you read the original .htaccess rules.)\n *\n * ## Differences with .htaccess\n *\n * [1] https://httpd.apache.org/docs/current/rewrite/intro.html\n * [2] https://httpd.apache.org/docs/current/rewrite/flags.html\n */\nexport const wordPressRewriteRules: RewriteRule[] = [\n\t/**\n\t * Substitutes the multisite WordPress rewrite rule:\n\t *\n\t * RewriteBase /\n\t * RewriteRule ^([_0-9a-zA-Z-]+/)?(wp-(content|admin|includes).*) $2 [L]\n\t */\n\t{\n\t\tmatch: new RegExp(\n\t\t\t/* The .htaccess rule does not have an explicit initial slash,\n\t\t\t\tbut it's still implied by `RewriteBase /` */\n\t\t\t`^(/[_0-9a-zA-Z-]+)?` +\n\t\t\t\t/**\n\t\t\t\t * Avoid discarding the initial slash of the rewritten URL.\n\t\t\t\t * .htaccess places the trailing slash in the first group. It\n\t\t\t\t * relies on the implicit `RewriteBase /` again – the final,\n\t\t\t\t * rewritten URL still has the `/` at the beginning. This rule\n\t\t\t\t * does not have an implied RewriteBase, so the only way to preserve\n\t\t\t\t * the `/` at the beginning is to avoid replacing it.\n\t\t\t\t */\n\t\t\t\t'(/' +\n\t\t\t\t// The rest of the pattern is the same:\n\t\t\t\t`wp-(content|admin|includes)/.*)`\n\t\t),\n\t\treplacement: '$2',\n\t},\n];\n","import { isURLScoped } from '@php-wasm/scopes';\n// @ts-ignore\nimport { buildVersion } from 'virtual:remote-config';\n\nconst CACHE_NAME_PREFIX = 'playground-cache';\nconst LATEST_CACHE_NAME = `${CACHE_NAME_PREFIX}-${buildVersion}`;\n\n// We save a top-level Promise because this module is imported by\n// a Service Worker module which does not allow top-level await.\nconst promisedOfflineModeCache = caches.open(LATEST_CACHE_NAME);\n\nexport async function cacheFirstFetch(request: Request): Promise<Response> {\n\tconst offlineModeCache = await promisedOfflineModeCache;\n\tconst cachedResponse = await offlineModeCache.match(request, {\n\t\tignoreSearch: true,\n\t});\n\tif (cachedResponse) {\n\t\treturn cachedResponse;\n\t}\n\n\t/**\n\t * Ensure the response is not coming from HTTP cache.\n\t *\n\t * We never want to put a stale asset in CacheStorage as\n\t * that would break Playground.\n\t *\n\t * See service-worker.ts for more details.\n\t */\n\tconst response = await fetchFresh(request);\n\tif (response.ok) {\n\t\t/**\n\t\t * Confirm the current service worker is still active\n\t\t * when the asset is fetched. Caching a stale request\n\t\t * from a stale worker has no benefits. It only takes\n\t\t * up space.\n\t\t */\n\t\tif (isCurrentServiceWorkerActive()) {\n\t\t\t// Intentionally do not await writing to the cache so the response\n\t\t\t// promise can be returned immediately and observed for progress events.\n\t\t\t// NOTE: This is a race condition for simultaneous requests for the same asset.\n\t\t\tofflineModeCache.put(request, response.clone());\n\t\t}\n\t}\n\n\treturn response;\n}\n\nexport async function networkFirstFetch(request: Request): Promise<Response> {\n\tconst offlineModeCache = await promisedOfflineModeCache;\n\tconst cachedResponse = await offlineModeCache.match(request, {\n\t\tignoreSearch: true,\n\t});\n\n\tlet response: Response | undefined = undefined;\n\ttry {\n\t\tresponse = await fetch(request, {\n\t\t\tcache: 'no-cache',\n\t\t});\n\t} catch (e) {\n\t\tif (cachedResponse) {\n\t\t\treturn cachedResponse;\n\t\t}\n\t\tthrow e;\n\t}\n\n\tif (response.ok) {\n\t\t// Intentionally do not await writing to the cache so the response\n\t\t// promise can be returned immediately and observed for progress events.\n\t\t// NOTE: This is a race condition for simultaneous requests for the same asset.\n\t\tofflineModeCache.put(request, response.clone());\n\t\treturn response;\n\t}\n\n\tif (cachedResponse) {\n\t\treturn cachedResponse;\n\t}\n\n\treturn response;\n}\n\n/**\n * For offline mode to work we need to cache all required assets.\n *\n * These assets are listed in the `/assets-required-for-offline-mode.json`\n * file and contain JavaScript, CSS, and other assets required to load the\n * site without making any network requests.\n */\nexport async function cacheOfflineModeAssetsForCurrentRelease(): Promise<any> {\n\t// Get the cache manifest and add all the files to the cache\n\tconst manifestResponse = await fetchFresh(\n\t\t'/assets-required-for-offline-mode.json'\n\t);\n\tconst requiredOfflineAssetUrls = await manifestResponse.json();\n\tconst urlsToCache = ['/', ...requiredOfflineAssetUrls];\n\tconst websiteRequests = urlsToCache.map(\n\t\t/**\n\t\t * Ensure the response is not coming from HTTP cache.\n\t\t *\n\t\t * If it did, we'd risk mixing assets from different\n\t\t * Playground builds and breaking the site.\n\t\t *\n\t\t * See service-worker.ts for more details.\n\t\t */\n\t\t(url: string) => new Request(url, { cache: 'no-cache' })\n\t);\n\tconst offlineModeCache = await promisedOfflineModeCache;\n\tawait offlineModeCache.addAll(websiteRequests);\n}\n\n/**\n * Remove outdated files from the cache.\n *\n * We cache data based on `buildVersion` which is updated whenever Playground\n * is built. So when a new version of Playground is deployed, the service\n * worker will remove the old cache and cache the new assets.\n *\n * If your build version doesn't change while developing locally check\n * `buildVersionPlugin` for more details on how it's generated.\n */\nexport async function purgeEverythingFromPreviousRelease() {\n\tconst keys = await caches.keys();\n\tconst oldKeys = keys.filter(\n\t\t(key) => key.startsWith(CACHE_NAME_PREFIX) && key !== LATEST_CACHE_NAME\n\t);\n\treturn Promise.all(oldKeys.map((key) => caches.delete(key)));\n}\n\n/**\n * Answers whether a given URL has a response in the offline mode cache.\n * Ignores the search part of the URL by default.\n */\nexport async function hasCachedResponse(\n\turl: string,\n\tqueryOptions: CacheQueryOptions = { ignoreSearch: true }\n): Promise<boolean> {\n\tconst offlineModeCache = await promisedOfflineModeCache;\n\tconst cachedResponse = await offlineModeCache.match(url, queryOptions);\n\treturn !!cachedResponse;\n}\n\nexport function shouldCacheUrl(url: URL) {\n\tif (url.href.includes('wordpress-static.zip')) {\n\t\treturn true;\n\t}\n\t/**\n\t * The development environment uses Vite which doesn't work offline because\n\t * it dynamically generates assets. Check the README for offline development\n\t * instructions.\n\t */\n\tif (\n\t\turl.href.startsWith('http://127.0.0.1:5400/') ||\n\t\turl.href.startsWith('http://localhost:5400/') ||\n\t\turl.href.startsWith('https://playground.test/') ||\n\t\turl.pathname.startsWith('/website-server/')\n\t) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Don't cache scoped requests made to the PHP Worker Thread.\n\t * They may be static assets, but they may also be PHP files.\n\t * We can't tell by the URL, e.g. `/sitemap.xml` can be both.\n\t */\n\tif (isURLScoped(url)) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Don't cache responses generated by PHP files – they may\n\t * change on every request.\n\t */\n\tif (url.pathname.endsWith('.php')) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Allow only requests to the same hostname to be cached.\n\t */\n\treturn self.location.hostname === url.hostname;\n}\n\n/**\n * Fetches a resource and avoids stale responses from browser cache.\n *\n * @param resource The resource to fetch.\n * @param init     Optional object containing custom settings.\n * @returns Promise<Response>\n */\nfunction fetchFresh(resource: RequestInfo | URL, init?: RequestInit) {\n\treturn fetch(resource, {\n\t\t...init,\n\t\tcache: 'no-cache',\n\t});\n}\n\nexport function isCurrentServiceWorkerActive() {\n\t// @ts-ignore\n\t// Firefox doesn't support serviceWorker.state\n\tif (!('serviceWorker' in self) || !('state' in self.serviceWorker)) {\n\t\treturn true;\n\t}\n\t// @ts-ignore\n\treturn self.serviceWorker.state === 'activated';\n}\n","/// <reference lib=\"WebWorker\" />\n/**\n * Playground's service worker. Here's a rundown of non-obvious things that\n * are happening in here:\n *\n * ## Playground must be upgraded as early as possible after a new release\n *\n * New service workers call .skipWaiting(), immediately claim all the clients\n * that were controlled by the previous service worker and clears the offline\n * cache. The claimed clients are not forcibly refreshed. They just continue\n * running under the new service worker.\n *\n * Why?\n *\n * Because Playground fetches new resources asynchronously and on demand. However,\n * deploying a new webapp version of the app destroys the resources referenced in\n * the previous webapp version. Therefore, we can't allow the previous version\n * to run when a new version becomes available.\n *\n * ## Caching strategy\n *\n * Playground uses caching heavily to achieve great loading speeds and provide\n * an offline mode.\n *\n * Caching is a complex beast. Playground deals with the following cache layers:\n *\n * * HTTP cache in the browser\n * * CacheStorage in the service worker\n * * Edge Cache on playground.wordpress.net\n *\n * ### HTTP cache in the browser\n *\n * This service worker skips the browser HTTP cache for all network requests. This is because\n * the HTTP cache caused a particularly nasty problem in Playground deployments.\n *\n * Installing a new service worker purged the CacheStorage and requested a new set of assets\n * from the network. However, some of these requests were served from the HTTP cache. As a\n * result, Playground would start loading a mix of old and new assets and quickly error out.\n * What made it worse is that this broken state was cached in CacheStorage, breaking Playground\n * for weeks until the cache was refreshed.\n *\n * See https://github.com/WordPress/wordpress-playground/pull/1822 for more details.\n *\n * ### CacheStorage in the service worker\n *\n * Playground primarily relies on the **Cache first** strategy. This means assets are:\n *\n * 1. Loaded from the network without using any HTTP caching.\n * 2. Stored in the CacheStorage.\n * 3. Served from the CacheStorage on subsequent requests.\n *\n * While this strategy enables fast load times and an offline experience, it also\n * creates a substantial challenge.\n *\n * When a new Playground version is deployed, all the clients will load an old\n * version of the `remote.html` file on their next visit. Unfortunately, that old\n * `remote.html` file contains hardcoded references to assets that may not be\n * cached and no longer exist in the new webapp build.\n *\n * To solve this problem, we use the **Network first** strategy when `remote.html`\n * is requested. This introduces a small network overhead, but it guarantees loading\n * the most recent version of `remote.html` and all the referenced assets.\n *\n * Similarly, we use the **Network first** strategy for the `/` path. This is\n * useful in situations where the user didn't visit Playground in a while,\n * they have a stale version of the `/` route cached, and they open Playground.\n * If we loaded the cached version, they'd see the old Playground website on their\n * first visit and then the new Playground website only on their second visit.\n *\n * There's still a small window of time between loading the remote.html file and\n * fetching the new assets when a new deployment would break the application.\n * This should be very rare, but when it happens we provide an error message asking\n * the user to reload the page.\n *\n * ### Edge Cache on playground.wordpress.net\n *\n * The remote server (playground.wordpress.net) has an Edge Cache that's populated with\n * all static assets on every webapp deployment. All the assets served by playground.wordpress.net\n * at any point in time come from the same build and are consistent with each other. The\n * deployment process is atomic-ish so the server should never expose a mix of old and new\n * assets.\n *\n * However, what if a new webapp version is deployed right when someone downloaded 10 out of\n * 27 static assets required to boot Playground?\n *\n * Right now, they'd end up in an undefined state and likely see an error. Then, on a page refresh,\n * they'd pick up a new service worker that would purge the stale assets and boot the new webapp\n * version.\n *\n * This is not a big problem for now, but it's also not the best user experience. This can be\n * eventually solved with push notifications. A new deployment would notify all the active\n * clients to upgrade and pick up the new assets.\n *\n * ## Related resources\n *\n * * PR that turned off HTTP caching: https://github.com/WordPress/wordpress-playground/pull/1822\n * * Exploring all the cache layers: https://github.com/WordPress/wordpress-playground/issues/1774\n * * Cache first strategy: https://web.dev/articles/offline-cookbook#cache-falling-back-to-network\n * * Service worker caching and HTTP caching: https://web.dev/articles/service-worker-caching-and-http-caching\n */\n\ndeclare const self: ServiceWorkerGlobalScope;\n\nimport { getURLScope, isURLScoped, removeURLScope } from '@php-wasm/scopes';\nimport { applyRewriteRules } from '@php-wasm/universal';\nimport {\n\tawaitReply,\n\tconvertFetchEventToPHPRequest,\n\tcloneRequest,\n\tbroadcastMessageExpectReply,\n} from '@php-wasm/web-service-worker';\nimport { wordPressRewriteRules } from '@wp-playground/wordpress';\nimport { reportServiceWorkerMetrics } from '@php-wasm/logger';\n\nimport {\n\tcacheFirstFetch,\n\tnetworkFirstFetch,\n\tcacheOfflineModeAssetsForCurrentRelease,\n\tisCurrentServiceWorkerActive,\n\tpurgeEverythingFromPreviousRelease,\n\tshouldCacheUrl,\n} from './src/lib/offline-mode-cache';\n\nif (!(self as any).document) {\n\t// Workaround: vite translates import.meta.url\n\t// to document.currentScript which fails inside of\n\t// a service worker because document is undefined\n\t// @ts-ignore\n\t// eslint-disable-next-line no-global-assign\n\tself.document = {};\n}\n\n/**\n * Forces the browser to always use the latest service worker.\n *\n * Each service worker build contains a hardcoded `buildVersion` used to derive a cache key\n * for offline-mode-cache. As long as the previous service worker is used, it will\n * keep serving a stale version of Playground assets, e.g. `/index.html`, `php.wasm`, etc.\n *\n * This is problematic for two reasons:\n *\n * 1. Users won't receive critical bugfixes for up to 24 hours after they're released [1].\n * 2. Users will experience fatal crashes. Assets such as the WebAssembly PHP builds are\n *    loaded asynchronously using fetch() and import() functions. The specific URLs are\n *    hardcoded by the bundler at build time, e.g. the worker-thread.js file contains\n *    a call similar to `import(\"./assets/php_8_3-2286e20c.js\")`. If the browser uses\n *    a stale version of the worker thread, it will try to import a JavaScript file\n *    that no longer exists.\n *\n * See also: https://github.com/WordPress/wordpress-playground/issues/105\n *\n * [1] https://web.dev/articles/service-worker-lifecycle#updates\n */\nself.addEventListener('install', (event) => {\n\tevent.waitUntil(self.skipWaiting());\n});\n\n/**\n * Ensures:\n *\n * * The very first Playground load is controlled by this service worker.\n * * Other browser tabs are upgraded to the latest service worker.\n *\n * ## Initial load\n *\n * This is necessary because service workers don't control any pages loaded\n * before they are activated. This includes the page that actually registers\n * the service worker. You need to reload it before\n * `navigator.serviceWorker.controller` is set and the fetch() requests are\n * intercepted here.\n *\n * However, the initial Playground load already downloads a few large assets,\n * like a 12MB wordpress-static.zip file. We need to cache them these requests.\n * Otherwise they'll be fetched again on the next page load.\n *\n * client.claim() only affects pages loaded before the initial servie worker\n * registration. It shouldn't have unwanted side effects in our case. All these\n * pages would get controlled eventually anyway.\n *\n * See:\n * * The service worker lifecycle https://web.dev/articles/service-worker-lifecycle\n * * Clients.claim() docs https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim\n */\nself.addEventListener('activate', function (event) {\n\tasync function doActivate() {\n\t\tawait self.clients.claim();\n\n\t\tif (shouldCacheUrl(new URL(location.href))) {\n\t\t\tawait purgeEverythingFromPreviousRelease();\n\t\t\tcacheOfflineModeAssetsForCurrentRelease();\n\t\t}\n\t}\n\tevent.waitUntil(doActivate());\n});\n\nself.addEventListener('fetch', (event) => {\n\tif (!isCurrentServiceWorkerActive()) {\n\t\treturn;\n\t}\n\n\tconst url = new URL(event.request.url);\n\n\t// Don't handle requests to the service worker script itself.\n\tif (url.pathname.startsWith(self.location.pathname)) {\n\t\treturn;\n\t}\n\n\tconst isReservedUrl =\n\t\turl.pathname.startsWith('/plugin-proxy') ||\n\t\turl.pathname.startsWith('/client/index.js');\n\tif (isReservedUrl) {\n\t\treturn;\n\t}\n\n\tif (isURLScoped(url)) {\n\t\treturn event.respondWith(handleScopedRequest(event, getURLScope(url)!));\n\t}\n\n\tlet referrerUrl;\n\ttry {\n\t\treferrerUrl = new URL(event.request.referrer);\n\t} catch {\n\t\t// ignore\n\t}\n\n\tif (referrerUrl && isURLScoped(referrerUrl)) {\n\t\treturn event.respondWith(\n\t\t\thandleScopedRequest(event, getURLScope(referrerUrl)!)\n\t\t);\n\t}\n\n\t/**\n\t * A proxy that enables offline caching of cross-origin requests.\n\t *\n\t * For example, the following request fetching the list of all the Blueprints\n\t * from the Blueprints directory:\n\t *\n\t * https://playground.wordpress.net/proxy/network-first-fetch/https://raw.githubusercontent.com/WordPress/blueprints/trunk/index.json\n\t *\n\t * would be proxied to:\n\t *\n\t * https://raw.githubusercontent.com/WordPress/blueprints/trunk/index.json\n\t *\n\t * And the response would be cached for when Playground is running in the\n\t * offline mode.\n\t */\n\tif (url.pathname.startsWith('/proxy/')) {\n\t\tconst segments = url.pathname.split('/');\n\t\tconst command = segments[2];\n\t\tswitch (command) {\n\t\t\tcase 'network-first-fetch': {\n\t\t\t\tconst proxiedUrl =\n\t\t\t\t\turl.pathname.substring(\n\t\t\t\t\t\t'/proxy/'.length + command.length + 1\n\t\t\t\t\t) +\n\t\t\t\t\t(url?.search ? '?' + url.search : '') +\n\t\t\t\t\t(url?.hash ? '#' + url.hash : '');\n\t\t\t\tconst requestWithTargetUrl = cloneRequest(event.request, {\n\t\t\t\t\turl: proxiedUrl,\n\t\t\t\t});\n\t\t\t\treturn event.respondWith(\n\t\t\t\t\trequestWithTargetUrl.then(networkFirstFetch)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!shouldCacheUrl(new URL(event.request.url))) {\n\t\t/**\n\t\t * It's safe to use the regular `fetch` function here.\n\t\t *\n\t\t * This request won't be cached in the offline mode cache\n\t\t * and there's no risk of the two caches interfering with\n\t\t * each other.\n\t\t *\n\t\t * See service-worker.ts for more details.\n\t\t */\n\t\treturn;\n\t}\n\n\t/**\n\t * Always fetch the fresh version of `/remote.html` and `/` from the network.\n\t *\n\t * This is the secret sauce that enables seamless upgrades of the\n\t * running Playground clients when a new version is deployed on\n\t * the server.\n\t *\n\t * ## The problem with deployments\n\t *\n\t * App deployments remove all the static assets associated with the\n\t * previous app version. Meanwhile, the remote.html file we've cached\n\t * for offline usage still holds references to those assets.\n\t *\n\t * If we just loaded the cached remote.html file, the site would crash\n\t * with seemingly random errors.\n\t *\n\t * Instead, we fetch the most recent version of remote.html from the network.\n\t * It references the static assets that are now available on the server and\n\t * should work just fine.\n\t *\n\t * Relatedly, loading the `/` path using the network first strategy ensures\n\t * that the user sees the latest version of the webapp even if they aleady\n\t * have the previous version cached in CacheStorage.\n\t *\n\t * This very simple resolution took multiple iterations to get right. See\n\t * https://github.com/WordPress/wordpress-playground/issues/1821 for more\n\t * details.\n\t */\n\tif (url.pathname === '/remote.html' || url.pathname === '/') {\n\t\tevent.respondWith(networkFirstFetch(event.request));\n\t\treturn;\n\t}\n\n\t// Use cache first strategy to serve regular static assets.\n\treturn event.respondWith(cacheFirstFetch(event.request));\n});\n\n/**\n * A request to a PHP Worker Thread or to a regular static asset,\n * but initiated by a scoped referer (e.g. fetch() from a block editor iframe).\n */\nasync function handleScopedRequest(event: FetchEvent, scope: string) {\n\tconst fullUrl = new URL(event.request.url);\n\tconst unscopedUrl = removeURLScope(fullUrl);\n\tif (fullUrl.pathname.endsWith('/wp-includes/empty.html')) {\n\t\treturn emptyHtml();\n\t}\n\n\tconst workerResponse = await convertFetchEventToPHPRequest(event);\n\n\tif (\n\t\tworkerResponse.status === 404 &&\n\t\tworkerResponse.headers.get('x-backfill-from') === 'remote-host'\n\t) {\n\t\tconst { staticAssetsDirectory } = await getScopedWpDetails(scope!);\n\t\tif (!staticAssetsDirectory) {\n\t\t\tconst plain404Response = workerResponse.clone();\n\t\t\tplain404Response.headers.delete('x-backfill-from');\n\t\t\treturn plain404Response;\n\t\t}\n\n\t\t// If we get a 404 for a static file, try to fetch it from\n\t\t// the from the static assets directory at the remote server.\n\t\tconst requestedUrl = new URL(event.request.url);\n\t\tconst resolvedUrl = removeURLScope(requestedUrl);\n\t\tresolvedUrl.pathname = applyRewriteRules(\n\t\t\tresolvedUrl.pathname,\n\t\t\twordPressRewriteRules\n\t\t);\n\t\tif (\n\t\t\t// Vite dev server requests\n\t\t\t!resolvedUrl.pathname.startsWith('/@fs') &&\n\t\t\t!resolvedUrl.pathname.startsWith('/assets')\n\t\t) {\n\t\t\tresolvedUrl.pathname = `/${staticAssetsDirectory}${resolvedUrl.pathname}`;\n\t\t}\n\t\tconst request = await cloneRequest(event.request, {\n\t\t\turl: resolvedUrl,\n\t\t\t// Omit credentials to avoid causing cache aborts due to presence of\n\t\t\t// cookies\n\t\t\tcredentials: 'omit',\n\t\t});\n\n\t\t/**\n\t\t * Intentionally use fetch() over fetchFresh().\n\t\t *\n\t\t * At this point we know this request very likely came from WordPress\n\t\t * and is looking for a WordPress-related static asset. WordPress\n\t\t * has its own caching strategies in place. We're going to pass this\n\t\t * request to the remote server as it is and let WordPress manage its\n\t\t * own HTTP caching.\n\t\t */\n\t\treturn fetch(request).catch((e) => {\n\t\t\tif (e?.name === 'TypeError') {\n\t\t\t\t// This could be an ERR_HTTP2_PROTOCOL_ERROR that sometimes\n\t\t\t\t// happen on playground.wordpress.net. Let's add a randomized\n\t\t\t\t// delay and retry once\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\tsetTimeout(\n\t\t\t\t\t\t() => resolve(fetch(request)),\n\t\t\t\t\t\tMath.random() * 1500\n\t\t\t\t\t);\n\t\t\t\t}) as Promise<Response>;\n\t\t\t}\n\n\t\t\t// Otherwise let's just re-throw the error\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\t// Path the block-editor.js file to ensure the site editor's iframe\n\t// inherits the service worker.\n\t// @see controlledIframe below for more details.\n\tif (\n\t\t// WordPress Core version of block-editor.js\n\t\tunscopedUrl.pathname.endsWith('/block-editor.js') ||\n\t\tunscopedUrl.pathname.endsWith('/block-editor.min.js') ||\n\t\t// Gutenberg version of block-editor.js\n\t\tunscopedUrl.pathname.endsWith('/block-editor/index.js') ||\n\t\tunscopedUrl.pathname.endsWith('/block-editor/index.min.js')\n\t) {\n\t\tconst script = await workerResponse.text();\n\t\tconst newScript = `${controlledIframe} ${script.replace(\n\t\t\t/\\(\\s*\"iframe\",/,\n\t\t\t'(__playground_ControlledIframe,'\n\t\t)}`;\n\t\treturn new Response(newScript, {\n\t\t\tstatus: workerResponse.status,\n\t\t\tstatusText: workerResponse.statusText,\n\t\t\theaders: workerResponse.headers,\n\t\t});\n\t}\n\n\treturn workerResponse;\n}\n\nreportServiceWorkerMetrics(self);\n\n/**\n * Pair the site editor's nested iframe to the Service Worker.\n *\n * Without the patch below, the site editor initiates network requests that\n * aren't routed through the service worker. That's a known browser issue:\n *\n * * https://bugs.chromium.org/p/chromium/issues/detail?id=880768\n * * https://bugzilla.mozilla.org/show_bug.cgi?id=1293277\n * * https://github.com/w3c/ServiceWorker/issues/765\n *\n * The problem with iframes using srcDoc and src=\"about:blank\" as they\n * fail to inherit the root site's service worker.\n *\n * Gutenberg loads the site editor using <iframe srcDoc=\"<!doctype html\">\n * to force the standards mode and not the quirks mode:\n *\n * https://github.com/WordPress/gutenberg/pull/38855\n *\n * This commit patches the site editor to achieve the same result via\n * <iframe src=\"/doctype.html\"> and a doctype.html file containing just\n * `<!doctype html>`. This allows the iframe to inherit the service worker\n * and correctly load all the css, js, fonts, images, and other assets.\n *\n * Ideally this issue would be fixed directly in Gutenberg and the patch\n * below would be removed.\n *\n * See https://github.com/WordPress/wordpress-playground/issues/42 for more details\n *\n * ## Why does this code live in the service worker?\n *\n * There's many ways to install the Gutenberg plugin:\n *\n * * Install plugin step\n * * Import a site\n * * Install Gutenberg from the plugin directory\n * * Upload a Gutenberg zip\n *\n * It's too difficult to patch Gutenberg in all these cases, so we\n * blanket-patch all the scripts requested over the network whose names seem to\n * indicate they're related to the Gutenberg plugin.\n */\nconst controlledIframe = `\nwindow.__playground_ControlledIframe = window.wp.element.forwardRef(function (props, ref) {\n\tconst source = window.wp.element.useMemo(function () {\n\t\t/**\n\t\t * A synchronous function to read a blob URL as text.\n\t\t *\n\t\t * @param {string} url\n\t\t * @returns {string}\n\t\t */\n\t\tconst __playground_readBlobAsText = function (url) {\n\t\t\ttry {\n\t\t\t\tlet xhr = new XMLHttpRequest();\n\t\t\t\txhr.open('GET', url, false);\n\t\t\t\txhr.overrideMimeType('text/plain;charset=utf-8');\n\t\t\t\txhr.send();\n\t\t\t\treturn xhr.responseText;\n\t\t\t} catch(e) {\n\t\t\t\treturn '';\n\t\t\t} finally {\n\t\t\t\tURL.revokeObjectURL(url);\n\t\t\t}\n\t\t};\n\t\tif (props.srcDoc) {\n\t\t\t// WordPress <= 6.2 uses a srcDoc that only contains a doctype.\n\t\t\treturn '/wp-includes/empty.html';\n\t\t} else if (props.src && props.src.startsWith('blob:')) {\n\t\t\t// WordPress 6.3 uses a blob URL with doctype and a list of static assets.\n\t\t\t// Let's pass the document content to empty.html and render it there.\n\t\t\treturn '/wp-includes/empty.html#' + encodeURIComponent(__playground_readBlobAsText(props.src));\n\t\t} else {\n\t\t\t// WordPress >= 6.4 uses a plain HTTPS URL that needs no correction.\n\t\t\treturn props.src;\n\t\t}\n\t}, [props.src]);\n\treturn (\n\t\twindow.wp.element.createElement('iframe', {\n\t\t\t...props,\n\t\t\tref: ref,\n\t\t\tsrc: source,\n\t\t\t// Make sure there's no srcDoc, as it would interfere with the src.\n\t\t\tsrcDoc: undefined\n\t\t})\n\t)\n});`;\n\n/**\n * The empty HTML file loaded by the patched editor iframe.\n */\nfunction emptyHtml() {\n\treturn new Response(\n\t\t'<!doctype html><script>const hash = window.location.hash.substring(1); if ( hash ) document.write(decodeURIComponent(hash))</script>',\n\t\t{\n\t\t\tstatus: 200,\n\t\t\theaders: {\n\t\t\t\t'content-type': 'text/html',\n\t\t\t},\n\t\t}\n\t);\n}\n\ntype WPModuleDetails = {\n\tstaticAssetsDirectory?: string;\n};\n\nconst scopeToWpModule: Record<string, WPModuleDetails> = {};\nasync function getScopedWpDetails(scope: string): Promise<WPModuleDetails> {\n\tif (!scopeToWpModule[scope]) {\n\t\tconst requestId = await broadcastMessageExpectReply(\n\t\t\t{\n\t\t\t\tmethod: 'getWordPressModuleDetails',\n\t\t\t},\n\t\t\tscope\n\t\t);\n\t\tscopeToWpModule[scope] = await awaitReply(self, requestId);\n\t}\n\treturn scopeToWpModule[scope];\n}\n"],"names":["isURLScoped","url","getURLScope","setURLScope","scope","newUrl","parts","removeURLScope","suffix","currentJsRuntime","asPromise","obj","resolve","reject","event","isByobSupported","inputBytes","stream","File","sources","fileName","options","date","reader","position","blob","controller","view","buffer","uint8array","bytesRead","CustomEvent","name","logEventType","logEvent","log","args","logger","logToConsole","prepareLogMessage","LogSeverity","logMessage","logs","addToLogArray","message","logToMemory","formatLogEntry","LogPrefix","Logger","handlers","logWithSeverity","handler","severity","getDefaultHandlers","prefix","formattedDate","formattedTime","now","reportServiceWorkerMetrics","worker","clients","metrics","c","client","SleepFinished","sleep","ms","AcquireTimeoutError","Semaphore","concurrency","timeout","acquired","value","released","fn","release","done","applyRewriteRules","path","rules","rule","proxyMarker","createEndpoint","releaseProxy","finalizer","throwMarker","WireValueType","MessageType","isObject","val","proxyTransferHandler","port1","port2","expose","port","wrap","throwTransferHandler","serialized","transferHandlers","isAllowedOrigin","allowedOrigins","origin","allowedOrigin","ep","afterResponseSent","callback","ev","id","type","argumentList","fromWireValue","returnValue","parent","prop","rawValue","proxy","transfer","wireValue","transferables","toWireValue","closeEndPoint","isMessagePort","endpoint","target","pendingListeners","data","resolver","createProxy","throwIfProxyReleased","isReleased","releaseEndpoint","requestResponseMessage","proxyCounter","proxyFinalizers","newCount","registerProxy","unregisterProxy","isProxyReleased","_target","r","p","_thisArg","rawArgumentList","last","processArguments","myFlat","arr","processed","v","transferCache","transfers","serializedValue","msg","generateUUID","list","constructor","errorConstructors","NonError","errorProperties","toJsonWasCalled","toJSON","from","json","newError","ErrorConstructor","destroyCircular","seen","to","forceEnumerable","maxDepth","depth","useToJSON","serialize","isErrorLike","continueDestroyCircular","key","property","enumerable","serializeError","deserializeError","isMinimumViableSerializedError","Comlink.transferHandlers","throwTransferHandlerCustom","ErrorSerializer.serializeError","error","ErrorSerializer.deserializeError","additionalCallStack","deepestError","DEFAULT_RESPONSE_TIMEOUT","lastRequestId","getNextRequestId","awaitReply","messageTarget","requestId","responseHandler","failOntimeout","convertFetchEventToPHPRequest","referrerUrl","contentType","body","requestHeaders","pair","phpResponse","broadcastMessageExpectReply","e","responseBody","cloneRequest","request","overrides","wordPressRewriteRules","CACHE_NAME_PREFIX","LATEST_CACHE_NAME","buildVersion","promisedOfflineModeCache","cacheFirstFetch","offlineModeCache","cachedResponse","response","fetchFresh","isCurrentServiceWorkerActive","networkFirstFetch","cacheOfflineModeAssetsForCurrentRelease","websiteRequests","purgeEverythingFromPreviousRelease","oldKeys","shouldCacheUrl","resource","init","doActivate","handleScopedRequest","command","proxiedUrl","requestWithTargetUrl","fullUrl","unscopedUrl","emptyHtml","workerResponse","staticAssetsDirectory","getScopedWpDetails","plain404Response","requestedUrl","resolvedUrl","script","newScript","controlledIframe","scopeToWpModule"],"mappings":"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"}
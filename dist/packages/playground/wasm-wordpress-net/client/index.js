const yp = function() {
  var e;
  return typeof process < "u" && ((e = process.release) == null ? void 0 : e.name) === "node" ? "NODE" : typeof window < "u" ? "WEB" : (
    // @ts-ignore
    typeof WorkerGlobalScope < "u" && // @ts-ignore
    self instanceof WorkerGlobalScope ? "WORKER" : "NODE"
  );
}();
if (yp === "NODE") {
  let e = function(r) {
    return new Promise(function(i, a) {
      r.onload = r.onerror = function(s) {
        r.onload = r.onerror = null, s.type === "load" ? i(r.result) : a(new Error("Failed to read the blob/file"));
      };
    });
  }, t = function() {
    const r = new Uint8Array([1, 2, 3, 4]), a = new File([r], "test").stream();
    try {
      return a.getReader({ mode: "byob" }), !0;
    } catch {
      return !1;
    }
  };
  if (typeof File > "u") {
    class r extends Blob {
      constructor(a, s, n) {
        super(a);
        let o;
        n != null && n.lastModified && (o = /* @__PURE__ */ new Date()), (!o || isNaN(o.getFullYear())) && (o = /* @__PURE__ */ new Date()), this.lastModifiedDate = o, this.lastModified = o.getMilliseconds(), this.name = s || "";
      }
    }
    global.File = r;
  }
  typeof Blob.prototype.arrayBuffer > "u" && (Blob.prototype.arrayBuffer = function() {
    const i = new FileReader();
    return i.readAsArrayBuffer(this), e(i);
  }), typeof Blob.prototype.text > "u" && (Blob.prototype.text = function() {
    const i = new FileReader();
    return i.readAsText(this), e(i);
  }), (typeof Blob.prototype.stream > "u" || !t()) && (Blob.prototype.stream = function() {
    let r = 0;
    const i = this;
    return new ReadableStream({
      type: "bytes",
      // 0.5 MB seems like a reasonable chunk size, let's adjust
      // this if needed.
      autoAllocateChunkSize: 512 * 1024,
      async pull(a) {
        const s = a.byobRequest.view, o = await i.slice(
          r,
          r + s.byteLength
        ).arrayBuffer(), l = new Uint8Array(o);
        new Uint8Array(s.buffer).set(l);
        const p = l.byteLength;
        a.byobRequest.respond(p), r += p, r >= i.size && a.close();
      }
    });
  });
}
if (yp === "NODE" && typeof CustomEvent > "u") {
  class e extends Event {
    constructor(r, i = {}) {
      super(r, i), this.detail = i.detail;
    }
    initCustomEvent() {
    }
  }
  globalThis.CustomEvent = e;
}
function _p(e) {
  return e && "read" in e && typeof e.read == "function";
}
async function id(e) {
  if (!_p(e))
    return e;
  const r = await (await e.read("blueprint.json")).text();
  return JSON.parse(r);
}
class Rn {
  static async create(t) {
    const r = await id(t), i = _p(t) ? t : void 0;
    return Rn.createFromDeclaration(r, i);
  }
  static createFromDeclaration(t, r = void 0) {
    return new Rn(
      t,
      r,
      t.version || 1
    );
  }
  constructor(t, r, i) {
    this.declaration = t, this.bundle = r, this.version = i;
  }
  getVersion() {
    return this.version;
  }
  getDeclaration() {
    return this.declaration;
  }
  isBundle() {
    return this.bundle !== void 0;
  }
  getBundle() {
    return this.bundle;
  }
  getBlueprint() {
    return this.getBundle() || this.getDeclaration();
  }
}
const ad = "playground-log", Io = (e, ...t) => {
  Te.dispatchEvent(
    new CustomEvent(ad, {
      detail: {
        log: e,
        args: t
      }
    })
  );
}, od = (e, ...t) => {
  switch (typeof e.message == "string" ? Reflect.set(e, "message", Oa(e.message)) : e.message.message && typeof e.message.message == "string" && Reflect.set(
    e.message,
    "message",
    Oa(e.message.message)
  ), e.severity) {
    case ut.Debug:
      console.debug(e.message, ...t);
      break;
    case ut.Info:
      console.info(e.message, ...t);
      break;
    case ut.Warn:
      console.warn(e.message, ...t);
      break;
    case ut.Error:
      console.error(e.message, ...t);
      break;
    case ut.Fatal:
      console.error(e.message, ...t);
      break;
    default:
      console.log(e.message, ...t);
  }
}, ld = (e) => e instanceof Error ? [e.message, e.stack].join(`
`) : JSON.stringify(e, null, 2), gp = [], Do = (e) => {
  gp.push(e);
}, Ta = (e) => {
  if (e.raw === !0)
    Do(e.message);
  else {
    const t = ud(
      typeof e.message == "object" ? ld(e.message) : e.message,
      e.severity,
      e.prefix ?? _r.JS
    );
    Do(t);
  }
};
let bi = 0;
const Ho = "/wordpress/wp-content/debug.log", fd = async (e) => await e.fileExists(Ho) ? await e.readFileAsText(Ho) : "", wp = (e, t) => {
  t.addEventListener("request.end", async () => {
    const r = await fd(t);
    if (r.length > bi) {
      const i = r.substring(bi);
      e.logMessage({
        message: i,
        severity: ut.Log,
        raw: !0
      }), bi = r.length;
    }
  }), t.addEventListener("request.error", (r) => {
    r = r, r.error && (e.logMessage({
      message: `${r.error.message} ${r.error.stack}`,
      severity: ut.Fatal,
      prefix: r.source === "request" ? _r.PHP : _r.WASM
    }), e.dispatchEvent(
      new CustomEvent(e.fatalErrorEvent, {
        detail: {
          logs: e.getLogs(),
          source: r.source
        }
      })
    ));
  });
}, ut = {
  Fatal: { name: "fatal", level: 0 },
  Error: { name: "error", level: 1 },
  Warn: { name: "warn", level: 2 },
  Log: { name: "log", level: 3 },
  Info: { name: "info", level: 4 },
  Debug: { name: "debug", level: 5 }
}, _r = {
  WASM: "Wasm Crash",
  PHP: "PHP",
  JS: "JavaScript"
};
class pd extends EventTarget {
  // constructor
  constructor(t = []) {
    super(), this.fatalErrorEvent = "playground-fatal-error", this.severity = ut.Info, this.handlers = t;
  }
  /**
   * Get all logs.
   * @returns string[]
   */
  getLogs() {
    return this.handlers.includes(Ta) ? [...gp] : (this.error(`Logs aren't stored because the logToMemory handler isn't registered.
				If you're using a custom logger instance, make sure to register logToMemory handler.
			`), []);
  }
  /**
   * Log message with severity.
   *
   * @param log Log
   * @param args any
   */
  logMessage(t, ...r) {
    const i = {
      ...t,
      severity: t.severity ?? ut.Log
    };
    for (const a of this.handlers)
      i.severity.level <= this.severity.level && a(i, ...r);
  }
  /**
   * Filter message based on severity
   * @param severity LogSeverity
   */
  setSeverityFilterLevel(t) {
    this.severity = t;
  }
  /**
   * Log message
   *
   * @param message any
   * @param args any
   */
  log(t, ...r) {
    this.logMessage(
      {
        message: t,
        severity: ut.Log,
        prefix: _r.JS,
        raw: !1
      },
      ...r
    );
  }
  /**
   * Log debug message
   *
   * @param message any
   * @param args any
   */
  debug(t, ...r) {
    this.logMessage(
      {
        message: t,
        severity: ut.Debug,
        prefix: _r.JS,
        raw: !1
      },
      ...r
    );
  }
  /**
   * Log info message
   *
   * @param message any
   * @param args any
   */
  info(t, ...r) {
    this.logMessage(
      {
        message: t,
        severity: ut.Info,
        prefix: _r.JS,
        raw: !1
      },
      ...r
    );
  }
  /**
   * Log warning message
   *
   * @param message any
   * @param args any
   */
  warn(t, ...r) {
    this.logMessage(
      {
        message: t,
        severity: ut.Warn,
        prefix: _r.JS,
        raw: !1
      },
      ...r
    );
  }
  /**
   * Log error message
   *
   * @param message any
   * @param args any
   */
  error(t, ...r) {
    this.logMessage(
      {
        message: t,
        severity: ut.Error,
        prefix: _r.JS,
        raw: !1
      },
      ...r
    );
  }
}
const cd = () => {
  try {
    if (process.env.NODE_ENV === "test")
      return [Ta, Io];
  } catch {
  }
  return [Ta, od, Io];
}, Te = new pd(cd()), Oa = (e) => e.replace(/\t/g, ""), ud = (e, t, r) => {
  const i = /* @__PURE__ */ new Date(), a = new Intl.DateTimeFormat("en-GB", {
    year: "numeric",
    month: "short",
    day: "2-digit",
    timeZone: "UTC"
  }).format(i).replace(/ /g, "-"), s = new Intl.DateTimeFormat("en-GB", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: !1,
    timeZone: "UTC",
    timeZoneName: "short"
  }).format(i), n = a + " " + s;
  return e = Oa(e), `[${n}] ${r} ${t.name}: ${e}`;
}, dd = 5 * 1024 * 1024;
function hd(e, t) {
  const r = e.headers.get("content-length") || "", i = parseInt(r, 10) || dd;
  return new Response(
    bp(e.body, i, t),
    {
      status: e.status,
      statusText: e.statusText,
      headers: e.headers
    }
  );
}
function bp(e, t, r) {
  function i(a, s) {
    r(
      new CustomEvent("progress", {
        detail: {
          loaded: a,
          total: s
        }
      })
    );
  }
  return new ReadableStream({
    async start(a) {
      if (!e) {
        a.close();
        return;
      }
      const s = e.getReader();
      let n = 0;
      for (; ; )
        try {
          const { done: o, value: l } = await s.read();
          if (l && (n += l.byteLength), o) {
            i(n, n), a.close();
            break;
          } else
            i(n, t), a.enqueue(l);
        } catch (o) {
          Te.error({ e: o }), a.error(o);
          break;
        }
    }
  });
}
const vi = 1e-5;
class si extends EventTarget {
  constructor({
    weight: t = 1,
    caption: r = "",
    fillTime: i = 4
  } = {}) {
    super(), this._selfWeight = 1, this._selfDone = !1, this._selfProgress = 0, this._selfCaption = "", this._isFilling = !1, this._subTrackers = [], this._weight = t, this._selfCaption = r, this._fillTime = i;
  }
  /**
   * Creates a new sub-tracker with a specific weight.
   *
   * The weight determines what percentage of the overall progress
   * the sub-tracker represents. For example, if the main tracker is
   * monitoring a process that has two stages, and the first stage
   * is expected to take twice as long as the second stage, you could
   * create the first sub-tracker with a weight of 0.67 and the second
   * sub-tracker with a weight of 0.33.
   *
   * The caption is an optional string that describes the current stage
   * of the operation. If provided, it will be used as the progress caption
   * for the sub-tracker. If not provided, the main tracker will look for
   * the next sub-tracker with a non-empty caption and use that as the progress
   * caption instead.
   *
   * Returns the newly-created sub-tracker.
   *
   * @throws {Error} If the weight of the new stage would cause the total weight of all stages to exceed 1.
   *
   * @param weight The weight of the new stage, as a decimal value between 0 and 1.
   * @param caption The caption for the new stage, which will be used as the progress caption for the sub-tracker.
   *
   * @example
   * ```ts
   * const tracker = new ProgressTracker();
   * const subTracker1 = tracker.stage(0.67, 'Slow stage');
   * const subTracker2 = tracker.stage(0.33, 'Fast stage');
   *
   * subTracker2.set(50);
   * subTracker1.set(75);
   * subTracker2.set(100);
   * subTracker1.set(100);
   * ```
   */
  stage(t, r = "") {
    if (t || (t = this._selfWeight), this._selfWeight - t < -vi)
      throw new Error(
        `Cannot add a stage with weight ${t} as the total weight of registered stages would exceed 1.`
      );
    this._selfWeight -= t;
    const i = new si({
      caption: r,
      weight: t,
      fillTime: this._fillTime
    });
    return this._subTrackers.push(i), i.addEventListener("progress", () => this.notifyProgress()), i.addEventListener("done", () => {
      this.done && this.notifyDone();
    }), i;
  }
  /**
   * Fills the progress bar slowly over time, simulating progress.
   *
   * The progress bar is filled in a 100 steps, and each step, the progress
   * is increased by 1. If `stopBeforeFinishing` is true, the progress bar
   * will stop filling when it reaches 99% so that you can call `finish()`
   * explicitly.
   *
   * If the progress bar is filling or already filled, this method does nothing.
   *
   * @example
   * ```ts
   * const progress = new ProgressTracker({ caption: 'Processing...' });
   * progress.fillSlowly();
   * ```
   *
   * @param options Optional options.
   */
  fillSlowly({ stopBeforeFinishing: t = !0 } = {}) {
    if (this._isFilling)
      return;
    this._isFilling = !0;
    const i = this._fillTime / 100;
    this._fillInterval = setInterval(() => {
      this.set(this._selfProgress + 1), t && this._selfProgress >= 99 && clearInterval(this._fillInterval);
    }, i);
  }
  set(t) {
    this._selfProgress = Math.min(t, 100), this.notifyProgress(), this._selfProgress + vi >= 100 && this.finish();
  }
  finish() {
    this._fillInterval && clearInterval(this._fillInterval), this._selfDone = !0, this._selfProgress = 100, this._isFilling = !1, this._fillInterval = void 0, this.notifyProgress(), this.notifyDone();
  }
  get caption() {
    for (let t = this._subTrackers.length - 1; t >= 0; t--)
      if (!this._subTrackers[t].done) {
        const r = this._subTrackers[t].caption;
        if (r)
          return r;
      }
    return this._selfCaption;
  }
  setCaption(t) {
    this._selfCaption = t, this.notifyProgress();
  }
  get done() {
    return this.progress + vi >= 100;
  }
  get progress() {
    if (this._selfDone)
      return 100;
    const t = this._subTrackers.reduce(
      (r, i) => r + i.progress * i.weight,
      this._selfProgress * this._selfWeight
    );
    return Math.round(t * 1e4) / 1e4;
  }
  get weight() {
    return this._weight;
  }
  get observer() {
    return this._progressObserver || (this._progressObserver = (t) => {
      this.set(t);
    }), this._progressObserver;
  }
  get loadingListener() {
    return this._loadingListener || (this._loadingListener = (t) => {
      this.set(t.detail.loaded / t.detail.total * 100);
    }), this._loadingListener;
  }
  pipe(t) {
    t.setProgress({
      progress: this.progress,
      caption: this.caption
    }), this.addEventListener("progress", (r) => {
      t.setProgress({
        progress: r.detail.progress,
        caption: r.detail.caption
      });
    }), this.addEventListener("done", () => {
      t.setLoaded();
    });
  }
  addEventListener(t, r) {
    super.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    super.removeEventListener(t, r);
  }
  notifyProgress() {
    const t = this;
    this.dispatchEvent(
      new CustomEvent("progress", {
        detail: {
          get progress() {
            return t.progress;
          },
          get caption() {
            return t.caption;
          }
        }
      })
    );
  }
  notifyDone() {
    this.dispatchEvent(new CustomEvent("done"));
  }
}
const vp = Symbol("SleepFinished");
function md(e) {
  return new Promise((t) => {
    setTimeout(() => t(vp), e);
  });
}
class yd extends Error {
  constructor() {
    super("Acquiring lock timed out");
  }
}
class cn {
  constructor({ concurrency: t, timeout: r }) {
    this._running = 0, this.concurrency = t, this.timeout = r, this.queue = [];
  }
  get remaining() {
    return this.concurrency - this.running;
  }
  get running() {
    return this._running;
  }
  async acquire() {
    for (; ; )
      if (this._running >= this.concurrency) {
        const t = new Promise((r) => {
          this.queue.push(r);
        });
        this.timeout !== void 0 ? await Promise.race([t, md(this.timeout)]).then(
          (r) => {
            if (r === vp)
              throw new yd();
          }
        ) : await t;
      } else {
        this._running++;
        let t = !1;
        return () => {
          t || (t = !0, this._running--, this.queue.length > 0 && this.queue.shift()());
        };
      }
  }
  async run(t) {
    const r = await this.acquire();
    try {
      return await t();
    } finally {
      r();
    }
  }
}
function Ae(...e) {
  function t(s) {
    return s.substring(s.length - 1) === "/";
  }
  let r = e.join("/");
  const i = r[0] === "/", a = t(r);
  return r = ii(r), !r && !i && (r = "."), r && a && !t(r) && (r += "/"), r;
}
function Ca(e) {
  if (e === "/")
    return "/";
  e = ii(e);
  const t = e.lastIndexOf("/");
  return t === -1 ? "" : t === 0 ? "/" : e.substr(0, t);
}
function ii(e) {
  const t = e[0] === "/";
  return e = _d(
    e.split("/").filter((r) => !!r),
    !t
  ).join("/"), (t ? "/" : "") + e.replace(/\/$/, "");
}
function _d(e, t) {
  let r = 0;
  for (let i = e.length - 1; i >= 0; i--) {
    const a = e[i];
    a === "." ? e.splice(i, 1) : a === ".." ? (e.splice(i, 1), r++) : r && (e.splice(i, 1), r--);
  }
  if (t)
    for (; r; r--)
      e.unshift("..");
  return e;
}
function gd(e = 36, t = "!@#$%^&*()_+=-[]/.,<>?") {
  const r = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" + t;
  let i = "";
  for (let a = e; a > 0; --a)
    i += r[Math.floor(Math.random() * r.length)];
  return i;
}
function js() {
  return gd(36, "-_");
}
function xt(e) {
  return `json_decode(base64_decode('${wd(
    JSON.stringify(e)
  )}'), true)`;
}
function ai(e) {
  const t = {};
  for (const r in e)
    t[r] = xt(e[r]);
  return t;
}
function wd(e) {
  return bd(new TextEncoder().encode(e));
}
function bd(e) {
  const t = String.fromCodePoint(...e);
  return btoa(t);
}
function vd(e) {
  let t = 0;
  e.forEach((a) => t += a.length);
  const r = new Uint8Array(t);
  let i = 0;
  return e.forEach((a) => {
    r.set(a, i), i += a.length;
  }), r;
}
(function() {
  var e;
  return typeof process < "u" && ((e = process.release) == null ? void 0 : e.name) === "node" ? "NODE" : typeof window < "u" ? "WEB" : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? "WORKER" : "NODE";
})();
const xd = {
  500: "Internal Server Error",
  502: "Bad Gateway",
  404: "Not Found",
  403: "Forbidden",
  401: "Unauthorized",
  400: "Bad Request",
  301: "Moved Permanently",
  302: "Found",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  204: "No Content",
  201: "Created",
  200: "OK"
};
class xi {
  constructor(t, r, i, a) {
    this.parsedHeaders = null, this.cachedStdoutBytes = null, this.cachedStderrText = null, this.headersStream = t, this.stdout = r, this.stderr = i, this.exitCode = a;
  }
  /**
   * True if the response is successful (HTTP status code 200-399),
   * false otherwise.
   */
  async ok() {
    try {
      const t = await this.httpStatusCode;
      return t >= 200 && t < 400;
    } catch {
      return !1;
    }
  }
  /**
   * Resolves when the response has finished processing â€“ either successfully or not.
   */
  get finished() {
    return Promise.allSettled([this.exitCode.finally(() => {
    })]).then(
      () => {
      }
    );
  }
  /**
   * Resolves once HTTP headers are available.
   */
  get headers() {
    return this.getParsedHeaders().then((t) => t.headers);
  }
  /**
   * Resolves once HTTP status code is available.
   */
  get httpStatusCode() {
    return this.getParsedHeaders().then((t) => t.httpStatusCode).then((t) => t !== void 0 ? t : this.getParsedHeaders().then(
      (r) => r.httpStatusCode,
      () => 200
    )).catch(() => 500);
  }
  /**
   * Exposes the stdout bytes as they're produced by the PHP instance
   */
  get stdoutText() {
    return this.stdoutBytes.then(
      (t) => new TextDecoder().decode(t)
    );
  }
  /**
   * Exposes the stdout bytes as they're produced by the PHP instance
   */
  get stdoutBytes() {
    return this.cachedStdoutBytes || (this.cachedStdoutBytes = Ed(this.stdout)), this.cachedStdoutBytes;
  }
  /**
   * Exposes the stderr bytes as they're produced by the PHP instance
   */
  get stderrText() {
    return this.cachedStderrText || (this.cachedStderrText = xp(this.stderr)), this.cachedStderrText;
  }
  async getParsedHeaders() {
    return this.parsedHeaders || (this.parsedHeaders = Sd(this.headersStream)), await this.parsedHeaders;
  }
}
async function Sd(e) {
  const t = await xp(e);
  let r;
  try {
    r = JSON.parse(t);
  } catch {
    return { headers: {}, httpStatusCode: 200 };
  }
  const i = {};
  for (const a of r.headers) {
    if (!a.includes(": "))
      continue;
    const s = a.indexOf(": "), n = a.substring(0, s).toLowerCase(), o = a.substring(s + 2);
    n in i || (i[n] = []), i[n].push(o);
  }
  return {
    headers: i,
    httpStatusCode: r.status
  };
}
async function xp(e) {
  const t = e.pipeThrough(new TextDecoderStream()).getReader(), r = [];
  for (; ; ) {
    const { done: i, value: a } = await t.read();
    if (i)
      return r.join("");
    a && r.push(a);
  }
}
async function Ed(e) {
  const t = e.getReader(), r = [];
  for (; ; ) {
    const { done: i, value: a } = await t.read();
    if (i) {
      const s = r.reduce(
        (l, p) => l + p.byteLength,
        0
      ), n = new Uint8Array(s);
      let o = 0;
      for (const l of r)
        n.set(l, o), o += l.byteLength;
      return n;
    }
    a && r.push(a);
  }
}
class kn {
  constructor(t, r, i, a = "", s = 0) {
    this.httpStatusCode = t, this.headers = r, this.bytes = i, this.exitCode = s, this.errors = a;
  }
  static forHttpCode(t, r = "") {
    return new kn(
      t,
      {},
      new TextEncoder().encode(
        r || xd[t] || ""
      )
    );
  }
  static fromRawData(t) {
    return new kn(
      t.httpStatusCode,
      t.headers,
      t.bytes,
      t.errors,
      t.exitCode
    );
  }
  static async fromStreamedResponse(t) {
    return await t.finished, new kn(
      await t.httpStatusCode,
      await t.headers,
      await t.stdoutBytes,
      await t.stderrText,
      await t.exitCode
    );
  }
  /**
   * True if the response is successful (HTTP status code 200-399),
   * false otherwise.
   */
  ok() {
    return this.httpStatusCode >= 200 && this.httpStatusCode < 400;
  }
  toRawData() {
    return {
      headers: this.headers,
      bytes: this.bytes,
      errors: this.errors,
      exitCode: this.exitCode,
      httpStatusCode: this.httpStatusCode
    };
  }
  /**
   * Response body as JSON.
   */
  get json() {
    return JSON.parse(this.text);
  }
  /**
   * Response body as text.
   */
  get text() {
    return new TextDecoder().decode(this.bytes);
  }
}
const Fo = "/internal/shared/php.ini";
var Sp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function to(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
const { hasOwnProperty: Si } = Object.prototype, La = (e, t = {}) => {
  typeof t == "string" && (t = { section: t }), t.align = t.align === !0, t.newline = t.newline === !0, t.sort = t.sort === !0, t.whitespace = t.whitespace === !0 || t.align === !0, t.platform = t.platform || typeof process < "u" && process.platform, t.bracketedArray = t.bracketedArray !== !1;
  const r = t.platform === "win32" ? `\r
` : `
`, i = t.whitespace ? " = " : "=", a = [], s = t.sort ? Object.keys(e).sort() : Object.keys(e);
  let n = 0;
  t.align && (n = tr(
    s.filter((p) => e[p] === null || Array.isArray(e[p]) || typeof e[p] != "object").map((p) => Array.isArray(e[p]) ? `${p}[]` : p).concat([""]).reduce((p, c) => tr(p).length >= tr(c).length ? p : c)
  ).length);
  let o = "";
  const l = t.bracketedArray ? "[]" : "";
  for (const p of s) {
    const c = e[p];
    if (c && Array.isArray(c))
      for (const m of c)
        o += tr(`${p}${l}`).padEnd(n, " ") + i + tr(m) + r;
    else c && typeof c == "object" ? a.push(p) : o += tr(p).padEnd(n, " ") + i + tr(c) + r;
  }
  t.section && o.length && (o = "[" + tr(t.section) + "]" + (t.newline ? r + r : r) + o);
  for (const p of a) {
    const c = Ep(p, ".").join("\\."), m = (t.section ? t.section + "." : "") + c, h = La(e[p], {
      ...t,
      section: m
    });
    o.length && h.length && (o += r), o += h;
  }
  return o;
};
function Ep(e, t) {
  var r = 0, i = 0, a = 0, s = [];
  do
    if (a = e.indexOf(t, r), a !== -1) {
      if (r = a + t.length, a > 0 && e[a - 1] === "\\")
        continue;
      s.push(e.slice(i, a)), i = a + t.length;
    }
  while (a !== -1);
  return s.push(e.slice(i)), s;
}
const Bo = (e, t = {}) => {
  t.bracketedArray = t.bracketedArray !== !1;
  const r = /* @__PURE__ */ Object.create(null);
  let i = r, a = null;
  const s = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i, n = e.split(/[\r\n]+/g), o = {};
  for (const p of n) {
    if (!p || p.match(/^\s*[;#]/) || p.match(/^\s*$/))
      continue;
    const c = p.match(s);
    if (!c)
      continue;
    if (c[1] !== void 0) {
      if (a = ks(c[1]), a === "__proto__") {
        i = /* @__PURE__ */ Object.create(null);
        continue;
      }
      i = r[a] = r[a] || /* @__PURE__ */ Object.create(null);
      continue;
    }
    const m = ks(c[2]);
    let h;
    t.bracketedArray ? h = m.length > 2 && m.slice(-2) === "[]" : (o[m] = ((o == null ? void 0 : o[m]) || 0) + 1, h = o[m] > 1);
    const g = h ? m.slice(0, -2) : m;
    if (g === "__proto__")
      continue;
    const R = c[3] ? ks(c[4]) : !0, y = R === "true" || R === "false" || R === "null" ? JSON.parse(R) : R;
    h && (Si.call(i, g) ? Array.isArray(i[g]) || (i[g] = [i[g]]) : i[g] = []), Array.isArray(i[g]) ? i[g].push(y) : i[g] = y;
  }
  const l = [];
  for (const p of Object.keys(r)) {
    if (!Si.call(r, p) || typeof r[p] != "object" || Array.isArray(r[p]))
      continue;
    const c = Ep(p, ".");
    i = r;
    const m = c.pop(), h = m.replace(/\\\./g, ".");
    for (const g of c)
      g !== "__proto__" && ((!Si.call(i, g) || typeof i[g] != "object") && (i[g] = /* @__PURE__ */ Object.create(null)), i = i[g]);
    i === r && h === m || (i[h] = r[p], l.push(p));
  }
  for (const p of l)
    delete r[p];
  return r;
}, kp = (e) => e.startsWith('"') && e.endsWith('"') || e.startsWith("'") && e.endsWith("'"), tr = (e) => typeof e != "string" || e.match(/[=\r\n]/) || e.match(/^\[/) || e.length > 1 && kp(e) || e !== e.trim() ? JSON.stringify(e) : e.split(";").join("\\;").split("#").join("\\#"), ks = (e) => {
  if (e = (e || "").trim(), kp(e)) {
    e.charAt(0) === "'" && (e = e.slice(1, -1));
    try {
      e = JSON.parse(e);
    } catch {
    }
  } else {
    let t = !1, r = "";
    for (let i = 0, a = e.length; i < a; i++) {
      const s = e.charAt(i);
      if (t)
        "\\;#".indexOf(s) !== -1 ? r += s : r += "\\" + s, t = !1;
      else {
        if (";#".indexOf(s) !== -1)
          break;
        s === "\\" ? t = !0 : r += s;
      }
    }
    return t && (r += "\\"), r.trim();
  }
  return e;
};
var No = {
  parse: Bo,
  decode: Bo,
  stringify: La,
  encode: La,
  safe: tr,
  unsafe: ks
};
async function ov(e, t) {
  const r = No.parse(await e.readFileAsText(Fo));
  for (const [i, a] of Object.entries(t))
    a == null ? delete r[i] : r[i] = a;
  await e.writeFile(Fo, No.stringify(r));
}
function kd(...e) {
  const t = new Uint8Array(
    e.reduce((i, a) => i + a.length, 0)
  );
  let r = 0;
  for (const i of e)
    t.set(i, r), r += i.length;
  return t;
}
function Pd(e) {
  {
    let t = new Uint8Array();
    return new TransformStream({
      transform(r) {
        t = kd(t, r);
      },
      flush(r) {
        r.enqueue(t);
      }
    });
  }
}
async function Ad(e, t) {
  return await e.pipeThrough(Pd()).getReader().read().then(({ value: r }) => r);
}
class Ir extends File {
  static fromArrayBuffer(t, r, i) {
    return new Ir(
      new ReadableStream({
        start(a) {
          a.enqueue(new Uint8Array(t)), a.close();
        }
      }),
      r,
      i
    );
  }
  /**
   * Creates a new StreamedFile instance.
   *
   * @param readableStream The readable stream containing the file data.
   * @param name The name of the file.
   * @param options An object containing options such as the MIME type and file size.
   */
  constructor(t, r, i) {
    super([], r, { type: i == null ? void 0 : i.type }), this.readableStream = t, this.filesize = i == null ? void 0 : i.filesize;
  }
  /**
   * Overrides the slice() method of the File class.
   *
   * @returns A Blob representing a portion of the file.
   */
  slice() {
    throw new Error("slice() is not possible on a StreamedFile");
  }
  /**
   * Returns the readable stream associated with the file.
   *
   * @returns The readable stream.
   */
  stream() {
    return this.readableStream;
  }
  /**
   * Loads the file data into memory and then returns it as a string.
   *
   * @returns File data as text.
   */
  async text() {
    return new TextDecoder().decode(await this.arrayBuffer());
  }
  /**
   * Loads the file data into memory and then returns it as an ArrayBuffer.
   *
   * @returns File data as an ArrayBuffer.
   */
  async arrayBuffer() {
    return await Ad(this.stream());
  }
}
ReadableStream.prototype[Symbol.asyncIterator] || (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
  const e = this.getReader();
  try {
    for (; ; ) {
      const { done: t, value: r } = await e.read();
      if (t)
        return;
      yield r;
    }
  } finally {
    e.releaseLock();
  }
}, ReadableStream.prototype.iterate = // @ts-ignore
ReadableStream.prototype[Symbol.asyncIterator]);
new cn({ concurrency: 10 });
const ro = [
  "8.4",
  "8.3",
  "8.2",
  "8.1",
  "8.0",
  "7.4",
  "7.3",
  "7.2"
], Td = ro[0], lv = ro;
async function oi(e, t, r, { rmRoot: i = !1 } = {}) {
  i && await e.isDir(t) && await e.rmdir(t, { recursive: !0 });
  for (const [a, s] of Object.entries(r)) {
    const n = Ae(t, a);
    await e.fileExists(Ca(n)) || await e.mkdir(Ca(n)), s instanceof Uint8Array || typeof s == "string" ? await e.writeFile(n, s) : await oi(e, n, s);
  }
}
/**
 * Original, unmodified Comlink library from Google:
 *
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Pp = Symbol("Comlink.proxy"), Od = Symbol("Comlink.endpoint"), Cd = Symbol("Comlink.releaseProxy"), Ei = Symbol("Comlink.finalizer"), Ps = Symbol("Comlink.thrown");
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Us = {
  RAW: "RAW",
  HANDLER: "HANDLER"
}, bt = {
  GET: "GET",
  SET: "SET",
  APPLY: "APPLY",
  CONSTRUCT: "CONSTRUCT",
  ENDPOINT: "ENDPOINT",
  RELEASE: "RELEASE"
}, Ap = (e) => typeof e == "object" && e !== null || typeof e == "function", Ld = {
  canHandle: (e) => Ap(e) && e[Pp],
  serialize(e) {
    const { port1: t, port2: r } = new MessageChannel();
    return no(e, t), [r, [r]];
  },
  deserialize(e) {
    return e.start(), so(e);
  }
}, Rd = {
  canHandle: (e) => Ap(e) && Ps in e,
  serialize({ value: e }) {
    let t;
    return e instanceof Error ? t = {
      isError: !0,
      value: {
        message: e.message,
        name: e.name,
        stack: e.stack
      }
    } : t = { isError: !1, value: e }, [t, []];
  },
  deserialize(e) {
    throw e.isError ? Object.assign(
      new Error(e.value.message),
      e.value
    ) : e.value;
  }
}, qt = /* @__PURE__ */ new Map([
  ["proxy", Ld],
  ["throw", Rd]
]);
function $d(e, t) {
  for (const r of e)
    if (t === r || r === "*" || r instanceof RegExp && r.test(t))
      return !0;
  return !1;
}
function no(e, t = globalThis, r = ["*"], i) {
  t.addEventListener("message", function a(s) {
    if (!s || !s.data)
      return;
    if (!$d(r, s.origin)) {
      console.warn(`Invalid origin '${s.origin}' for comlink proxy`);
      return;
    }
    const { id: n, type: o, path: l } = {
      path: [],
      ...s.data
    }, p = (s.data.argumentList || []).map(kr);
    let c;
    try {
      const m = l.slice(0, -1).reduce((g, R) => g[R], e), h = l.reduce((g, R) => g[R], e);
      switch (o) {
        case bt.GET:
          c = h;
          break;
        case bt.SET:
          m[l.slice(-1)[0]] = kr(
            s.data.value
          ), c = !0;
          break;
        case bt.APPLY:
          c = h.apply(m, p);
          break;
        case bt.CONSTRUCT:
          {
            const g = new h(...p);
            c = Lp(g);
          }
          break;
        case bt.ENDPOINT:
          {
            const { port1: g, port2: R } = new MessageChannel();
            no(e, R), c = Bd(g, [g]);
          }
          break;
        case bt.RELEASE:
          c = void 0;
          break;
        default:
          return;
      }
    } catch (m) {
      c = { value: m, [Ps]: 0 };
    }
    Promise.resolve(c).catch((m) => ({ value: m, [Ps]: 0 })).then((m) => {
      const [h, g] = qs(m);
      t.postMessage({ ...h, id: n }, g), o === bt.RELEASE && (t.removeEventListener("message", a), Tp(t), Ei in e && typeof e[Ei] == "function" && e[Ei]());
    }).catch(() => {
      const [m, h] = qs({
        value: new TypeError("Unserializable return value"),
        [Ps]: 0
      });
      t.postMessage({ ...m, id: n }, h);
    }).finally(() => {
    });
  }), t.start && t.start();
}
function Id(e) {
  return e.constructor.name === "MessagePort";
}
function Tp(e) {
  Id(e) && e.close();
}
function so(e, t) {
  const r = /* @__PURE__ */ new Map();
  return e.addEventListener("message", function(a) {
    const { data: s } = a;
    if (!s || !s.id)
      return;
    const n = r.get(s.id);
    if (n)
      try {
        n(s);
      } finally {
        r.delete(s.id);
      }
  }), Ra(e, r, [], t);
}
function ls(e) {
  if (e)
    throw new Error("Proxy has been released and is not useable");
}
function Op(e) {
  return Xr(e, /* @__PURE__ */ new Map(), {
    type: bt.RELEASE
  }).then(() => {
    Tp(e);
  });
}
const Ws = /* @__PURE__ */ new WeakMap(), Ms = "FinalizationRegistry" in globalThis && new FinalizationRegistry((e) => {
  const t = (Ws.get(e) || 0) - 1;
  Ws.set(e, t), t === 0 && Op(e);
});
function Dd(e, t) {
  const r = (Ws.get(t) || 0) + 1;
  Ws.set(t, r), Ms && Ms.register(e, t, e);
}
function Hd(e) {
  Ms && Ms.unregister(e);
}
function Ra(e, t, r = [], i = function() {
}) {
  let a = !1;
  const s = new Proxy(i, {
    get(n, o) {
      if (ls(a), o === Cd)
        return () => {
          Hd(s), Op(e), t.clear(), a = !0;
        };
      if (o === "then") {
        if (r.length === 0)
          return { then: () => s };
        const l = Xr(e, t, {
          type: bt.GET,
          path: r.map((p) => p.toString())
        }).then(kr);
        return l.then.bind(l);
      }
      return Ra(e, t, [...r, o]);
    },
    set(n, o, l) {
      ls(a);
      const [p, c] = qs(l);
      return Xr(
        e,
        t,
        {
          type: bt.SET,
          path: [...r, o].map((m) => m.toString()),
          value: p
        },
        c
      ).then(kr);
    },
    apply(n, o, l) {
      ls(a);
      const p = r[r.length - 1];
      if (p === Od)
        return Xr(e, t, {
          type: bt.ENDPOINT
        }).then(kr);
      if (p === "bind")
        return Ra(e, t, r.slice(0, -1));
      const [c, m] = jo(l);
      return Xr(
        e,
        t,
        {
          type: bt.APPLY,
          path: r.map((h) => h.toString()),
          argumentList: c
        },
        m
      ).then(kr);
    },
    construct(n, o) {
      ls(a);
      const [l, p] = jo(o);
      return Xr(
        e,
        t,
        {
          type: bt.CONSTRUCT,
          path: r.map((c) => c.toString()),
          argumentList: l
        },
        p
      ).then(kr);
    }
  });
  return Dd(s, e), s;
}
function Fd(e) {
  return Array.prototype.concat.apply([], e);
}
function jo(e) {
  const t = e.map(qs);
  return [t.map((r) => r[0]), Fd(t.map((r) => r[1]))];
}
const Cp = /* @__PURE__ */ new WeakMap();
function Bd(e, t) {
  return Cp.set(e, t), e;
}
function Lp(e) {
  return Object.assign(e, { [Pp]: !0 });
}
function Nd(e, t = globalThis, r = "*") {
  return {
    postMessage: (i, a) => e.postMessage(i, r, a),
    addEventListener: t.addEventListener.bind(t),
    removeEventListener: t.removeEventListener.bind(t)
  };
}
function qs(e) {
  for (const [t, r] of qt)
    if (r.canHandle(e)) {
      const [i, a] = r.serialize(e);
      return [
        {
          type: Us.HANDLER,
          name: t,
          value: i
        },
        a
      ];
    }
  return [
    {
      type: Us.RAW,
      value: e
    },
    Cp.get(e) || []
  ];
}
function kr(e) {
  switch (e.type) {
    case Us.HANDLER:
      return qt.get(e.name).deserialize(e.value);
    case Us.RAW:
      return e.value;
  }
}
function Xr(e, t, r, i) {
  return new Promise((a) => {
    const s = jd();
    t.set(s, a), e.start && e.start(), e.postMessage({ id: s, ...r }, i);
  });
}
function jd() {
  return new Array(4).fill(0).map(
    () => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)
  ).join("-");
}
function Ud(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return {
    postMessage: e.postMessage.bind(e),
    addEventListener: (r, i) => {
      const a = (s) => {
        "handleEvent" in i ? i.handleEvent({ data: s }) : i({ data: s });
      };
      e.on("message", a), t.set(i, a);
    },
    removeEventListener: (r, i) => {
      const a = t.get(i);
      a && (e.off("message", a), t.delete(i));
    },
    start: e.start && e.start.bind(e)
  };
}
const Wd = [
  // Native ES errors https://262.ecma-international.org/12.0/#sec-well-known-intrinsic-objects
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  AggregateError,
  // Built-in errors
  globalThis.DOMException,
  // Node-specific errors
  // https://nodejs.org/api/errors.html
  globalThis.AssertionError,
  globalThis.SystemError
].filter(Boolean).map((e) => [e.name, e]), Md = new Map(Wd);
class io extends Error {
  constructor(t) {
    super(io._prepareSuperMessage(t)), this.name = "NonError";
  }
  static _prepareSuperMessage(t) {
    try {
      return JSON.stringify(t);
    } catch {
      return String(t);
    }
  }
}
const qd = [
  {
    property: "name",
    enumerable: !1
  },
  {
    property: "message",
    enumerable: !1
  },
  {
    property: "stack",
    enumerable: !1
  },
  {
    property: "code",
    enumerable: !0
  },
  {
    property: "cause",
    enumerable: !1
  },
  {
    property: "errors",
    enumerable: !1
  }
], $a = /* @__PURE__ */ new WeakSet(), Kd = (e) => {
  $a.add(e);
  const t = e.toJSON();
  return $a.delete(e), t;
}, Rp = (e) => {
  const t = Md.get(e) ?? Error;
  return t === AggregateError ? new t([]) : new t();
}, ao = ({
  from: e,
  seen: t,
  to: r,
  forceEnumerable: i,
  maxDepth: a,
  depth: s,
  useToJSON: n,
  serialize: o
}) => {
  if (r || (Array.isArray(e) ? r = [] : !o && Uo(e) ? r = Rp(e.name) : r = {}), t.push(e), s >= a)
    return r;
  if (n && typeof e.toJSON == "function" && !$a.has(e))
    return Kd(e);
  const l = (p) => ao({
    from: p,
    seen: [...t],
    forceEnumerable: i,
    maxDepth: a,
    depth: s,
    useToJSON: n,
    serialize: o
  });
  for (const [p, c] of Object.entries(e)) {
    if (c && c instanceof Uint8Array && c.constructor.name === "Buffer") {
      r[p] = "[object Buffer]";
      continue;
    }
    if (c !== null && typeof c == "object" && typeof c.pipe == "function") {
      r[p] = "[object Stream]";
      continue;
    }
    if (typeof c != "function") {
      if (!c || typeof c != "object") {
        try {
          r[p] = c;
        } catch {
        }
        continue;
      }
      if (!t.includes(e[p])) {
        s++, r[p] = l(e[p]);
        continue;
      }
      r[p] = "[Circular]";
    }
  }
  if (o || r instanceof Error)
    for (const { property: p, enumerable: c } of qd)
      e[p] !== void 0 && e[p] !== null && Object.defineProperty(r, p, {
        value: Uo(e[p]) || Array.isArray(e[p]) ? l(e[p]) : e[p],
        enumerable: i ? !0 : c,
        configurable: !0,
        writable: !0
      });
  return r;
};
function zd(e, t = {}) {
  const { maxDepth: r = Number.POSITIVE_INFINITY, useToJSON: i = !0 } = t;
  return typeof e == "object" && e !== null ? ao({
    from: e,
    seen: [],
    forceEnumerable: !0,
    maxDepth: r,
    depth: 0,
    useToJSON: i,
    serialize: !0
  }) : typeof e == "function" ? `[Function: ${e.name || "anonymous"}]` : e;
}
function Gd(e, t = {}) {
  const { maxDepth: r = Number.POSITIVE_INFINITY } = t;
  return e instanceof Error ? e : Vd(e) ? ao({
    from: e,
    seen: [],
    to: Rp(e.name),
    maxDepth: r,
    depth: 0,
    serialize: !1
  }) : new io(e);
}
function Uo(e) {
  return !!e && typeof e == "object" && typeof e.name == "string" && typeof e.message == "string" && typeof e.stack == "string";
}
function Vd(e) {
  return !!e && typeof e == "object" && typeof e.message == "string" && !Array.isArray(e);
}
function $p(e, t = void 0) {
  Yd();
  let r;
  import.meta.url.startsWith("file://") ? r = Ud(e) : r = e instanceof Worker ? e : Nd(e, t);
  const a = so(r), s = Ip(a);
  return new Proxy(s, {
    get: (n, o) => o === "isConnected" ? async () => {
      for (; ; )
        try {
          await Zd(a.isConnected(), 200);
          break;
        } catch {
        }
    } : a[o]
  });
}
async function Zd(e, t) {
  return new Promise((r, i) => {
    setTimeout(i, t), e.then(r);
  });
}
let Wo = !1;
function Yd() {
  if (Wo)
    return;
  Wo = !0, qt.set("EVENT", {
    canHandle: (r) => r instanceof CustomEvent,
    serialize: (r) => [
      {
        detail: r.detail
      },
      []
    ],
    deserialize: (r) => r
  }), qt.set("FUNCTION", {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
    canHandle: (r) => typeof r == "function",
    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
    serialize(r) {
      const { port1: i, port2: a } = new MessageChannel();
      return no(r, i), [a, [a]];
    },
    deserialize(r) {
      return r.start(), so(r);
    }
  }), qt.set("MESSAGE_PORT", {
    canHandle: (r) => r instanceof MessagePort,
    serialize(r) {
      return [r, [r]];
    },
    deserialize(r) {
      return r;
    }
  }), qt.set("PHPResponse", {
    canHandle: (r) => typeof r == "object" && r !== null && "headers" in r && "bytes" in r && "errors" in r && "exitCode" in r && "httpStatusCode" in r,
    serialize(r) {
      return [r.toRawData(), []];
    },
    deserialize(r) {
      return kn.fromRawData(r);
    }
  });
  const e = qt.get("throw"), t = e == null ? void 0 : e.serialize;
  e.serialize = ({ value: r }) => {
    const i = t({ value: r });
    return r.response && (i[0].value.response = r.response), r.source && (i[0].value.source = r.source), i;
  }, qt.set("StreamedPHPResponse", {
    canHandle: (r) => r instanceof xi,
    serialize(r) {
      const i = Xd(), a = Jd(r.exitCode);
      if (i)
        return [{
          __type: "StreamedPHPResponse",
          headers: r.headersStream,
          stdout: r.stdout,
          stderr: r.stderr,
          exitCodePort: a
        }, [a]];
      const s = ki(r.headersStream), n = ki(r.stdout), o = ki(r.stderr);
      return [
        {
          __type: "StreamedPHPResponse",
          headersPort: s,
          stdoutPort: n,
          stderrPort: o,
          exitCodePort: a
        },
        [s, n, o, a]
      ];
    },
    deserialize(r) {
      if (r.headers && r.stdout && r.stderr) {
        const o = Mo(
          r.exitCodePort
        );
        return new xi(
          r.headers,
          r.stdout,
          r.stderr,
          o
        );
      }
      const i = Pi(r.headersPort), a = Pi(r.stdoutPort), s = Pi(r.stderrPort), n = Mo(r.exitCodePort);
      return new xi(i, a, s, n);
    }
  });
}
function Xd() {
  try {
    if (typeof ReadableStream > "u") return !1;
    const { port1: e } = new MessageChannel(), t = new ReadableStream();
    e.postMessage(t);
    try {
      e.close();
    } catch {
    }
    return !0;
  } catch {
    return !1;
  }
}
function ki(e) {
  const { port1: t, port2: r } = new MessageChannel();
  return (async () => {
    const i = e.getReader();
    try {
      for (; ; ) {
        const { done: a, value: s } = await i.read();
        if (a) {
          try {
            t.postMessage({ t: "close" });
          } catch {
          }
          try {
            t.close();
          } catch {
          }
          break;
        }
        if (s) {
          const n = s.byteOffset === 0 && s.byteLength === s.buffer.byteLength ? s : s.slice(), o = n.buffer;
          try {
            t.postMessage({ t: "chunk", b: o }, [
              o
            ]);
          } catch {
            t.postMessage({
              t: "chunk",
              b: n.buffer.slice(0)
            });
          }
        }
      }
    } catch (a) {
      try {
        t.postMessage({ t: "error", m: (a == null ? void 0 : a.message) || String(a) });
      } catch {
      }
    } finally {
      try {
        t.close();
      } catch {
      }
    }
  })(), r;
}
function Pi(e) {
  return new ReadableStream({
    start(t) {
      const r = (a) => {
        const s = a.data;
        if (s)
          switch (s.t) {
            case "chunk":
              t.enqueue(new Uint8Array(s.b));
              break;
            case "close":
              t.close(), i();
              break;
            case "error":
              t.error(new Error(s.m || "Stream error")), i();
              break;
          }
      }, i = () => {
        var a;
        try {
          (a = e.removeEventListener) == null || a.call(e, "message", r);
        } catch {
        }
        try {
          e.onmessage = null;
        } catch {
        }
        try {
          e.close();
        } catch {
        }
      };
      e.addEventListener ? e.addEventListener("message", r) : e.on ? e.on(
        "message",
        (a) => r({ data: a })
      ) : e.onmessage = r, typeof e.start == "function" && e.start();
    },
    cancel() {
      try {
        e.close();
      } catch {
      }
    }
  });
}
function Jd(e) {
  const { port1: t, port2: r } = new MessageChannel();
  return e.then((i) => {
    try {
      t.postMessage({ t: "resolve", v: i });
    } catch {
    }
  }).catch((i) => {
    try {
      t.postMessage({
        t: "reject",
        m: (i == null ? void 0 : i.message) || String(i)
      });
    } catch {
    }
  }).finally(() => {
    try {
      t.close();
    } catch {
    }
  }), r;
}
function Mo(e) {
  return new Promise((t, r) => {
    const i = (s) => {
      const n = s.data;
      n && (n.t === "resolve" ? (a(), t(n.v)) : n.t === "reject" && (a(), r(new Error(n.m || ""))));
    }, a = () => {
      var s;
      try {
        (s = e.removeEventListener) == null || s.call(e, "message", i);
      } catch {
      }
      try {
        e.onmessage = null;
      } catch {
      }
      try {
        e.close();
      } catch {
      }
    };
    e.addEventListener ? e.addEventListener("message", i) : e.on ? e.on(
      "message",
      (s) => i({ data: s })
    ) : e.onmessage = i, typeof e.start == "function" && e.start();
  });
}
const Qd = qt.get(
  "throw"
), eh = {
  canHandle: Qd.canHandle,
  serialize: ({ value: e }) => {
    let t;
    return e instanceof Error ? (t = {
      isError: !0,
      value: zd(e)
    }, t.value.originalErrorClassName = e.constructor.name) : t = { isError: !1, value: e }, [t, []];
  },
  deserialize: (e) => {
    if (e.isError) {
      const t = Gd(e.value), r = new Error("Comlink method call failed");
      let i = t;
      for (; i.cause; )
        i = i.cause;
      throw i.cause = r, t;
    }
    throw e.value;
  }
};
qt.set("throw", eh);
function Ip(e) {
  return new Proxy(e, {
    get(t, r) {
      switch (typeof t[r]) {
        case "function":
          return (...i) => t[r](...i);
        case "object":
          return t[r] === null ? t[r] : Ip(t[r]);
        case "undefined":
        case "number":
        case "string":
          return t[r];
        default:
          return Lp(t[r]);
      }
    }
  });
}
new cn({ concurrency: 15 });
new cn({ concurrency: 10 });
function th(e) {
  let t = [e];
  return {
    next() {
      return Promise.resolve({ done: t.length === 0, value: t.pop() });
    },
    return() {
      return t = [], {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function Dp(e) {
  return e[Symbol.asyncIterator] ? e[Symbol.asyncIterator]() : e[Symbol.iterator] ? e[Symbol.iterator]() : e.next ? e : th(e);
}
class Hp {
  constructor(t) {
    if (typeof Buffer > "u")
      throw new Error("Missing Buffer dependency");
    this.stream = Dp(t), this.buffer = null, this.cursor = 0, this.undoCursor = 0, this.started = !1, this._ended = !1, this._discardedBytes = 0;
  }
  eof() {
    return this._ended && this.cursor === this.buffer.length;
  }
  tell() {
    return this._discardedBytes + this.cursor;
  }
  async byte() {
    if (!this.eof() && (this.started || await this._init(), !(this.cursor === this.buffer.length && (await this._loadnext(), this._ended))))
      return this._moveCursor(1), this.buffer[this.undoCursor];
  }
  async chunk() {
    if (!this.eof() && (this.started || await this._init(), !(this.cursor === this.buffer.length && (await this._loadnext(), this._ended))))
      return this._moveCursor(this.buffer.length), this.buffer.slice(this.undoCursor, this.cursor);
  }
  async read(t) {
    if (!this.eof())
      return this.started || await this._init(), this.cursor + t > this.buffer.length && (this._trim(), await this._accumulate(t)), this._moveCursor(t), this.buffer.slice(this.undoCursor, this.cursor);
  }
  async skip(t) {
    this.eof() || (this.started || await this._init(), this.cursor + t > this.buffer.length && (this._trim(), await this._accumulate(t)), this._moveCursor(t));
  }
  async undo() {
    this.cursor = this.undoCursor;
  }
  async _next() {
    this.started = !0;
    let { done: t, value: r } = await this.stream.next();
    return t && (this._ended = !0, !r) ? Buffer.alloc(0) : (r && (r = Buffer.from(r)), r);
  }
  _trim() {
    this.buffer = this.buffer.slice(this.undoCursor), this.cursor -= this.undoCursor, this._discardedBytes += this.undoCursor, this.undoCursor = 0;
  }
  _moveCursor(t) {
    this.undoCursor = this.cursor, this.cursor += t, this.cursor > this.buffer.length && (this.cursor = this.buffer.length);
  }
  async _accumulate(t) {
    if (this._ended) return;
    const r = [this.buffer];
    for (; this.cursor + t > rh(r); ) {
      const i = await this._next();
      if (this._ended) break;
      r.push(i);
    }
    this.buffer = Buffer.concat(r);
  }
  async _loadnext() {
    this._discardedBytes += this.buffer.length, this.undoCursor = 0, this.cursor = 0, this.buffer = await this._next();
  }
  async _init() {
    this.buffer = await this._next();
  }
}
function rh(e) {
  return e.reduce((t, r) => t + r.length, 0);
}
function nh(e, t) {
  const r = t.toString(16);
  return "0".repeat(e - r.length) + r;
}
class Ye {
  static flush() {
    return Buffer.from("0000", "utf8");
  }
  static delim() {
    return Buffer.from("0001", "utf8");
  }
  static encode(t) {
    typeof t == "string" && (t = Buffer.from(t));
    const r = t.length + 4, i = nh(4, r);
    return Buffer.concat([Buffer.from(i, "utf8"), t]);
  }
  static streamReader(t) {
    const r = new Hp(t);
    return async function() {
      try {
        let a = await r.read(4);
        if (a == null) return !0;
        if (a = parseInt(a.toString("utf8"), 16), a === 0 || a === 1) return null;
        const s = await r.read(a - 4);
        return s ?? !0;
      } catch (a) {
        return t.error = a, !0;
      }
    };
  }
}
class un extends Error {
  constructor(t) {
    super(t), this.caller = "";
  }
  toJSON() {
    return {
      code: this.code,
      data: this.data,
      caller: this.caller,
      message: this.message,
      stack: this.stack
    };
  }
  fromJSON(t) {
    const r = new un(t.message);
    return r.code = t.code, r.data = t.data, r.caller = t.caller, r.stack = t.stack, r;
  }
  get isIsomorphicGitError() {
    return !0;
  }
}
class ke extends un {
  /**
   * @param {string} message
   */
  constructor(t) {
    super(
      `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${t}`
    ), this.code = this.name = ke.code, this.data = { message: t };
  }
}
ke.code = "InternalError";
class Gn extends un {
  /**
   * @param {string} filepath
   */
  constructor(t) {
    super(`The filepath "${t}" contains unsafe character sequences`), this.code = this.name = Gn.code, this.data = { filepath: t };
  }
}
Gn.code = "UnsafeFilepathError";
function Fp(e, t) {
  return -(e < t) || +(e > t);
}
function Bp(e, t) {
  return Fp(e.path, t.path);
}
function sh(e, t) {
  return Fp(qo(e), qo(t));
}
function qo(e) {
  return e.mode === "040000" ? e.path + "/" : e.path;
}
function Np(e) {
  switch (e) {
    case "040000":
      return "tree";
    case "100644":
      return "blob";
    case "100755":
      return "blob";
    case "120000":
      return "blob";
    case "160000":
      return "commit";
  }
  throw new ke(`Unexpected GitTree entry mode: ${e}`);
}
function ih(e) {
  const t = [];
  let r = 0;
  for (; r < e.length; ) {
    const i = e.indexOf(32, r);
    if (i === -1)
      throw new ke(
        `GitTree: Error parsing buffer at byte location ${r}: Could not find the next space character.`
      );
    const a = e.indexOf(0, r);
    if (a === -1)
      throw new ke(
        `GitTree: Error parsing buffer at byte location ${r}: Could not find the next null character.`
      );
    let s = e.slice(r, i).toString("utf8");
    s === "40000" && (s = "040000");
    const n = Np(s), o = e.slice(i + 1, a).toString("utf8");
    if (o.includes("\\") || o.includes("/"))
      throw new Gn(o);
    const l = e.slice(a + 1, a + 21).toString("hex");
    r = a + 21, t.push({ mode: s, path: o, oid: l, type: n });
  }
  return t;
}
function ah(e) {
  if (typeof e == "number" && (e = e.toString(8)), e.match(/^0?4.*/)) return "040000";
  if (e.match(/^1006.*/)) return "100644";
  if (e.match(/^1007.*/)) return "100755";
  if (e.match(/^120.*/)) return "120000";
  if (e.match(/^160.*/)) return "160000";
  throw new ke(`Could not understand file mode: ${e}`);
}
function oh(e) {
  return !e.oid && e.sha && (e.oid = e.sha), e.mode = ah(e.mode), e.type || (e.type = Np(e.mode)), e;
}
class oo {
  constructor(t) {
    if (Buffer.isBuffer(t))
      this._entries = ih(t);
    else if (Array.isArray(t))
      this._entries = t.map(oh);
    else
      throw new ke("invalid type passed to GitTree constructor");
    this._entries.sort(Bp);
  }
  static from(t) {
    return new oo(t);
  }
  render() {
    return this._entries.map((t) => `${t.mode} ${t.type} ${t.oid}    ${t.path}`).join(`
`);
  }
  toObject() {
    const t = [...this._entries];
    return t.sort(sh), Buffer.concat(
      t.map((r) => {
        const i = Buffer.from(r.mode.replace(/^0/, "")), a = Buffer.from(" "), s = Buffer.from(r.path, "utf8"), n = Buffer.from([0]), o = Buffer.from(r.oid, "hex");
        return Buffer.concat([i, a, s, n, o]);
      })
    );
  }
  /**
   * @returns {TreeEntry[]}
   */
  entries() {
    return this._entries;
  }
  *[Symbol.iterator]() {
    for (const t of this._entries)
      yield t;
  }
}
function Ia({ name: e, email: t, timestamp: r, timezoneOffset: i }) {
  return i = lh(i), `${e} <${t}> ${r} ${i}`;
}
function lh(e) {
  const t = fh(ph(e));
  e = Math.abs(e);
  const r = Math.floor(e / 60);
  e -= r * 60;
  let i = String(r), a = String(e);
  return i.length < 2 && (i = "0" + i), a.length < 2 && (a = "0" + a), (t === -1 ? "-" : "+") + i + a;
}
function fh(e) {
  return Math.sign(e) || (Object.is(e, -0) ? -1 : 1);
}
function ph(e) {
  return e === 0 ? e : -e;
}
function rr(e) {
  return e = e.replace(/\r/g, ""), e = e.replace(/^\n+/, ""), e = e.replace(/\n+$/, "") + `
`, e;
}
function Ks(e) {
  const [, t, r, i, a] = e.match(
    /^(.*) <(.*)> (.*) (.*)$/
  );
  return {
    name: t,
    email: r,
    timestamp: Number(i),
    timezoneOffset: ch(a)
  };
}
function ch(e) {
  let [, t, r, i] = e.match(/(\+|-)(\d\d)(\d\d)/);
  return i = (t === "+" ? 1 : -1) * (Number(r) * 60 + Number(i)), uh(i);
}
function uh(e) {
  return e === 0 ? e : -e;
}
class Pn {
  constructor(t) {
    if (typeof t == "string")
      this._tag = t;
    else if (Buffer.isBuffer(t))
      this._tag = t.toString("utf8");
    else if (typeof t == "object")
      this._tag = Pn.render(t);
    else
      throw new ke(
        "invalid type passed to GitAnnotatedTag constructor"
      );
  }
  static from(t) {
    return new Pn(t);
  }
  static render(t) {
    return `object ${t.object}
type ${t.type}
tag ${t.tag}
tagger ${Ia(t.tagger)}

${t.message}
${t.gpgsig ? t.gpgsig : ""}`;
  }
  justHeaders() {
    return this._tag.slice(0, this._tag.indexOf(`

`));
  }
  message() {
    const t = this.withoutSignature();
    return t.slice(t.indexOf(`

`) + 2);
  }
  parse() {
    return Object.assign(this.headers(), {
      message: this.message(),
      gpgsig: this.gpgsig()
    });
  }
  render() {
    return this._tag;
  }
  headers() {
    const t = this.justHeaders().split(`
`), r = [];
    for (const a of t)
      a[0] === " " ? r[r.length - 1] += `
` + a.slice(1) : r.push(a);
    const i = {};
    for (const a of r) {
      const s = a.slice(0, a.indexOf(" ")), n = a.slice(a.indexOf(" ") + 1);
      Array.isArray(i[s]) ? i[s].push(n) : i[s] = n;
    }
    return i.tagger && (i.tagger = Ks(i.tagger)), i.committer && (i.committer = Ks(i.committer)), i;
  }
  withoutSignature() {
    const t = rr(this._tag);
    return t.indexOf(`
-----BEGIN PGP SIGNATURE-----`) === -1 ? t : t.slice(0, t.lastIndexOf(`
-----BEGIN PGP SIGNATURE-----`));
  }
  gpgsig() {
    if (this._tag.indexOf(`
-----BEGIN PGP SIGNATURE-----`) === -1) return;
    const t = this._tag.slice(
      this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._tag.indexOf("-----END PGP SIGNATURE-----") + 27
    );
    return rr(t);
  }
  payload() {
    return this.withoutSignature() + `
`;
  }
  toObject() {
    return Buffer.from(this._tag, "utf8");
  }
  static async sign(t, r, i) {
    const a = t.payload();
    let { signature: s } = await r({ payload: a, secretKey: i });
    s = rr(s);
    const n = a + s;
    return Pn.from(n);
  }
}
function Ai(e) {
  return e.trim().split(`
`).map((t) => " " + t).join(`
`) + `
`;
}
function dh(e) {
  return e.split(`
`).map((t) => t.replace(/^ /, "")).join(`
`);
}
class _t {
  constructor(t) {
    if (typeof t == "string")
      this._commit = t;
    else if (Buffer.isBuffer(t))
      this._commit = t.toString("utf8");
    else if (typeof t == "object")
      this._commit = _t.render(t);
    else
      throw new ke("invalid type passed to GitCommit constructor");
  }
  static fromPayloadSignature({ payload: t, signature: r }) {
    const i = _t.justHeaders(t), a = _t.justMessage(t), s = rr(
      i + `
gpgsig` + Ai(r) + `
` + a
    );
    return new _t(s);
  }
  static from(t) {
    return new _t(t);
  }
  toObject() {
    return Buffer.from(this._commit, "utf8");
  }
  // Todo: allow setting the headers and message
  headers() {
    return this.parseHeaders();
  }
  // Todo: allow setting the headers and message
  message() {
    return _t.justMessage(this._commit);
  }
  parse() {
    return Object.assign({ message: this.message() }, this.headers());
  }
  static justMessage(t) {
    return rr(t.slice(t.indexOf(`

`) + 2));
  }
  static justHeaders(t) {
    return t.slice(0, t.indexOf(`

`));
  }
  parseHeaders() {
    const t = _t.justHeaders(this._commit).split(`
`), r = [];
    for (const a of t)
      a[0] === " " ? r[r.length - 1] += `
` + a.slice(1) : r.push(a);
    const i = {
      parent: []
    };
    for (const a of r) {
      const s = a.slice(0, a.indexOf(" ")), n = a.slice(a.indexOf(" ") + 1);
      Array.isArray(i[s]) ? i[s].push(n) : i[s] = n;
    }
    return i.author && (i.author = Ks(i.author)), i.committer && (i.committer = Ks(i.committer)), i;
  }
  static renderHeaders(t) {
    let r = "";
    if (t.tree ? r += `tree ${t.tree}
` : r += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904
`, t.parent) {
      if (t.parent.length === void 0)
        throw new ke("commit 'parent' property should be an array");
      for (const s of t.parent)
        r += `parent ${s}
`;
    }
    const i = t.author;
    r += `author ${Ia(i)}
`;
    const a = t.committer || t.author;
    return r += `committer ${Ia(a)}
`, t.gpgsig && (r += "gpgsig" + Ai(t.gpgsig)), r;
  }
  static render(t) {
    return _t.renderHeaders(t) + `
` + rr(t.message);
  }
  render() {
    return this._commit;
  }
  withoutSignature() {
    const t = rr(this._commit);
    if (t.indexOf(`
gpgsig`) === -1) return t;
    const r = t.slice(0, t.indexOf(`
gpgsig`)), i = t.slice(
      t.indexOf(`-----END PGP SIGNATURE-----
`) + 28
    );
    return rr(r + `
` + i);
  }
  isolateSignature() {
    const t = this._commit.slice(
      this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._commit.indexOf("-----END PGP SIGNATURE-----") + 27
    );
    return dh(t);
  }
  static async sign(t, r, i) {
    const a = t.withoutSignature(), s = _t.justMessage(t._commit);
    let { signature: n } = await r({ payload: a, secretKey: i });
    n = rr(n);
    const l = _t.justHeaders(t._commit) + `
gpgsig` + Ai(n) + `
` + s;
    return _t.from(l);
  }
}
var jp = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
(function(e) {
  (function(t) {
    t(typeof DO_NOT_EXPORT_CRC > "u" ? e : {});
  })(function(t) {
    t.version = "1.2.2";
    function r() {
      for (var A = 0, L = new Array(256), S = 0; S != 256; ++S)
        A = S, A = A & 1 ? -306674912 ^ A >>> 1 : A >>> 1, A = A & 1 ? -306674912 ^ A >>> 1 : A >>> 1, A = A & 1 ? -306674912 ^ A >>> 1 : A >>> 1, A = A & 1 ? -306674912 ^ A >>> 1 : A >>> 1, A = A & 1 ? -306674912 ^ A >>> 1 : A >>> 1, A = A & 1 ? -306674912 ^ A >>> 1 : A >>> 1, A = A & 1 ? -306674912 ^ A >>> 1 : A >>> 1, A = A & 1 ? -306674912 ^ A >>> 1 : A >>> 1, L[S] = A;
      return typeof Int32Array < "u" ? new Int32Array(L) : L;
    }
    var i = r();
    function a(A) {
      var L = 0, S = 0, P = 0, I = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
      for (P = 0; P != 256; ++P) I[P] = A[P];
      for (P = 0; P != 256; ++P)
        for (S = A[P], L = 256 + P; L < 4096; L += 256) S = I[L] = S >>> 8 ^ A[S & 255];
      var $ = [];
      for (P = 1; P != 16; ++P) $[P - 1] = typeof Int32Array < "u" ? I.subarray(P * 256, P * 256 + 256) : I.slice(P * 256, P * 256 + 256);
      return $;
    }
    var s = a(i), n = s[0], o = s[1], l = s[2], p = s[3], c = s[4], m = s[5], h = s[6], g = s[7], R = s[8], y = s[9], _ = s[10], w = s[11], C = s[12], E = s[13], D = s[14];
    function T(A, L) {
      for (var S = L ^ -1, P = 0, I = A.length; P < I; ) S = S >>> 8 ^ i[(S ^ A.charCodeAt(P++)) & 255];
      return ~S;
    }
    function H(A, L) {
      for (var S = L ^ -1, P = A.length - 15, I = 0; I < P; ) S = D[A[I++] ^ S & 255] ^ E[A[I++] ^ S >> 8 & 255] ^ C[A[I++] ^ S >> 16 & 255] ^ w[A[I++] ^ S >>> 24] ^ _[A[I++]] ^ y[A[I++]] ^ R[A[I++]] ^ g[A[I++]] ^ h[A[I++]] ^ m[A[I++]] ^ c[A[I++]] ^ p[A[I++]] ^ l[A[I++]] ^ o[A[I++]] ^ n[A[I++]] ^ i[A[I++]];
      for (P += 15; I < P; ) S = S >>> 8 ^ i[(S ^ A[I++]) & 255];
      return ~S;
    }
    function k(A, L) {
      for (var S = L ^ -1, P = 0, I = A.length, $ = 0, N = 0; P < I; )
        $ = A.charCodeAt(P++), $ < 128 ? S = S >>> 8 ^ i[(S ^ $) & 255] : $ < 2048 ? (S = S >>> 8 ^ i[(S ^ (192 | $ >> 6 & 31)) & 255], S = S >>> 8 ^ i[(S ^ (128 | $ & 63)) & 255]) : $ >= 55296 && $ < 57344 ? ($ = ($ & 1023) + 64, N = A.charCodeAt(P++) & 1023, S = S >>> 8 ^ i[(S ^ (240 | $ >> 8 & 7)) & 255], S = S >>> 8 ^ i[(S ^ (128 | $ >> 2 & 63)) & 255], S = S >>> 8 ^ i[(S ^ (128 | N >> 6 & 15 | ($ & 3) << 4)) & 255], S = S >>> 8 ^ i[(S ^ (128 | N & 63)) & 255]) : (S = S >>> 8 ^ i[(S ^ (224 | $ >> 12 & 15)) & 255], S = S >>> 8 ^ i[(S ^ (128 | $ >> 6 & 63)) & 255], S = S >>> 8 ^ i[(S ^ (128 | $ & 63)) & 255]);
      return ~S;
    }
    t.table = i, t.bstr = T, t.buf = H, t.str = k;
  });
})(jp);
const hh = /* @__PURE__ */ to(jp);
class mh {
  static wrap({ type: t, object: r }) {
    return Buffer.concat([
      Buffer.from(`${t} ${r.byteLength.toString()}\0`),
      Buffer.from(r)
    ]);
  }
  static unwrap(t) {
    const r = t.indexOf(32), i = t.indexOf(0), a = t.slice(0, r).toString("utf8"), s = t.slice(r + 1, i).toString("utf8"), n = t.length - (i + 1);
    if (parseInt(s) !== n)
      throw new ke(
        `Length mismatch: expected ${s} bytes but got ${n} instead.`
      );
    return {
      type: a,
      object: Buffer.from(t.slice(i + 1))
    };
  }
}
class Kt {
  constructor(t) {
    this.buffer = t, this._start = 0;
  }
  eof() {
    return this._start >= this.buffer.length;
  }
  tell() {
    return this._start;
  }
  seek(t) {
    this._start = t;
  }
  slice(t) {
    const r = this.buffer.slice(this._start, this._start + t);
    return this._start += t, r;
  }
  toString(t, r) {
    const i = this.buffer.toString(t, this._start, this._start + r);
    return this._start += r, i;
  }
  write(t, r, i) {
    const a = this.buffer.write(t, this._start, r, i);
    return this._start += r, a;
  }
  copy(t, r, i) {
    const a = t.copy(this.buffer, this._start, r, i);
    return this._start += a, a;
  }
  readUInt8() {
    const t = this.buffer.readUInt8(this._start);
    return this._start += 1, t;
  }
  writeUInt8(t) {
    const r = this.buffer.writeUInt8(t, this._start);
    return this._start += 1, r;
  }
  readUInt16BE() {
    const t = this.buffer.readUInt16BE(this._start);
    return this._start += 2, t;
  }
  writeUInt16BE(t) {
    const r = this.buffer.writeUInt16BE(t, this._start);
    return this._start += 2, r;
  }
  readUInt32BE() {
    const t = this.buffer.readUInt32BE(this._start);
    return this._start += 4, t;
  }
  writeUInt32BE(t) {
    const r = this.buffer.writeUInt32BE(t, this._start);
    return this._start += 4, r;
  }
}
function yh(e, t) {
  const r = new Kt(e), i = Ko(r);
  if (i !== t.byteLength)
    throw new ke(
      `applyDelta expected source buffer to be ${i} bytes but the provided buffer was ${t.length} bytes`
    );
  const a = Ko(r);
  let s;
  const n = Go(r, t);
  if (n.byteLength === a)
    s = n;
  else {
    s = Buffer.alloc(a);
    const o = new Kt(s);
    for (o.copy(n); !r.eof(); )
      o.copy(Go(r, t));
    const l = o.tell();
    if (a !== l)
      throw new ke(
        `applyDelta expected target buffer to be ${a} bytes but the resulting buffer was ${l} bytes`
      );
  }
  return s;
}
function Ko(e) {
  let t = 0, r = 0, i = null;
  do
    i = e.readUInt8(), t |= (i & 127) << r, r += 7;
  while (i & 128);
  return t;
}
function zo(e, t, r) {
  let i = 0, a = 0;
  for (; r--; )
    t & 1 && (i |= e.readUInt8() << a), t >>= 1, a += 8;
  return i;
}
function Go(e, t) {
  const r = e.readUInt8(), i = 128, a = 15, s = 112;
  if (r & i) {
    const n = zo(e, r & a, 4);
    let o = zo(e, (r & s) >> 4, 3);
    return o === 0 && (o = 65536), t.slice(n, n + o);
  } else
    return e.slice(r);
}
var ar = {};
(function(e) {
  var t = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
  function r(s, n) {
    return Object.prototype.hasOwnProperty.call(s, n);
  }
  e.assign = function(s) {
    for (var n = Array.prototype.slice.call(arguments, 1); n.length; ) {
      var o = n.shift();
      if (o) {
        if (typeof o != "object")
          throw new TypeError(o + "must be non-object");
        for (var l in o)
          r(o, l) && (s[l] = o[l]);
      }
    }
    return s;
  }, e.shrinkBuf = function(s, n) {
    return s.length === n ? s : s.subarray ? s.subarray(0, n) : (s.length = n, s);
  };
  var i = {
    arraySet: function(s, n, o, l, p) {
      if (n.subarray && s.subarray) {
        s.set(n.subarray(o, o + l), p);
        return;
      }
      for (var c = 0; c < l; c++)
        s[p + c] = n[o + c];
    },
    // Join array of chunks to single array.
    flattenChunks: function(s) {
      var n, o, l, p, c, m;
      for (l = 0, n = 0, o = s.length; n < o; n++)
        l += s[n].length;
      for (m = new Uint8Array(l), p = 0, n = 0, o = s.length; n < o; n++)
        c = s[n], m.set(c, p), p += c.length;
      return m;
    }
  }, a = {
    arraySet: function(s, n, o, l, p) {
      for (var c = 0; c < l; c++)
        s[p + c] = n[o + c];
    },
    // Join array of chunks to single array.
    flattenChunks: function(s) {
      return [].concat.apply([], s);
    }
  };
  e.setTyped = function(s) {
    s ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, a));
  }, e.setTyped(t);
})(ar);
var Vn = {}, Xt = {}, dn = {}, _h = ar, gh = 4, Vo = 0, Zo = 1, wh = 2;
function hn(e) {
  for (var t = e.length; --t >= 0; )
    e[t] = 0;
}
var bh = 0, Up = 1, vh = 2, xh = 3, Sh = 258, lo = 29, Zn = 256, $n = Zn + 1 + lo, rn = 30, fo = 19, Wp = 2 * $n + 1, Tr = 15, Ti = 16, Eh = 7, po = 256, Mp = 16, qp = 17, Kp = 18, Da = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
), As = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
), kh = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
), zp = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Ph = 512, nr = new Array(($n + 2) * 2);
hn(nr);
var An = new Array(rn * 2);
hn(An);
var In = new Array(Ph);
hn(In);
var Dn = new Array(Sh - xh + 1);
hn(Dn);
var co = new Array(lo);
hn(co);
var zs = new Array(rn);
hn(zs);
function Oi(e, t, r, i, a) {
  this.static_tree = e, this.extra_bits = t, this.extra_base = r, this.elems = i, this.max_length = a, this.has_stree = e && e.length;
}
var Gp, Vp, Zp;
function Ci(e, t) {
  this.dyn_tree = e, this.max_code = 0, this.stat_desc = t;
}
function Yp(e) {
  return e < 256 ? In[e] : In[256 + (e >>> 7)];
}
function Hn(e, t) {
  e.pending_buf[e.pending++] = t & 255, e.pending_buf[e.pending++] = t >>> 8 & 255;
}
function dt(e, t, r) {
  e.bi_valid > Ti - r ? (e.bi_buf |= t << e.bi_valid & 65535, Hn(e, e.bi_buf), e.bi_buf = t >> Ti - e.bi_valid, e.bi_valid += r - Ti) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += r);
}
function zt(e, t, r) {
  dt(
    e,
    r[t * 2],
    r[t * 2 + 1]
    /*.Len*/
  );
}
function Xp(e, t) {
  var r = 0;
  do
    r |= e & 1, e >>>= 1, r <<= 1;
  while (--t > 0);
  return r >>> 1;
}
function Ah(e) {
  e.bi_valid === 16 ? (Hn(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = e.bi_buf & 255, e.bi_buf >>= 8, e.bi_valid -= 8);
}
function Th(e, t) {
  var r = t.dyn_tree, i = t.max_code, a = t.stat_desc.static_tree, s = t.stat_desc.has_stree, n = t.stat_desc.extra_bits, o = t.stat_desc.extra_base, l = t.stat_desc.max_length, p, c, m, h, g, R, y = 0;
  for (h = 0; h <= Tr; h++)
    e.bl_count[h] = 0;
  for (r[e.heap[e.heap_max] * 2 + 1] = 0, p = e.heap_max + 1; p < Wp; p++)
    c = e.heap[p], h = r[r[c * 2 + 1] * 2 + 1] + 1, h > l && (h = l, y++), r[c * 2 + 1] = h, !(c > i) && (e.bl_count[h]++, g = 0, c >= o && (g = n[c - o]), R = r[c * 2], e.opt_len += R * (h + g), s && (e.static_len += R * (a[c * 2 + 1] + g)));
  if (y !== 0) {
    do {
      for (h = l - 1; e.bl_count[h] === 0; )
        h--;
      e.bl_count[h]--, e.bl_count[h + 1] += 2, e.bl_count[l]--, y -= 2;
    } while (y > 0);
    for (h = l; h !== 0; h--)
      for (c = e.bl_count[h]; c !== 0; )
        m = e.heap[--p], !(m > i) && (r[m * 2 + 1] !== h && (e.opt_len += (h - r[m * 2 + 1]) * r[m * 2], r[m * 2 + 1] = h), c--);
  }
}
function Jp(e, t, r) {
  var i = new Array(Tr + 1), a = 0, s, n;
  for (s = 1; s <= Tr; s++)
    i[s] = a = a + r[s - 1] << 1;
  for (n = 0; n <= t; n++) {
    var o = e[n * 2 + 1];
    o !== 0 && (e[n * 2] = Xp(i[o]++, o));
  }
}
function Oh() {
  var e, t, r, i, a, s = new Array(Tr + 1);
  for (r = 0, i = 0; i < lo - 1; i++)
    for (co[i] = r, e = 0; e < 1 << Da[i]; e++)
      Dn[r++] = i;
  for (Dn[r - 1] = i, a = 0, i = 0; i < 16; i++)
    for (zs[i] = a, e = 0; e < 1 << As[i]; e++)
      In[a++] = i;
  for (a >>= 7; i < rn; i++)
    for (zs[i] = a << 7, e = 0; e < 1 << As[i] - 7; e++)
      In[256 + a++] = i;
  for (t = 0; t <= Tr; t++)
    s[t] = 0;
  for (e = 0; e <= 143; )
    nr[e * 2 + 1] = 8, e++, s[8]++;
  for (; e <= 255; )
    nr[e * 2 + 1] = 9, e++, s[9]++;
  for (; e <= 279; )
    nr[e * 2 + 1] = 7, e++, s[7]++;
  for (; e <= 287; )
    nr[e * 2 + 1] = 8, e++, s[8]++;
  for (Jp(nr, $n + 1, s), e = 0; e < rn; e++)
    An[e * 2 + 1] = 5, An[e * 2] = Xp(e, 5);
  Gp = new Oi(nr, Da, Zn + 1, $n, Tr), Vp = new Oi(An, As, 0, rn, Tr), Zp = new Oi(new Array(0), kh, 0, fo, Eh);
}
function Qp(e) {
  var t;
  for (t = 0; t < $n; t++)
    e.dyn_ltree[t * 2] = 0;
  for (t = 0; t < rn; t++)
    e.dyn_dtree[t * 2] = 0;
  for (t = 0; t < fo; t++)
    e.bl_tree[t * 2] = 0;
  e.dyn_ltree[po * 2] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0;
}
function ec(e) {
  e.bi_valid > 8 ? Hn(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0;
}
function Ch(e, t, r, i) {
  ec(e), Hn(e, r), Hn(e, ~r), _h.arraySet(e.pending_buf, e.window, t, r, e.pending), e.pending += r;
}
function Yo(e, t, r, i) {
  var a = t * 2, s = r * 2;
  return e[a] < e[s] || e[a] === e[s] && i[t] <= i[r];
}
function Li(e, t, r) {
  for (var i = e.heap[r], a = r << 1; a <= e.heap_len && (a < e.heap_len && Yo(t, e.heap[a + 1], e.heap[a], e.depth) && a++, !Yo(t, i, e.heap[a], e.depth)); )
    e.heap[r] = e.heap[a], r = a, a <<= 1;
  e.heap[r] = i;
}
function Xo(e, t, r) {
  var i, a, s = 0, n, o;
  if (e.last_lit !== 0)
    do
      i = e.pending_buf[e.d_buf + s * 2] << 8 | e.pending_buf[e.d_buf + s * 2 + 1], a = e.pending_buf[e.l_buf + s], s++, i === 0 ? zt(e, a, t) : (n = Dn[a], zt(e, n + Zn + 1, t), o = Da[n], o !== 0 && (a -= co[n], dt(e, a, o)), i--, n = Yp(i), zt(e, n, r), o = As[n], o !== 0 && (i -= zs[n], dt(e, i, o)));
    while (s < e.last_lit);
  zt(e, po, t);
}
function Ha(e, t) {
  var r = t.dyn_tree, i = t.stat_desc.static_tree, a = t.stat_desc.has_stree, s = t.stat_desc.elems, n, o, l = -1, p;
  for (e.heap_len = 0, e.heap_max = Wp, n = 0; n < s; n++)
    r[n * 2] !== 0 ? (e.heap[++e.heap_len] = l = n, e.depth[n] = 0) : r[n * 2 + 1] = 0;
  for (; e.heap_len < 2; )
    p = e.heap[++e.heap_len] = l < 2 ? ++l : 0, r[p * 2] = 1, e.depth[p] = 0, e.opt_len--, a && (e.static_len -= i[p * 2 + 1]);
  for (t.max_code = l, n = e.heap_len >> 1; n >= 1; n--)
    Li(e, r, n);
  p = s;
  do
    n = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[
      1
      /*SMALLEST*/
    ] = e.heap[e.heap_len--], Li(
      e,
      r,
      1
      /*SMALLEST*/
    ), o = e.heap[
      1
      /*SMALLEST*/
    ], e.heap[--e.heap_max] = n, e.heap[--e.heap_max] = o, r[p * 2] = r[n * 2] + r[o * 2], e.depth[p] = (e.depth[n] >= e.depth[o] ? e.depth[n] : e.depth[o]) + 1, r[n * 2 + 1] = r[o * 2 + 1] = p, e.heap[
      1
      /*SMALLEST*/
    ] = p++, Li(
      e,
      r,
      1
      /*SMALLEST*/
    );
  while (e.heap_len >= 2);
  e.heap[--e.heap_max] = e.heap[
    1
    /*SMALLEST*/
  ], Th(e, t), Jp(r, l, e.bl_count);
}
function Jo(e, t, r) {
  var i, a = -1, s, n = t[0 * 2 + 1], o = 0, l = 7, p = 4;
  for (n === 0 && (l = 138, p = 3), t[(r + 1) * 2 + 1] = 65535, i = 0; i <= r; i++)
    s = n, n = t[(i + 1) * 2 + 1], !(++o < l && s === n) && (o < p ? e.bl_tree[s * 2] += o : s !== 0 ? (s !== a && e.bl_tree[s * 2]++, e.bl_tree[Mp * 2]++) : o <= 10 ? e.bl_tree[qp * 2]++ : e.bl_tree[Kp * 2]++, o = 0, a = s, n === 0 ? (l = 138, p = 3) : s === n ? (l = 6, p = 3) : (l = 7, p = 4));
}
function Qo(e, t, r) {
  var i, a = -1, s, n = t[0 * 2 + 1], o = 0, l = 7, p = 4;
  for (n === 0 && (l = 138, p = 3), i = 0; i <= r; i++)
    if (s = n, n = t[(i + 1) * 2 + 1], !(++o < l && s === n)) {
      if (o < p)
        do
          zt(e, s, e.bl_tree);
        while (--o !== 0);
      else s !== 0 ? (s !== a && (zt(e, s, e.bl_tree), o--), zt(e, Mp, e.bl_tree), dt(e, o - 3, 2)) : o <= 10 ? (zt(e, qp, e.bl_tree), dt(e, o - 3, 3)) : (zt(e, Kp, e.bl_tree), dt(e, o - 11, 7));
      o = 0, a = s, n === 0 ? (l = 138, p = 3) : s === n ? (l = 6, p = 3) : (l = 7, p = 4);
    }
}
function Lh(e) {
  var t;
  for (Jo(e, e.dyn_ltree, e.l_desc.max_code), Jo(e, e.dyn_dtree, e.d_desc.max_code), Ha(e, e.bl_desc), t = fo - 1; t >= 3 && e.bl_tree[zp[t] * 2 + 1] === 0; t--)
    ;
  return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
}
function Rh(e, t, r, i) {
  var a;
  for (dt(e, t - 257, 5), dt(e, r - 1, 5), dt(e, i - 4, 4), a = 0; a < i; a++)
    dt(e, e.bl_tree[zp[a] * 2 + 1], 3);
  Qo(e, e.dyn_ltree, t - 1), Qo(e, e.dyn_dtree, r - 1);
}
function $h(e) {
  var t = 4093624447, r;
  for (r = 0; r <= 31; r++, t >>>= 1)
    if (t & 1 && e.dyn_ltree[r * 2] !== 0)
      return Vo;
  if (e.dyn_ltree[9 * 2] !== 0 || e.dyn_ltree[10 * 2] !== 0 || e.dyn_ltree[13 * 2] !== 0)
    return Zo;
  for (r = 32; r < Zn; r++)
    if (e.dyn_ltree[r * 2] !== 0)
      return Zo;
  return Vo;
}
var el = !1;
function Ih(e) {
  el || (Oh(), el = !0), e.l_desc = new Ci(e.dyn_ltree, Gp), e.d_desc = new Ci(e.dyn_dtree, Vp), e.bl_desc = new Ci(e.bl_tree, Zp), e.bi_buf = 0, e.bi_valid = 0, Qp(e);
}
function tc(e, t, r, i) {
  dt(e, (bh << 1) + (i ? 1 : 0), 3), Ch(e, t, r);
}
function Dh(e) {
  dt(e, Up << 1, 3), zt(e, po, nr), Ah(e);
}
function Hh(e, t, r, i) {
  var a, s, n = 0;
  e.level > 0 ? (e.strm.data_type === wh && (e.strm.data_type = $h(e)), Ha(e, e.l_desc), Ha(e, e.d_desc), n = Lh(e), a = e.opt_len + 3 + 7 >>> 3, s = e.static_len + 3 + 7 >>> 3, s <= a && (a = s)) : a = s = r + 5, r + 4 <= a && t !== -1 ? tc(e, t, r, i) : e.strategy === gh || s === a ? (dt(e, (Up << 1) + (i ? 1 : 0), 3), Xo(e, nr, An)) : (dt(e, (vh << 1) + (i ? 1 : 0), 3), Rh(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, n + 1), Xo(e, e.dyn_ltree, e.dyn_dtree)), Qp(e), i && ec(e);
}
function Fh(e, t, r) {
  return e.pending_buf[e.d_buf + e.last_lit * 2] = t >>> 8 & 255, e.pending_buf[e.d_buf + e.last_lit * 2 + 1] = t & 255, e.pending_buf[e.l_buf + e.last_lit] = r & 255, e.last_lit++, t === 0 ? e.dyn_ltree[r * 2]++ : (e.matches++, t--, e.dyn_ltree[(Dn[r] + Zn + 1) * 2]++, e.dyn_dtree[Yp(t) * 2]++), e.last_lit === e.lit_bufsize - 1;
}
dn._tr_init = Ih;
dn._tr_stored_block = tc;
dn._tr_flush_block = Hh;
dn._tr_tally = Fh;
dn._tr_align = Dh;
function Bh(e, t, r, i) {
  for (var a = e & 65535 | 0, s = e >>> 16 & 65535 | 0, n = 0; r !== 0; ) {
    n = r > 2e3 ? 2e3 : r, r -= n;
    do
      a = a + t[i++] | 0, s = s + a | 0;
    while (--n);
    a %= 65521, s %= 65521;
  }
  return a | s << 16 | 0;
}
var rc = Bh;
function Nh() {
  for (var e, t = [], r = 0; r < 256; r++) {
    e = r;
    for (var i = 0; i < 8; i++)
      e = e & 1 ? 3988292384 ^ e >>> 1 : e >>> 1;
    t[r] = e;
  }
  return t;
}
var jh = Nh();
function Uh(e, t, r, i) {
  var a = jh, s = i + r;
  e ^= -1;
  for (var n = i; n < s; n++)
    e = e >>> 8 ^ a[(e ^ t[n]) & 255];
  return e ^ -1;
}
var nc = Uh, uo = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
}, at = ar, At = dn, sc = rc, ur = nc, Wh = uo, Ur = 0, Mh = 1, qh = 3, vr = 4, tl = 5, Gt = 0, rl = 1, Tt = -2, Kh = -3, Ri = -5, zh = -1, Gh = 1, fs = 2, Vh = 3, Zh = 4, Yh = 0, Xh = 2, li = 8, Jh = 9, Qh = 15, em = 8, tm = 29, rm = 256, Fa = rm + 1 + tm, nm = 30, sm = 19, im = 2 * Fa + 1, am = 15, _e = 3, wr = 258, Ht = wr + _e + 1, om = 32, fi = 42, Ba = 69, Ts = 73, Os = 91, Cs = 103, Or = 113, En = 666, qe = 1, Yn = 2, Dr = 3, mn = 4, lm = 3;
function br(e, t) {
  return e.msg = Wh[t], t;
}
function nl(e) {
  return (e << 1) - (e > 4 ? 9 : 0);
}
function gr(e) {
  for (var t = e.length; --t >= 0; )
    e[t] = 0;
}
function dr(e) {
  var t = e.state, r = t.pending;
  r > e.avail_out && (r = e.avail_out), r !== 0 && (at.arraySet(e.output, t.pending_buf, t.pending_out, r, e.next_out), e.next_out += r, t.pending_out += r, e.total_out += r, e.avail_out -= r, t.pending -= r, t.pending === 0 && (t.pending_out = 0));
}
function Qe(e, t) {
  At._tr_flush_block(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, dr(e.strm);
}
function Se(e, t) {
  e.pending_buf[e.pending++] = t;
}
function gn(e, t) {
  e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = t & 255;
}
function fm(e, t, r, i) {
  var a = e.avail_in;
  return a > i && (a = i), a === 0 ? 0 : (e.avail_in -= a, at.arraySet(t, e.input, e.next_in, a, r), e.state.wrap === 1 ? e.adler = sc(e.adler, t, a, r) : e.state.wrap === 2 && (e.adler = ur(e.adler, t, a, r)), e.next_in += a, e.total_in += a, a);
}
function ic(e, t) {
  var r = e.max_chain_length, i = e.strstart, a, s, n = e.prev_length, o = e.nice_match, l = e.strstart > e.w_size - Ht ? e.strstart - (e.w_size - Ht) : 0, p = e.window, c = e.w_mask, m = e.prev, h = e.strstart + wr, g = p[i + n - 1], R = p[i + n];
  e.prev_length >= e.good_match && (r >>= 2), o > e.lookahead && (o = e.lookahead);
  do
    if (a = t, !(p[a + n] !== R || p[a + n - 1] !== g || p[a] !== p[i] || p[++a] !== p[i + 1])) {
      i += 2, a++;
      do
        ;
      while (p[++i] === p[++a] && p[++i] === p[++a] && p[++i] === p[++a] && p[++i] === p[++a] && p[++i] === p[++a] && p[++i] === p[++a] && p[++i] === p[++a] && p[++i] === p[++a] && i < h);
      if (s = wr - (h - i), i = h - wr, s > n) {
        if (e.match_start = t, n = s, s >= o)
          break;
        g = p[i + n - 1], R = p[i + n];
      }
    }
  while ((t = m[t & c]) > l && --r !== 0);
  return n <= e.lookahead ? n : e.lookahead;
}
function Hr(e) {
  var t = e.w_size, r, i, a, s, n;
  do {
    if (s = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - Ht)) {
      at.arraySet(e.window, e.window, t, t, 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, i = e.hash_size, r = i;
      do
        a = e.head[--r], e.head[r] = a >= t ? a - t : 0;
      while (--i);
      i = t, r = i;
      do
        a = e.prev[--r], e.prev[r] = a >= t ? a - t : 0;
      while (--i);
      s += t;
    }
    if (e.strm.avail_in === 0)
      break;
    if (i = fm(e.strm, e.window, e.strstart + e.lookahead, s), e.lookahead += i, e.lookahead + e.insert >= _e)
      for (n = e.strstart - e.insert, e.ins_h = e.window[n], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[n + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[n + _e - 1]) & e.hash_mask, e.prev[n & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = n, n++, e.insert--, !(e.lookahead + e.insert < _e)); )
        ;
  } while (e.lookahead < Ht && e.strm.avail_in !== 0);
}
function pm(e, t) {
  var r = 65535;
  for (r > e.pending_buf_size - 5 && (r = e.pending_buf_size - 5); ; ) {
    if (e.lookahead <= 1) {
      if (Hr(e), e.lookahead === 0 && t === Ur)
        return qe;
      if (e.lookahead === 0)
        break;
    }
    e.strstart += e.lookahead, e.lookahead = 0;
    var i = e.block_start + r;
    if ((e.strstart === 0 || e.strstart >= i) && (e.lookahead = e.strstart - i, e.strstart = i, Qe(e, !1), e.strm.avail_out === 0) || e.strstart - e.block_start >= e.w_size - Ht && (Qe(e, !1), e.strm.avail_out === 0))
      return qe;
  }
  return e.insert = 0, t === vr ? (Qe(e, !0), e.strm.avail_out === 0 ? Dr : mn) : (e.strstart > e.block_start && (Qe(e, !1), e.strm.avail_out === 0), qe);
}
function $i(e, t) {
  for (var r, i; ; ) {
    if (e.lookahead < Ht) {
      if (Hr(e), e.lookahead < Ht && t === Ur)
        return qe;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= _e && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + _e - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), r !== 0 && e.strstart - r <= e.w_size - Ht && (e.match_length = ic(e, r)), e.match_length >= _e)
      if (i = At._tr_tally(e, e.strstart - e.match_start, e.match_length - _e), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= _e) {
        e.match_length--;
        do
          e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + _e - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart;
        while (--e.match_length !== 0);
        e.strstart++;
      } else
        e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask;
    else
      i = At._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
    if (i && (Qe(e, !1), e.strm.avail_out === 0))
      return qe;
  }
  return e.insert = e.strstart < _e - 1 ? e.strstart : _e - 1, t === vr ? (Qe(e, !0), e.strm.avail_out === 0 ? Dr : mn) : e.last_lit && (Qe(e, !1), e.strm.avail_out === 0) ? qe : Yn;
}
function qr(e, t) {
  for (var r, i, a; ; ) {
    if (e.lookahead < Ht) {
      if (Hr(e), e.lookahead < Ht && t === Ur)
        return qe;
      if (e.lookahead === 0)
        break;
    }
    if (r = 0, e.lookahead >= _e && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + _e - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = _e - 1, r !== 0 && e.prev_length < e.max_lazy_match && e.strstart - r <= e.w_size - Ht && (e.match_length = ic(e, r), e.match_length <= 5 && (e.strategy === Gh || e.match_length === _e && e.strstart - e.match_start > 4096) && (e.match_length = _e - 1)), e.prev_length >= _e && e.match_length <= e.prev_length) {
      a = e.strstart + e.lookahead - _e, i = At._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - _e), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
      do
        ++e.strstart <= a && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + _e - 1]) & e.hash_mask, r = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart);
      while (--e.prev_length !== 0);
      if (e.match_available = 0, e.match_length = _e - 1, e.strstart++, i && (Qe(e, !1), e.strm.avail_out === 0))
        return qe;
    } else if (e.match_available) {
      if (i = At._tr_tally(e, 0, e.window[e.strstart - 1]), i && Qe(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0)
        return qe;
    } else
      e.match_available = 1, e.strstart++, e.lookahead--;
  }
  return e.match_available && (i = At._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < _e - 1 ? e.strstart : _e - 1, t === vr ? (Qe(e, !0), e.strm.avail_out === 0 ? Dr : mn) : e.last_lit && (Qe(e, !1), e.strm.avail_out === 0) ? qe : Yn;
}
function cm(e, t) {
  for (var r, i, a, s, n = e.window; ; ) {
    if (e.lookahead <= wr) {
      if (Hr(e), e.lookahead <= wr && t === Ur)
        return qe;
      if (e.lookahead === 0)
        break;
    }
    if (e.match_length = 0, e.lookahead >= _e && e.strstart > 0 && (a = e.strstart - 1, i = n[a], i === n[++a] && i === n[++a] && i === n[++a])) {
      s = e.strstart + wr;
      do
        ;
      while (i === n[++a] && i === n[++a] && i === n[++a] && i === n[++a] && i === n[++a] && i === n[++a] && i === n[++a] && i === n[++a] && a < s);
      e.match_length = wr - (s - a), e.match_length > e.lookahead && (e.match_length = e.lookahead);
    }
    if (e.match_length >= _e ? (r = At._tr_tally(e, 1, e.match_length - _e), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (r = At._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), r && (Qe(e, !1), e.strm.avail_out === 0))
      return qe;
  }
  return e.insert = 0, t === vr ? (Qe(e, !0), e.strm.avail_out === 0 ? Dr : mn) : e.last_lit && (Qe(e, !1), e.strm.avail_out === 0) ? qe : Yn;
}
function um(e, t) {
  for (var r; ; ) {
    if (e.lookahead === 0 && (Hr(e), e.lookahead === 0)) {
      if (t === Ur)
        return qe;
      break;
    }
    if (e.match_length = 0, r = At._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, r && (Qe(e, !1), e.strm.avail_out === 0))
      return qe;
  }
  return e.insert = 0, t === vr ? (Qe(e, !0), e.strm.avail_out === 0 ? Dr : mn) : e.last_lit && (Qe(e, !1), e.strm.avail_out === 0) ? qe : Yn;
}
function Nt(e, t, r, i, a) {
  this.good_length = e, this.max_lazy = t, this.nice_length = r, this.max_chain = i, this.func = a;
}
var en;
en = [
  /*      good lazy nice chain */
  new Nt(0, 0, 0, 0, pm),
  /* 0 store only */
  new Nt(4, 4, 8, 4, $i),
  /* 1 max speed, no lazy matches */
  new Nt(4, 5, 16, 8, $i),
  /* 2 */
  new Nt(4, 6, 32, 32, $i),
  /* 3 */
  new Nt(4, 4, 16, 16, qr),
  /* 4 lazy matches */
  new Nt(8, 16, 32, 32, qr),
  /* 5 */
  new Nt(8, 16, 128, 128, qr),
  /* 6 */
  new Nt(8, 32, 128, 256, qr),
  /* 7 */
  new Nt(32, 128, 258, 1024, qr),
  /* 8 */
  new Nt(32, 258, 258, 4096, qr)
  /* 9 max compression */
];
function dm(e) {
  e.window_size = 2 * e.w_size, gr(e.head), e.max_lazy_match = en[e.level].max_lazy, e.good_match = en[e.level].good_length, e.nice_match = en[e.level].nice_length, e.max_chain_length = en[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = _e - 1, e.match_available = 0, e.ins_h = 0;
}
function hm() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = li, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new at.Buf16(im * 2), this.dyn_dtree = new at.Buf16((2 * nm + 1) * 2), this.bl_tree = new at.Buf16((2 * sm + 1) * 2), gr(this.dyn_ltree), gr(this.dyn_dtree), gr(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new at.Buf16(am + 1), this.heap = new at.Buf16(2 * Fa + 1), gr(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new at.Buf16(2 * Fa + 1), gr(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
function ac(e) {
  var t;
  return !e || !e.state ? br(e, Tt) : (e.total_in = e.total_out = 0, e.data_type = Xh, t = e.state, t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? fi : Or, e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = Ur, At._tr_init(t), Gt);
}
function oc(e) {
  var t = ac(e);
  return t === Gt && dm(e.state), t;
}
function mm(e, t) {
  return !e || !e.state || e.state.wrap !== 2 ? Tt : (e.state.gzhead = t, Gt);
}
function lc(e, t, r, i, a, s) {
  if (!e)
    return Tt;
  var n = 1;
  if (t === zh && (t = 6), i < 0 ? (n = 0, i = -i) : i > 15 && (n = 2, i -= 16), a < 1 || a > Jh || r !== li || i < 8 || i > 15 || t < 0 || t > 9 || s < 0 || s > Zh)
    return br(e, Tt);
  i === 8 && (i = 9);
  var o = new hm();
  return e.state = o, o.strm = e, o.wrap = n, o.gzhead = null, o.w_bits = i, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = a + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + _e - 1) / _e), o.window = new at.Buf8(o.w_size * 2), o.head = new at.Buf16(o.hash_size), o.prev = new at.Buf16(o.w_size), o.lit_bufsize = 1 << a + 6, o.pending_buf_size = o.lit_bufsize * 4, o.pending_buf = new at.Buf8(o.pending_buf_size), o.d_buf = 1 * o.lit_bufsize, o.l_buf = 3 * o.lit_bufsize, o.level = t, o.strategy = s, o.method = r, oc(e);
}
function ym(e, t) {
  return lc(e, t, li, Qh, em, Yh);
}
function _m(e, t) {
  var r, i, a, s;
  if (!e || !e.state || t > tl || t < 0)
    return e ? br(e, Tt) : Tt;
  if (i = e.state, !e.output || !e.input && e.avail_in !== 0 || i.status === En && t !== vr)
    return br(e, e.avail_out === 0 ? Ri : Tt);
  if (i.strm = e, r = i.last_flush, i.last_flush = t, i.status === fi)
    if (i.wrap === 2)
      e.adler = 0, Se(i, 31), Se(i, 139), Se(i, 8), i.gzhead ? (Se(
        i,
        (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)
      ), Se(i, i.gzhead.time & 255), Se(i, i.gzhead.time >> 8 & 255), Se(i, i.gzhead.time >> 16 & 255), Se(i, i.gzhead.time >> 24 & 255), Se(i, i.level === 9 ? 2 : i.strategy >= fs || i.level < 2 ? 4 : 0), Se(i, i.gzhead.os & 255), i.gzhead.extra && i.gzhead.extra.length && (Se(i, i.gzhead.extra.length & 255), Se(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (e.adler = ur(e.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = Ba) : (Se(i, 0), Se(i, 0), Se(i, 0), Se(i, 0), Se(i, 0), Se(i, i.level === 9 ? 2 : i.strategy >= fs || i.level < 2 ? 4 : 0), Se(i, lm), i.status = Or);
    else {
      var n = li + (i.w_bits - 8 << 4) << 8, o = -1;
      i.strategy >= fs || i.level < 2 ? o = 0 : i.level < 6 ? o = 1 : i.level === 6 ? o = 2 : o = 3, n |= o << 6, i.strstart !== 0 && (n |= om), n += 31 - n % 31, i.status = Or, gn(i, n), i.strstart !== 0 && (gn(i, e.adler >>> 16), gn(i, e.adler & 65535)), e.adler = 1;
    }
  if (i.status === Ba)
    if (i.gzhead.extra) {
      for (a = i.pending; i.gzindex < (i.gzhead.extra.length & 65535) && !(i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > a && (e.adler = ur(e.adler, i.pending_buf, i.pending - a, a)), dr(e), a = i.pending, i.pending === i.pending_buf_size)); )
        Se(i, i.gzhead.extra[i.gzindex] & 255), i.gzindex++;
      i.gzhead.hcrc && i.pending > a && (e.adler = ur(e.adler, i.pending_buf, i.pending - a, a)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = Ts);
    } else
      i.status = Ts;
  if (i.status === Ts)
    if (i.gzhead.name) {
      a = i.pending;
      do {
        if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > a && (e.adler = ur(e.adler, i.pending_buf, i.pending - a, a)), dr(e), a = i.pending, i.pending === i.pending_buf_size)) {
          s = 1;
          break;
        }
        i.gzindex < i.gzhead.name.length ? s = i.gzhead.name.charCodeAt(i.gzindex++) & 255 : s = 0, Se(i, s);
      } while (s !== 0);
      i.gzhead.hcrc && i.pending > a && (e.adler = ur(e.adler, i.pending_buf, i.pending - a, a)), s === 0 && (i.gzindex = 0, i.status = Os);
    } else
      i.status = Os;
  if (i.status === Os)
    if (i.gzhead.comment) {
      a = i.pending;
      do {
        if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > a && (e.adler = ur(e.adler, i.pending_buf, i.pending - a, a)), dr(e), a = i.pending, i.pending === i.pending_buf_size)) {
          s = 1;
          break;
        }
        i.gzindex < i.gzhead.comment.length ? s = i.gzhead.comment.charCodeAt(i.gzindex++) & 255 : s = 0, Se(i, s);
      } while (s !== 0);
      i.gzhead.hcrc && i.pending > a && (e.adler = ur(e.adler, i.pending_buf, i.pending - a, a)), s === 0 && (i.status = Cs);
    } else
      i.status = Cs;
  if (i.status === Cs && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && dr(e), i.pending + 2 <= i.pending_buf_size && (Se(i, e.adler & 255), Se(i, e.adler >> 8 & 255), e.adler = 0, i.status = Or)) : i.status = Or), i.pending !== 0) {
    if (dr(e), e.avail_out === 0)
      return i.last_flush = -1, Gt;
  } else if (e.avail_in === 0 && nl(t) <= nl(r) && t !== vr)
    return br(e, Ri);
  if (i.status === En && e.avail_in !== 0)
    return br(e, Ri);
  if (e.avail_in !== 0 || i.lookahead !== 0 || t !== Ur && i.status !== En) {
    var l = i.strategy === fs ? um(i, t) : i.strategy === Vh ? cm(i, t) : en[i.level].func(i, t);
    if ((l === Dr || l === mn) && (i.status = En), l === qe || l === Dr)
      return e.avail_out === 0 && (i.last_flush = -1), Gt;
    if (l === Yn && (t === Mh ? At._tr_align(i) : t !== tl && (At._tr_stored_block(i, 0, 0, !1), t === qh && (gr(i.head), i.lookahead === 0 && (i.strstart = 0, i.block_start = 0, i.insert = 0))), dr(e), e.avail_out === 0))
      return i.last_flush = -1, Gt;
  }
  return t !== vr ? Gt : i.wrap <= 0 ? rl : (i.wrap === 2 ? (Se(i, e.adler & 255), Se(i, e.adler >> 8 & 255), Se(i, e.adler >> 16 & 255), Se(i, e.adler >> 24 & 255), Se(i, e.total_in & 255), Se(i, e.total_in >> 8 & 255), Se(i, e.total_in >> 16 & 255), Se(i, e.total_in >> 24 & 255)) : (gn(i, e.adler >>> 16), gn(i, e.adler & 65535)), dr(e), i.wrap > 0 && (i.wrap = -i.wrap), i.pending !== 0 ? Gt : rl);
}
function gm(e) {
  var t;
  return !e || !e.state ? Tt : (t = e.state.status, t !== fi && t !== Ba && t !== Ts && t !== Os && t !== Cs && t !== Or && t !== En ? br(e, Tt) : (e.state = null, t === Or ? br(e, Kh) : Gt));
}
function wm(e, t) {
  var r = t.length, i, a, s, n, o, l, p, c;
  if (!e || !e.state || (i = e.state, n = i.wrap, n === 2 || n === 1 && i.status !== fi || i.lookahead))
    return Tt;
  for (n === 1 && (e.adler = sc(e.adler, t, r, 0)), i.wrap = 0, r >= i.w_size && (n === 0 && (gr(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0), c = new at.Buf8(i.w_size), at.arraySet(c, t, r - i.w_size, i.w_size, 0), t = c, r = i.w_size), o = e.avail_in, l = e.next_in, p = e.input, e.avail_in = r, e.next_in = 0, e.input = t, Hr(i); i.lookahead >= _e; ) {
    a = i.strstart, s = i.lookahead - (_e - 1);
    do
      i.ins_h = (i.ins_h << i.hash_shift ^ i.window[a + _e - 1]) & i.hash_mask, i.prev[a & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = a, a++;
    while (--s);
    i.strstart = a, i.lookahead = _e - 1, Hr(i);
  }
  return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = _e - 1, i.match_available = 0, e.next_in = l, e.input = p, e.avail_in = o, i.wrap = n, Gt;
}
Xt.deflateInit = ym;
Xt.deflateInit2 = lc;
Xt.deflateReset = oc;
Xt.deflateResetKeep = ac;
Xt.deflateSetHeader = mm;
Xt.deflate = _m;
Xt.deflateEnd = gm;
Xt.deflateSetDictionary = wm;
Xt.deflateInfo = "pako deflate (from Nodeca project)";
var Wr = {}, pi = ar, fc = !0, pc = !0;
try {
  String.fromCharCode.apply(null, [0]);
} catch {
  fc = !1;
}
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  pc = !1;
}
var Fn = new pi.Buf8(256);
for (var lr = 0; lr < 256; lr++)
  Fn[lr] = lr >= 252 ? 6 : lr >= 248 ? 5 : lr >= 240 ? 4 : lr >= 224 ? 3 : lr >= 192 ? 2 : 1;
Fn[254] = Fn[254] = 1;
Wr.string2buf = function(e) {
  var t, r, i, a, s, n = e.length, o = 0;
  for (a = 0; a < n; a++)
    r = e.charCodeAt(a), (r & 64512) === 55296 && a + 1 < n && (i = e.charCodeAt(a + 1), (i & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (i - 56320), a++)), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
  for (t = new pi.Buf8(o), s = 0, a = 0; s < o; a++)
    r = e.charCodeAt(a), (r & 64512) === 55296 && a + 1 < n && (i = e.charCodeAt(a + 1), (i & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (i - 56320), a++)), r < 128 ? t[s++] = r : r < 2048 ? (t[s++] = 192 | r >>> 6, t[s++] = 128 | r & 63) : r < 65536 ? (t[s++] = 224 | r >>> 12, t[s++] = 128 | r >>> 6 & 63, t[s++] = 128 | r & 63) : (t[s++] = 240 | r >>> 18, t[s++] = 128 | r >>> 12 & 63, t[s++] = 128 | r >>> 6 & 63, t[s++] = 128 | r & 63);
  return t;
};
function cc(e, t) {
  if (t < 65534 && (e.subarray && pc || !e.subarray && fc))
    return String.fromCharCode.apply(null, pi.shrinkBuf(e, t));
  for (var r = "", i = 0; i < t; i++)
    r += String.fromCharCode(e[i]);
  return r;
}
Wr.buf2binstring = function(e) {
  return cc(e, e.length);
};
Wr.binstring2buf = function(e) {
  for (var t = new pi.Buf8(e.length), r = 0, i = t.length; r < i; r++)
    t[r] = e.charCodeAt(r);
  return t;
};
Wr.buf2string = function(e, t) {
  var r, i, a, s, n = t || e.length, o = new Array(n * 2);
  for (i = 0, r = 0; r < n; ) {
    if (a = e[r++], a < 128) {
      o[i++] = a;
      continue;
    }
    if (s = Fn[a], s > 4) {
      o[i++] = 65533, r += s - 1;
      continue;
    }
    for (a &= s === 2 ? 31 : s === 3 ? 15 : 7; s > 1 && r < n; )
      a = a << 6 | e[r++] & 63, s--;
    if (s > 1) {
      o[i++] = 65533;
      continue;
    }
    a < 65536 ? o[i++] = a : (a -= 65536, o[i++] = 55296 | a >> 10 & 1023, o[i++] = 56320 | a & 1023);
  }
  return cc(o, i);
};
Wr.utf8border = function(e, t) {
  var r;
  for (t = t || e.length, t > e.length && (t = e.length), r = t - 1; r >= 0 && (e[r] & 192) === 128; )
    r--;
  return r < 0 || r === 0 ? t : r + Fn[e[r]] > t ? r : t;
};
function bm() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
}
var uc = bm, Tn = Xt, On = ar, Na = Wr, ja = uo, vm = uc, dc = Object.prototype.toString, xm = 0, Ii = 4, nn = 0, sl = 1, il = 2, Sm = -1, Em = 0, km = 8;
function Fr(e) {
  if (!(this instanceof Fr)) return new Fr(e);
  this.options = On.assign({
    level: Sm,
    method: km,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Em,
    to: ""
  }, e || {});
  var t = this.options;
  t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new vm(), this.strm.avail_out = 0;
  var r = Tn.deflateInit2(
    this.strm,
    t.level,
    t.method,
    t.windowBits,
    t.memLevel,
    t.strategy
  );
  if (r !== nn)
    throw new Error(ja[r]);
  if (t.header && Tn.deflateSetHeader(this.strm, t.header), t.dictionary) {
    var i;
    if (typeof t.dictionary == "string" ? i = Na.string2buf(t.dictionary) : dc.call(t.dictionary) === "[object ArrayBuffer]" ? i = new Uint8Array(t.dictionary) : i = t.dictionary, r = Tn.deflateSetDictionary(this.strm, i), r !== nn)
      throw new Error(ja[r]);
    this._dict_set = !0;
  }
}
Fr.prototype.push = function(e, t) {
  var r = this.strm, i = this.options.chunkSize, a, s;
  if (this.ended)
    return !1;
  s = t === ~~t ? t : t === !0 ? Ii : xm, typeof e == "string" ? r.input = Na.string2buf(e) : dc.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length;
  do {
    if (r.avail_out === 0 && (r.output = new On.Buf8(i), r.next_out = 0, r.avail_out = i), a = Tn.deflate(r, s), a !== sl && a !== nn)
      return this.onEnd(a), this.ended = !0, !1;
    (r.avail_out === 0 || r.avail_in === 0 && (s === Ii || s === il)) && (this.options.to === "string" ? this.onData(Na.buf2binstring(On.shrinkBuf(r.output, r.next_out))) : this.onData(On.shrinkBuf(r.output, r.next_out)));
  } while ((r.avail_in > 0 || r.avail_out === 0) && a !== sl);
  return s === Ii ? (a = Tn.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === nn) : (s === il && (this.onEnd(nn), r.avail_out = 0), !0);
};
Fr.prototype.onData = function(e) {
  this.chunks.push(e);
};
Fr.prototype.onEnd = function(e) {
  e === nn && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = On.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function ho(e, t) {
  var r = new Fr(t);
  if (r.push(e, !0), r.err)
    throw r.msg || ja[r.err];
  return r.result;
}
function Pm(e, t) {
  return t = t || {}, t.raw = !0, ho(e, t);
}
function Am(e, t) {
  return t = t || {}, t.gzip = !0, ho(e, t);
}
Vn.Deflate = Fr;
Vn.deflate = ho;
Vn.deflateRaw = Pm;
Vn.gzip = Am;
var Xn = {}, Ft = {}, ps = 30, Tm = 12, Om = function(t, r) {
  var i, a, s, n, o, l, p, c, m, h, g, R, y, _, w, C, E, D, T, H, k, A, L, S, P;
  i = t.state, a = t.next_in, S = t.input, s = a + (t.avail_in - 5), n = t.next_out, P = t.output, o = n - (r - t.avail_out), l = n + (t.avail_out - 257), p = i.dmax, c = i.wsize, m = i.whave, h = i.wnext, g = i.window, R = i.hold, y = i.bits, _ = i.lencode, w = i.distcode, C = (1 << i.lenbits) - 1, E = (1 << i.distbits) - 1;
  e:
    do {
      y < 15 && (R += S[a++] << y, y += 8, R += S[a++] << y, y += 8), D = _[R & C];
      t:
        for (; ; ) {
          if (T = D >>> 24, R >>>= T, y -= T, T = D >>> 16 & 255, T === 0)
            P[n++] = D & 65535;
          else if (T & 16) {
            H = D & 65535, T &= 15, T && (y < T && (R += S[a++] << y, y += 8), H += R & (1 << T) - 1, R >>>= T, y -= T), y < 15 && (R += S[a++] << y, y += 8, R += S[a++] << y, y += 8), D = w[R & E];
            r:
              for (; ; ) {
                if (T = D >>> 24, R >>>= T, y -= T, T = D >>> 16 & 255, T & 16) {
                  if (k = D & 65535, T &= 15, y < T && (R += S[a++] << y, y += 8, y < T && (R += S[a++] << y, y += 8)), k += R & (1 << T) - 1, k > p) {
                    t.msg = "invalid distance too far back", i.mode = ps;
                    break e;
                  }
                  if (R >>>= T, y -= T, T = n - o, k > T) {
                    if (T = k - T, T > m && i.sane) {
                      t.msg = "invalid distance too far back", i.mode = ps;
                      break e;
                    }
                    if (A = 0, L = g, h === 0) {
                      if (A += c - T, T < H) {
                        H -= T;
                        do
                          P[n++] = g[A++];
                        while (--T);
                        A = n - k, L = P;
                      }
                    } else if (h < T) {
                      if (A += c + h - T, T -= h, T < H) {
                        H -= T;
                        do
                          P[n++] = g[A++];
                        while (--T);
                        if (A = 0, h < H) {
                          T = h, H -= T;
                          do
                            P[n++] = g[A++];
                          while (--T);
                          A = n - k, L = P;
                        }
                      }
                    } else if (A += h - T, T < H) {
                      H -= T;
                      do
                        P[n++] = g[A++];
                      while (--T);
                      A = n - k, L = P;
                    }
                    for (; H > 2; )
                      P[n++] = L[A++], P[n++] = L[A++], P[n++] = L[A++], H -= 3;
                    H && (P[n++] = L[A++], H > 1 && (P[n++] = L[A++]));
                  } else {
                    A = n - k;
                    do
                      P[n++] = P[A++], P[n++] = P[A++], P[n++] = P[A++], H -= 3;
                    while (H > 2);
                    H && (P[n++] = P[A++], H > 1 && (P[n++] = P[A++]));
                  }
                } else if (T & 64) {
                  t.msg = "invalid distance code", i.mode = ps;
                  break e;
                } else {
                  D = w[(D & 65535) + (R & (1 << T) - 1)];
                  continue r;
                }
                break;
              }
          } else if (T & 64)
            if (T & 32) {
              i.mode = Tm;
              break e;
            } else {
              t.msg = "invalid literal/length code", i.mode = ps;
              break e;
            }
          else {
            D = _[(D & 65535) + (R & (1 << T) - 1)];
            continue t;
          }
          break;
        }
    } while (a < s && n < l);
  H = y >> 3, a -= H, y -= H << 3, R &= (1 << y) - 1, t.next_in = a, t.next_out = n, t.avail_in = a < s ? 5 + (s - a) : 5 - (a - s), t.avail_out = n < l ? 257 + (l - n) : 257 - (n - l), i.hold = R, i.bits = y;
}, al = ar, Kr = 15, ol = 852, ll = 592, fl = 0, Di = 1, pl = 2, Cm = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
], Lm = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
], Rm = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
], $m = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
], Im = function(t, r, i, a, s, n, o, l) {
  var p = l.bits, c = 0, m = 0, h = 0, g = 0, R = 0, y = 0, _ = 0, w = 0, C = 0, E = 0, D, T, H, k, A, L = null, S = 0, P, I = new al.Buf16(Kr + 1), $ = new al.Buf16(Kr + 1), N = null, U = 0, M, Z, z;
  for (c = 0; c <= Kr; c++)
    I[c] = 0;
  for (m = 0; m < a; m++)
    I[r[i + m]]++;
  for (R = p, g = Kr; g >= 1 && I[g] === 0; g--)
    ;
  if (R > g && (R = g), g === 0)
    return s[n++] = 1 << 24 | 64 << 16 | 0, s[n++] = 1 << 24 | 64 << 16 | 0, l.bits = 1, 0;
  for (h = 1; h < g && I[h] === 0; h++)
    ;
  for (R < h && (R = h), w = 1, c = 1; c <= Kr; c++)
    if (w <<= 1, w -= I[c], w < 0)
      return -1;
  if (w > 0 && (t === fl || g !== 1))
    return -1;
  for ($[1] = 0, c = 1; c < Kr; c++)
    $[c + 1] = $[c] + I[c];
  for (m = 0; m < a; m++)
    r[i + m] !== 0 && (o[$[r[i + m]]++] = m);
  if (t === fl ? (L = N = o, P = 19) : t === Di ? (L = Cm, S -= 257, N = Lm, U -= 257, P = 256) : (L = Rm, N = $m, P = -1), E = 0, m = 0, c = h, A = n, y = R, _ = 0, H = -1, C = 1 << R, k = C - 1, t === Di && C > ol || t === pl && C > ll)
    return 1;
  for (; ; ) {
    M = c - _, o[m] < P ? (Z = 0, z = o[m]) : o[m] > P ? (Z = N[U + o[m]], z = L[S + o[m]]) : (Z = 96, z = 0), D = 1 << c - _, T = 1 << y, h = T;
    do
      T -= D, s[A + (E >> _) + T] = M << 24 | Z << 16 | z | 0;
    while (T !== 0);
    for (D = 1 << c - 1; E & D; )
      D >>= 1;
    if (D !== 0 ? (E &= D - 1, E += D) : E = 0, m++, --I[c] === 0) {
      if (c === g)
        break;
      c = r[i + o[m]];
    }
    if (c > R && (E & k) !== H) {
      for (_ === 0 && (_ = R), A += h, y = c - _, w = 1 << y; y + _ < g && (w -= I[y + _], !(w <= 0)); )
        y++, w <<= 1;
      if (C += 1 << y, t === Di && C > ol || t === pl && C > ll)
        return 1;
      H = E & k, s[H] = R << 24 | y << 16 | A - n | 0;
    }
  }
  return E !== 0 && (s[A + E] = c - _ << 24 | 64 << 16 | 0), l.bits = R, 0;
}, vt = ar, Ua = rc, jt = nc, Dm = Om, Cn = Im, Hm = 0, hc = 1, mc = 2, cl = 4, Fm = 5, cs = 6, Br = 0, Bm = 1, Nm = 2, Ot = -2, yc = -3, _c = -4, jm = -5, ul = 8, gc = 1, dl = 2, hl = 3, ml = 4, yl = 5, _l = 6, gl = 7, wl = 8, bl = 9, vl = 10, Gs = 11, er = 12, Hi = 13, xl = 14, Fi = 15, Sl = 16, El = 17, kl = 18, Pl = 19, us = 20, ds = 21, Al = 22, Tl = 23, Ol = 24, Cl = 25, Ll = 26, Bi = 27, Rl = 28, $l = 29, He = 30, wc = 31, Um = 32, Wm = 852, Mm = 592, qm = 15, Km = qm;
function Il(e) {
  return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((e & 65280) << 8) + ((e & 255) << 24);
}
function zm() {
  this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new vt.Buf16(320), this.work = new vt.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
function bc(e) {
  var t;
  return !e || !e.state ? Ot : (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = t.wrap & 1), t.mode = gc, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new vt.Buf32(Wm), t.distcode = t.distdyn = new vt.Buf32(Mm), t.sane = 1, t.back = -1, Br);
}
function vc(e) {
  var t;
  return !e || !e.state ? Ot : (t = e.state, t.wsize = 0, t.whave = 0, t.wnext = 0, bc(e));
}
function xc(e, t) {
  var r, i;
  return !e || !e.state || (i = e.state, t < 0 ? (r = 0, t = -t) : (r = (t >> 4) + 1, t < 48 && (t &= 15)), t && (t < 8 || t > 15)) ? Ot : (i.window !== null && i.wbits !== t && (i.window = null), i.wrap = r, i.wbits = t, vc(e));
}
function Sc(e, t) {
  var r, i;
  return e ? (i = new zm(), e.state = i, i.window = null, r = xc(e, t), r !== Br && (e.state = null), r) : Ot;
}
function Gm(e) {
  return Sc(e, Km);
}
var Dl = !0, Ni, ji;
function Vm(e) {
  if (Dl) {
    var t;
    for (Ni = new vt.Buf32(512), ji = new vt.Buf32(32), t = 0; t < 144; )
      e.lens[t++] = 8;
    for (; t < 256; )
      e.lens[t++] = 9;
    for (; t < 280; )
      e.lens[t++] = 7;
    for (; t < 288; )
      e.lens[t++] = 8;
    for (Cn(hc, e.lens, 0, 288, Ni, 0, e.work, { bits: 9 }), t = 0; t < 32; )
      e.lens[t++] = 5;
    Cn(mc, e.lens, 0, 32, ji, 0, e.work, { bits: 5 }), Dl = !1;
  }
  e.lencode = Ni, e.lenbits = 9, e.distcode = ji, e.distbits = 5;
}
function Ec(e, t, r, i) {
  var a, s = e.state;
  return s.window === null && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new vt.Buf8(s.wsize)), i >= s.wsize ? (vt.arraySet(s.window, t, r - s.wsize, s.wsize, 0), s.wnext = 0, s.whave = s.wsize) : (a = s.wsize - s.wnext, a > i && (a = i), vt.arraySet(s.window, t, r - i, a, s.wnext), i -= a, i ? (vt.arraySet(s.window, t, r - i, i, 0), s.wnext = i, s.whave = s.wsize) : (s.wnext += a, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += a))), 0;
}
function Zm(e, t) {
  var r, i, a, s, n, o, l, p, c, m, h, g, R, y, _ = 0, w, C, E, D, T, H, k, A, L = new vt.Buf8(4), S, P, I = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!e || !e.state || !e.output || !e.input && e.avail_in !== 0)
    return Ot;
  r = e.state, r.mode === er && (r.mode = Hi), n = e.next_out, a = e.output, l = e.avail_out, s = e.next_in, i = e.input, o = e.avail_in, p = r.hold, c = r.bits, m = o, h = l, A = Br;
  e:
    for (; ; )
      switch (r.mode) {
        case gc:
          if (r.wrap === 0) {
            r.mode = Hi;
            break;
          }
          for (; c < 16; ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          if (r.wrap & 2 && p === 35615) {
            r.check = 0, L[0] = p & 255, L[1] = p >>> 8 & 255, r.check = jt(r.check, L, 2, 0), p = 0, c = 0, r.mode = dl;
            break;
          }
          if (r.flags = 0, r.head && (r.head.done = !1), !(r.wrap & 1) || /* check if zlib header allowed */
          (((p & 255) << 8) + (p >> 8)) % 31) {
            e.msg = "incorrect header check", r.mode = He;
            break;
          }
          if ((p & 15) !== ul) {
            e.msg = "unknown compression method", r.mode = He;
            break;
          }
          if (p >>>= 4, c -= 4, k = (p & 15) + 8, r.wbits === 0)
            r.wbits = k;
          else if (k > r.wbits) {
            e.msg = "invalid window size", r.mode = He;
            break;
          }
          r.dmax = 1 << k, e.adler = r.check = 1, r.mode = p & 512 ? vl : er, p = 0, c = 0;
          break;
        case dl:
          for (; c < 16; ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          if (r.flags = p, (r.flags & 255) !== ul) {
            e.msg = "unknown compression method", r.mode = He;
            break;
          }
          if (r.flags & 57344) {
            e.msg = "unknown header flags set", r.mode = He;
            break;
          }
          r.head && (r.head.text = p >> 8 & 1), r.flags & 512 && (L[0] = p & 255, L[1] = p >>> 8 & 255, r.check = jt(r.check, L, 2, 0)), p = 0, c = 0, r.mode = hl;
        case hl:
          for (; c < 32; ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          r.head && (r.head.time = p), r.flags & 512 && (L[0] = p & 255, L[1] = p >>> 8 & 255, L[2] = p >>> 16 & 255, L[3] = p >>> 24 & 255, r.check = jt(r.check, L, 4, 0)), p = 0, c = 0, r.mode = ml;
        case ml:
          for (; c < 16; ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          r.head && (r.head.xflags = p & 255, r.head.os = p >> 8), r.flags & 512 && (L[0] = p & 255, L[1] = p >>> 8 & 255, r.check = jt(r.check, L, 2, 0)), p = 0, c = 0, r.mode = yl;
        case yl:
          if (r.flags & 1024) {
            for (; c < 16; ) {
              if (o === 0)
                break e;
              o--, p += i[s++] << c, c += 8;
            }
            r.length = p, r.head && (r.head.extra_len = p), r.flags & 512 && (L[0] = p & 255, L[1] = p >>> 8 & 255, r.check = jt(r.check, L, 2, 0)), p = 0, c = 0;
          } else r.head && (r.head.extra = null);
          r.mode = _l;
        case _l:
          if (r.flags & 1024 && (g = r.length, g > o && (g = o), g && (r.head && (k = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Array(r.head.extra_len)), vt.arraySet(
            r.head.extra,
            i,
            s,
            // extra field is limited to 65536 bytes
            // - no need for additional size check
            g,
            /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
            k
          )), r.flags & 512 && (r.check = jt(r.check, i, g, s)), o -= g, s += g, r.length -= g), r.length))
            break e;
          r.length = 0, r.mode = gl;
        case gl:
          if (r.flags & 2048) {
            if (o === 0)
              break e;
            g = 0;
            do
              k = i[s + g++], r.head && k && r.length < 65536 && (r.head.name += String.fromCharCode(k));
            while (k && g < o);
            if (r.flags & 512 && (r.check = jt(r.check, i, g, s)), o -= g, s += g, k)
              break e;
          } else r.head && (r.head.name = null);
          r.length = 0, r.mode = wl;
        case wl:
          if (r.flags & 4096) {
            if (o === 0)
              break e;
            g = 0;
            do
              k = i[s + g++], r.head && k && r.length < 65536 && (r.head.comment += String.fromCharCode(k));
            while (k && g < o);
            if (r.flags & 512 && (r.check = jt(r.check, i, g, s)), o -= g, s += g, k)
              break e;
          } else r.head && (r.head.comment = null);
          r.mode = bl;
        case bl:
          if (r.flags & 512) {
            for (; c < 16; ) {
              if (o === 0)
                break e;
              o--, p += i[s++] << c, c += 8;
            }
            if (p !== (r.check & 65535)) {
              e.msg = "header crc mismatch", r.mode = He;
              break;
            }
            p = 0, c = 0;
          }
          r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = er;
          break;
        case vl:
          for (; c < 32; ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          e.adler = r.check = Il(p), p = 0, c = 0, r.mode = Gs;
        case Gs:
          if (r.havedict === 0)
            return e.next_out = n, e.avail_out = l, e.next_in = s, e.avail_in = o, r.hold = p, r.bits = c, Nm;
          e.adler = r.check = 1, r.mode = er;
        case er:
          if (t === Fm || t === cs)
            break e;
        case Hi:
          if (r.last) {
            p >>>= c & 7, c -= c & 7, r.mode = Bi;
            break;
          }
          for (; c < 3; ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          switch (r.last = p & 1, p >>>= 1, c -= 1, p & 3) {
            case 0:
              r.mode = xl;
              break;
            case 1:
              if (Vm(r), r.mode = us, t === cs) {
                p >>>= 2, c -= 2;
                break e;
              }
              break;
            case 2:
              r.mode = El;
              break;
            case 3:
              e.msg = "invalid block type", r.mode = He;
          }
          p >>>= 2, c -= 2;
          break;
        case xl:
          for (p >>>= c & 7, c -= c & 7; c < 32; ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          if ((p & 65535) !== (p >>> 16 ^ 65535)) {
            e.msg = "invalid stored block lengths", r.mode = He;
            break;
          }
          if (r.length = p & 65535, p = 0, c = 0, r.mode = Fi, t === cs)
            break e;
        case Fi:
          r.mode = Sl;
        case Sl:
          if (g = r.length, g) {
            if (g > o && (g = o), g > l && (g = l), g === 0)
              break e;
            vt.arraySet(a, i, s, g, n), o -= g, s += g, l -= g, n += g, r.length -= g;
            break;
          }
          r.mode = er;
          break;
        case El:
          for (; c < 14; ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          if (r.nlen = (p & 31) + 257, p >>>= 5, c -= 5, r.ndist = (p & 31) + 1, p >>>= 5, c -= 5, r.ncode = (p & 15) + 4, p >>>= 4, c -= 4, r.nlen > 286 || r.ndist > 30) {
            e.msg = "too many length or distance symbols", r.mode = He;
            break;
          }
          r.have = 0, r.mode = kl;
        case kl:
          for (; r.have < r.ncode; ) {
            for (; c < 3; ) {
              if (o === 0)
                break e;
              o--, p += i[s++] << c, c += 8;
            }
            r.lens[I[r.have++]] = p & 7, p >>>= 3, c -= 3;
          }
          for (; r.have < 19; )
            r.lens[I[r.have++]] = 0;
          if (r.lencode = r.lendyn, r.lenbits = 7, S = { bits: r.lenbits }, A = Cn(Hm, r.lens, 0, 19, r.lencode, 0, r.work, S), r.lenbits = S.bits, A) {
            e.msg = "invalid code lengths set", r.mode = He;
            break;
          }
          r.have = 0, r.mode = Pl;
        case Pl:
          for (; r.have < r.nlen + r.ndist; ) {
            for (; _ = r.lencode[p & (1 << r.lenbits) - 1], w = _ >>> 24, C = _ >>> 16 & 255, E = _ & 65535, !(w <= c); ) {
              if (o === 0)
                break e;
              o--, p += i[s++] << c, c += 8;
            }
            if (E < 16)
              p >>>= w, c -= w, r.lens[r.have++] = E;
            else {
              if (E === 16) {
                for (P = w + 2; c < P; ) {
                  if (o === 0)
                    break e;
                  o--, p += i[s++] << c, c += 8;
                }
                if (p >>>= w, c -= w, r.have === 0) {
                  e.msg = "invalid bit length repeat", r.mode = He;
                  break;
                }
                k = r.lens[r.have - 1], g = 3 + (p & 3), p >>>= 2, c -= 2;
              } else if (E === 17) {
                for (P = w + 3; c < P; ) {
                  if (o === 0)
                    break e;
                  o--, p += i[s++] << c, c += 8;
                }
                p >>>= w, c -= w, k = 0, g = 3 + (p & 7), p >>>= 3, c -= 3;
              } else {
                for (P = w + 7; c < P; ) {
                  if (o === 0)
                    break e;
                  o--, p += i[s++] << c, c += 8;
                }
                p >>>= w, c -= w, k = 0, g = 11 + (p & 127), p >>>= 7, c -= 7;
              }
              if (r.have + g > r.nlen + r.ndist) {
                e.msg = "invalid bit length repeat", r.mode = He;
                break;
              }
              for (; g--; )
                r.lens[r.have++] = k;
            }
          }
          if (r.mode === He)
            break;
          if (r.lens[256] === 0) {
            e.msg = "invalid code -- missing end-of-block", r.mode = He;
            break;
          }
          if (r.lenbits = 9, S = { bits: r.lenbits }, A = Cn(hc, r.lens, 0, r.nlen, r.lencode, 0, r.work, S), r.lenbits = S.bits, A) {
            e.msg = "invalid literal/lengths set", r.mode = He;
            break;
          }
          if (r.distbits = 6, r.distcode = r.distdyn, S = { bits: r.distbits }, A = Cn(mc, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, S), r.distbits = S.bits, A) {
            e.msg = "invalid distances set", r.mode = He;
            break;
          }
          if (r.mode = us, t === cs)
            break e;
        case us:
          r.mode = ds;
        case ds:
          if (o >= 6 && l >= 258) {
            e.next_out = n, e.avail_out = l, e.next_in = s, e.avail_in = o, r.hold = p, r.bits = c, Dm(e, h), n = e.next_out, a = e.output, l = e.avail_out, s = e.next_in, i = e.input, o = e.avail_in, p = r.hold, c = r.bits, r.mode === er && (r.back = -1);
            break;
          }
          for (r.back = 0; _ = r.lencode[p & (1 << r.lenbits) - 1], w = _ >>> 24, C = _ >>> 16 & 255, E = _ & 65535, !(w <= c); ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          if (C && !(C & 240)) {
            for (D = w, T = C, H = E; _ = r.lencode[H + ((p & (1 << D + T) - 1) >> D)], w = _ >>> 24, C = _ >>> 16 & 255, E = _ & 65535, !(D + w <= c); ) {
              if (o === 0)
                break e;
              o--, p += i[s++] << c, c += 8;
            }
            p >>>= D, c -= D, r.back += D;
          }
          if (p >>>= w, c -= w, r.back += w, r.length = E, C === 0) {
            r.mode = Ll;
            break;
          }
          if (C & 32) {
            r.back = -1, r.mode = er;
            break;
          }
          if (C & 64) {
            e.msg = "invalid literal/length code", r.mode = He;
            break;
          }
          r.extra = C & 15, r.mode = Al;
        case Al:
          if (r.extra) {
            for (P = r.extra; c < P; ) {
              if (o === 0)
                break e;
              o--, p += i[s++] << c, c += 8;
            }
            r.length += p & (1 << r.extra) - 1, p >>>= r.extra, c -= r.extra, r.back += r.extra;
          }
          r.was = r.length, r.mode = Tl;
        case Tl:
          for (; _ = r.distcode[p & (1 << r.distbits) - 1], w = _ >>> 24, C = _ >>> 16 & 255, E = _ & 65535, !(w <= c); ) {
            if (o === 0)
              break e;
            o--, p += i[s++] << c, c += 8;
          }
          if (!(C & 240)) {
            for (D = w, T = C, H = E; _ = r.distcode[H + ((p & (1 << D + T) - 1) >> D)], w = _ >>> 24, C = _ >>> 16 & 255, E = _ & 65535, !(D + w <= c); ) {
              if (o === 0)
                break e;
              o--, p += i[s++] << c, c += 8;
            }
            p >>>= D, c -= D, r.back += D;
          }
          if (p >>>= w, c -= w, r.back += w, C & 64) {
            e.msg = "invalid distance code", r.mode = He;
            break;
          }
          r.offset = E, r.extra = C & 15, r.mode = Ol;
        case Ol:
          if (r.extra) {
            for (P = r.extra; c < P; ) {
              if (o === 0)
                break e;
              o--, p += i[s++] << c, c += 8;
            }
            r.offset += p & (1 << r.extra) - 1, p >>>= r.extra, c -= r.extra, r.back += r.extra;
          }
          if (r.offset > r.dmax) {
            e.msg = "invalid distance too far back", r.mode = He;
            break;
          }
          r.mode = Cl;
        case Cl:
          if (l === 0)
            break e;
          if (g = h - l, r.offset > g) {
            if (g = r.offset - g, g > r.whave && r.sane) {
              e.msg = "invalid distance too far back", r.mode = He;
              break;
            }
            g > r.wnext ? (g -= r.wnext, R = r.wsize - g) : R = r.wnext - g, g > r.length && (g = r.length), y = r.window;
          } else
            y = a, R = n - r.offset, g = r.length;
          g > l && (g = l), l -= g, r.length -= g;
          do
            a[n++] = y[R++];
          while (--g);
          r.length === 0 && (r.mode = ds);
          break;
        case Ll:
          if (l === 0)
            break e;
          a[n++] = r.length, l--, r.mode = ds;
          break;
        case Bi:
          if (r.wrap) {
            for (; c < 32; ) {
              if (o === 0)
                break e;
              o--, p |= i[s++] << c, c += 8;
            }
            if (h -= l, e.total_out += h, r.total += h, h && (e.adler = r.check = /*UPDATE(state.check, put - _out, _out);*/
            r.flags ? jt(r.check, a, h, n - h) : Ua(r.check, a, h, n - h)), h = l, (r.flags ? p : Il(p)) !== r.check) {
              e.msg = "incorrect data check", r.mode = He;
              break;
            }
            p = 0, c = 0;
          }
          r.mode = Rl;
        case Rl:
          if (r.wrap && r.flags) {
            for (; c < 32; ) {
              if (o === 0)
                break e;
              o--, p += i[s++] << c, c += 8;
            }
            if (p !== (r.total & 4294967295)) {
              e.msg = "incorrect length check", r.mode = He;
              break;
            }
            p = 0, c = 0;
          }
          r.mode = $l;
        case $l:
          A = Bm;
          break e;
        case He:
          A = yc;
          break e;
        case wc:
          return _c;
        case Um:
        default:
          return Ot;
      }
  return e.next_out = n, e.avail_out = l, e.next_in = s, e.avail_in = o, r.hold = p, r.bits = c, (r.wsize || h !== e.avail_out && r.mode < He && (r.mode < Bi || t !== cl)) && Ec(e, e.output, e.next_out, h - e.avail_out), m -= e.avail_in, h -= e.avail_out, e.total_in += m, e.total_out += h, r.total += h, r.wrap && h && (e.adler = r.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
  r.flags ? jt(r.check, a, h, e.next_out - h) : Ua(r.check, a, h, e.next_out - h)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === er ? 128 : 0) + (r.mode === us || r.mode === Fi ? 256 : 0), (m === 0 && h === 0 || t === cl) && A === Br && (A = jm), A;
}
function Ym(e) {
  if (!e || !e.state)
    return Ot;
  var t = e.state;
  return t.window && (t.window = null), e.state = null, Br;
}
function Xm(e, t) {
  var r;
  return !e || !e.state || (r = e.state, !(r.wrap & 2)) ? Ot : (r.head = t, t.done = !1, Br);
}
function Jm(e, t) {
  var r = t.length, i, a, s;
  return !e || !e.state || (i = e.state, i.wrap !== 0 && i.mode !== Gs) ? Ot : i.mode === Gs && (a = 1, a = Ua(a, t, r, 0), a !== i.check) ? yc : (s = Ec(e, t, r, r), s ? (i.mode = wc, _c) : (i.havedict = 1, Br));
}
Ft.inflateReset = vc;
Ft.inflateReset2 = xc;
Ft.inflateResetKeep = bc;
Ft.inflateInit = Gm;
Ft.inflateInit2 = Sc;
Ft.inflate = Zm;
Ft.inflateEnd = Ym;
Ft.inflateGetHeader = Xm;
Ft.inflateSetDictionary = Jm;
Ft.inflateInfo = "pako inflate (from Nodeca project)";
var kc = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
function Qm() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
}
var ey = Qm, sn = Ft, Ln = ar, Ls = Wr, Ne = kc, Wa = uo, ty = uc, ry = ey, Pc = Object.prototype.toString;
function Nr(e) {
  if (!(this instanceof Nr)) return new Nr(e);
  this.options = Ln.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, e || {});
  var t = this.options;
  t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, t.windowBits === 0 && (t.windowBits = -15)), t.windowBits >= 0 && t.windowBits < 16 && !(e && e.windowBits) && (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && (t.windowBits & 15 || (t.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ty(), this.strm.avail_out = 0;
  var r = sn.inflateInit2(
    this.strm,
    t.windowBits
  );
  if (r !== Ne.Z_OK)
    throw new Error(Wa[r]);
  if (this.header = new ry(), sn.inflateGetHeader(this.strm, this.header), t.dictionary && (typeof t.dictionary == "string" ? t.dictionary = Ls.string2buf(t.dictionary) : Pc.call(t.dictionary) === "[object ArrayBuffer]" && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (r = sn.inflateSetDictionary(this.strm, t.dictionary), r !== Ne.Z_OK)))
    throw new Error(Wa[r]);
}
Nr.prototype.push = function(e, t) {
  var r = this.strm, i = this.options.chunkSize, a = this.options.dictionary, s, n, o, l, p, c = !1;
  if (this.ended)
    return !1;
  n = t === ~~t ? t : t === !0 ? Ne.Z_FINISH : Ne.Z_NO_FLUSH, typeof e == "string" ? r.input = Ls.binstring2buf(e) : Pc.call(e) === "[object ArrayBuffer]" ? r.input = new Uint8Array(e) : r.input = e, r.next_in = 0, r.avail_in = r.input.length;
  do {
    if (r.avail_out === 0 && (r.output = new Ln.Buf8(i), r.next_out = 0, r.avail_out = i), s = sn.inflate(r, Ne.Z_NO_FLUSH), s === Ne.Z_NEED_DICT && a && (s = sn.inflateSetDictionary(this.strm, a)), s === Ne.Z_BUF_ERROR && c === !0 && (s = Ne.Z_OK, c = !1), s !== Ne.Z_STREAM_END && s !== Ne.Z_OK)
      return this.onEnd(s), this.ended = !0, !1;
    r.next_out && (r.avail_out === 0 || s === Ne.Z_STREAM_END || r.avail_in === 0 && (n === Ne.Z_FINISH || n === Ne.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (o = Ls.utf8border(r.output, r.next_out), l = r.next_out - o, p = Ls.buf2string(r.output, o), r.next_out = l, r.avail_out = i - l, l && Ln.arraySet(r.output, r.output, o, l, 0), this.onData(p)) : this.onData(Ln.shrinkBuf(r.output, r.next_out))), r.avail_in === 0 && r.avail_out === 0 && (c = !0);
  } while ((r.avail_in > 0 || r.avail_out === 0) && s !== Ne.Z_STREAM_END);
  return s === Ne.Z_STREAM_END && (n = Ne.Z_FINISH), n === Ne.Z_FINISH ? (s = sn.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, s === Ne.Z_OK) : (n === Ne.Z_SYNC_FLUSH && (this.onEnd(Ne.Z_OK), r.avail_out = 0), !0);
};
Nr.prototype.onData = function(e) {
  this.chunks.push(e);
};
Nr.prototype.onEnd = function(e) {
  e === Ne.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Ln.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
};
function mo(e, t) {
  var r = new Nr(t);
  if (r.push(e, !0), r.err)
    throw r.msg || Wa[r.err];
  return r.result;
}
function ny(e, t) {
  return t = t || {}, t.raw = !0, mo(e, t);
}
Xn.Inflate = Nr;
Xn.inflate = mo;
Xn.inflateRaw = ny;
Xn.ungzip = mo;
var sy = ar.assign, iy = Vn, ay = Xn, oy = kc, Ac = {};
sy(Ac, iy, ay, oy);
var ly = Ac;
const yo = /* @__PURE__ */ to(ly);
async function fy(e, t) {
  const r = new Hp(e);
  let i = await r.read(4);
  if (i = i.toString("utf8"), i !== "PACK")
    throw new ke(`Invalid PACK header '${i}'`);
  let a = await r.read(4);
  if (a = a.readUInt32BE(0), a !== 2)
    throw new ke(`Invalid packfile version: ${a}`);
  let s = await r.read(4);
  if (s = s.readUInt32BE(0), !(s < 1))
    for (; !r.eof() && s--; ) {
      const n = r.tell(), { type: o, length: l, ofs: p, reference: c } = await py(r), m = new yo.Inflate();
      for (; !m.result; ) {
        const h = await r.chunk();
        if (!h) break;
        if (m.push(h, !1), m.err)
          throw new ke(`Pako error: ${m.msg}`);
        if (m.result) {
          if (m.result.length !== l)
            throw new ke(
              "Inflated object size is different from that stated in packfile."
            );
          await r.undo(), await r.read(h.length - m.strm.avail_in);
          const g = r.tell();
          await t({
            data: m.result,
            type: o,
            num: s,
            offset: n,
            end: g,
            reference: c,
            ofs: p
          });
        }
      }
    }
}
async function py(e) {
  let t = await e.byte();
  const r = t >> 4 & 7;
  let i = t & 15;
  if (t & 128) {
    let n = 4;
    do
      t = await e.byte(), i |= (t & 127) << n, n += 7;
    while (t & 128);
  }
  let a, s;
  if (r === 6) {
    let n = 0;
    a = 0;
    const o = [];
    do
      t = await e.byte(), a |= (t & 127) << n, n += 7, o.push(t);
    while (t & 128);
    s = Buffer.from(o);
  }
  return r === 7 && (s = await e.read(20)), { type: r, length: i, ofs: a, reference: s };
}
async function cy(e) {
  return yo.inflate(e);
}
var Ma = { exports: {} };
typeof Object.create == "function" ? Ma.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Ma.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var i = function() {
    };
    i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
  }
};
var uy = Ma.exports, qa = { exports: {} }, _o = {}, ci = {};
ci.byteLength = my;
ci.toByteArray = _y;
ci.fromByteArray = by;
var Vt = [], kt = [], dy = typeof Uint8Array < "u" ? Uint8Array : Array, Ui = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var zr = 0, hy = Ui.length; zr < hy; ++zr)
  Vt[zr] = Ui[zr], kt[Ui.charCodeAt(zr)] = zr;
kt[45] = 62;
kt[95] = 63;
function Tc(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var i = r === t ? 0 : 4 - r % 4;
  return [r, i];
}
function my(e) {
  var t = Tc(e), r = t[0], i = t[1];
  return (r + i) * 3 / 4 - i;
}
function yy(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function _y(e) {
  var t, r = Tc(e), i = r[0], a = r[1], s = new dy(yy(e, i, a)), n = 0, o = a > 0 ? i - 4 : i, l;
  for (l = 0; l < o; l += 4)
    t = kt[e.charCodeAt(l)] << 18 | kt[e.charCodeAt(l + 1)] << 12 | kt[e.charCodeAt(l + 2)] << 6 | kt[e.charCodeAt(l + 3)], s[n++] = t >> 16 & 255, s[n++] = t >> 8 & 255, s[n++] = t & 255;
  return a === 2 && (t = kt[e.charCodeAt(l)] << 2 | kt[e.charCodeAt(l + 1)] >> 4, s[n++] = t & 255), a === 1 && (t = kt[e.charCodeAt(l)] << 10 | kt[e.charCodeAt(l + 1)] << 4 | kt[e.charCodeAt(l + 2)] >> 2, s[n++] = t >> 8 & 255, s[n++] = t & 255), s;
}
function gy(e) {
  return Vt[e >> 18 & 63] + Vt[e >> 12 & 63] + Vt[e >> 6 & 63] + Vt[e & 63];
}
function wy(e, t, r) {
  for (var i, a = [], s = t; s < r; s += 3)
    i = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), a.push(gy(i));
  return a.join("");
}
function by(e) {
  for (var t, r = e.length, i = r % 3, a = [], s = 16383, n = 0, o = r - i; n < o; n += s)
    a.push(wy(e, n, n + s > o ? o : n + s));
  return i === 1 ? (t = e[r - 1], a.push(
    Vt[t >> 2] + Vt[t << 4 & 63] + "=="
  )) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], a.push(
    Vt[t >> 10] + Vt[t >> 4 & 63] + Vt[t << 2 & 63] + "="
  )), a.join("");
}
var go = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
go.read = function(e, t, r, i, a) {
  var s, n, o = a * 8 - i - 1, l = (1 << o) - 1, p = l >> 1, c = -7, m = r ? a - 1 : 0, h = r ? -1 : 1, g = e[t + m];
  for (m += h, s = g & (1 << -c) - 1, g >>= -c, c += o; c > 0; s = s * 256 + e[t + m], m += h, c -= 8)
    ;
  for (n = s & (1 << -c) - 1, s >>= -c, c += i; c > 0; n = n * 256 + e[t + m], m += h, c -= 8)
    ;
  if (s === 0)
    s = 1 - p;
  else {
    if (s === l)
      return n ? NaN : (g ? -1 : 1) * (1 / 0);
    n = n + Math.pow(2, i), s = s - p;
  }
  return (g ? -1 : 1) * n * Math.pow(2, s - i);
};
go.write = function(e, t, r, i, a, s) {
  var n, o, l, p = s * 8 - a - 1, c = (1 << p) - 1, m = c >> 1, h = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = i ? 0 : s - 1, R = i ? 1 : -1, y = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, n = c) : (n = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -n)) < 1 && (n--, l *= 2), n + m >= 1 ? t += h / l : t += h * Math.pow(2, 1 - m), t * l >= 2 && (n++, l /= 2), n + m >= c ? (o = 0, n = c) : n + m >= 1 ? (o = (t * l - 1) * Math.pow(2, a), n = n + m) : (o = t * Math.pow(2, m - 1) * Math.pow(2, a), n = 0)); a >= 8; e[r + g] = o & 255, g += R, o /= 256, a -= 8)
    ;
  for (n = n << a | o, p += a; p > 0; e[r + g] = n & 255, g += R, n /= 256, p -= 8)
    ;
  e[r + g - R] |= y * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var t = ci, r = go, i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = o, e.SlowBuffer = C, e.INSPECT_MAX_BYTES = 50;
  var a = 2147483647;
  e.kMaxLength = a, o.TYPED_ARRAY_SUPPORT = s(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      var v = new Uint8Array(1), u = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(u, Uint8Array.prototype), Object.setPrototypeOf(v, u), v.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(o.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(o.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (o.isBuffer(this))
        return this.byteOffset;
    }
  });
  function n(v) {
    if (v > a)
      throw new RangeError('The value "' + v + '" is invalid for option "size"');
    var u = new Uint8Array(v);
    return Object.setPrototypeOf(u, o.prototype), u;
  }
  function o(v, u, d) {
    if (typeof v == "number") {
      if (typeof u == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return m(v);
    }
    return l(v, u, d);
  }
  o.poolSize = 8192;
  function l(v, u, d) {
    if (typeof v == "string")
      return h(v, u);
    if (ArrayBuffer.isView(v))
      return R(v);
    if (v == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof v
      );
    if (De(v, ArrayBuffer) || v && De(v.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (De(v, SharedArrayBuffer) || v && De(v.buffer, SharedArrayBuffer)))
      return y(v, u, d);
    if (typeof v == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var O = v.valueOf && v.valueOf();
    if (O != null && O !== v)
      return o.from(O, u, d);
    var B = _(v);
    if (B) return B;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof v[Symbol.toPrimitive] == "function")
      return o.from(
        v[Symbol.toPrimitive]("string"),
        u,
        d
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof v
    );
  }
  o.from = function(v, u, d) {
    return l(v, u, d);
  }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
  function p(v) {
    if (typeof v != "number")
      throw new TypeError('"size" argument must be of type number');
    if (v < 0)
      throw new RangeError('The value "' + v + '" is invalid for option "size"');
  }
  function c(v, u, d) {
    return p(v), v <= 0 ? n(v) : u !== void 0 ? typeof d == "string" ? n(v).fill(u, d) : n(v).fill(u) : n(v);
  }
  o.alloc = function(v, u, d) {
    return c(v, u, d);
  };
  function m(v) {
    return p(v), n(v < 0 ? 0 : w(v) | 0);
  }
  o.allocUnsafe = function(v) {
    return m(v);
  }, o.allocUnsafeSlow = function(v) {
    return m(v);
  };
  function h(v, u) {
    if ((typeof u != "string" || u === "") && (u = "utf8"), !o.isEncoding(u))
      throw new TypeError("Unknown encoding: " + u);
    var d = E(v, u) | 0, O = n(d), B = O.write(v, u);
    return B !== d && (O = O.slice(0, B)), O;
  }
  function g(v) {
    for (var u = v.length < 0 ? 0 : w(v.length) | 0, d = n(u), O = 0; O < u; O += 1)
      d[O] = v[O] & 255;
    return d;
  }
  function R(v) {
    if (De(v, Uint8Array)) {
      var u = new Uint8Array(v);
      return y(u.buffer, u.byteOffset, u.byteLength);
    }
    return g(v);
  }
  function y(v, u, d) {
    if (u < 0 || v.byteLength < u)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (v.byteLength < u + (d || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var O;
    return u === void 0 && d === void 0 ? O = new Uint8Array(v) : d === void 0 ? O = new Uint8Array(v, u) : O = new Uint8Array(v, u, d), Object.setPrototypeOf(O, o.prototype), O;
  }
  function _(v) {
    if (o.isBuffer(v)) {
      var u = w(v.length) | 0, d = n(u);
      return d.length === 0 || v.copy(d, 0, 0, u), d;
    }
    if (v.length !== void 0)
      return typeof v.length != "number" || ft(v.length) ? n(0) : g(v);
    if (v.type === "Buffer" && Array.isArray(v.data))
      return g(v.data);
  }
  function w(v) {
    if (v >= a)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
    return v | 0;
  }
  function C(v) {
    return +v != v && (v = 0), o.alloc(+v);
  }
  o.isBuffer = function(u) {
    return u != null && u._isBuffer === !0 && u !== o.prototype;
  }, o.compare = function(u, d) {
    if (De(u, Uint8Array) && (u = o.from(u, u.offset, u.byteLength)), De(d, Uint8Array) && (d = o.from(d, d.offset, d.byteLength)), !o.isBuffer(u) || !o.isBuffer(d))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (u === d) return 0;
    for (var O = u.length, B = d.length, K = 0, X = Math.min(O, B); K < X; ++K)
      if (u[K] !== d[K]) {
        O = u[K], B = d[K];
        break;
      }
    return O < B ? -1 : B < O ? 1 : 0;
  }, o.isEncoding = function(u) {
    switch (String(u).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, o.concat = function(u, d) {
    if (!Array.isArray(u))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (u.length === 0)
      return o.alloc(0);
    var O;
    if (d === void 0)
      for (d = 0, O = 0; O < u.length; ++O)
        d += u[O].length;
    var B = o.allocUnsafe(d), K = 0;
    for (O = 0; O < u.length; ++O) {
      var X = u[O];
      if (De(X, Uint8Array))
        K + X.length > B.length ? o.from(X).copy(B, K) : Uint8Array.prototype.set.call(
          B,
          X,
          K
        );
      else if (o.isBuffer(X))
        X.copy(B, K);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      K += X.length;
    }
    return B;
  };
  function E(v, u) {
    if (o.isBuffer(v))
      return v.length;
    if (ArrayBuffer.isView(v) || De(v, ArrayBuffer))
      return v.byteLength;
    if (typeof v != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof v
      );
    var d = v.length, O = arguments.length > 2 && arguments[2] === !0;
    if (!O && d === 0) return 0;
    for (var B = !1; ; )
      switch (u) {
        case "ascii":
        case "latin1":
        case "binary":
          return d;
        case "utf8":
        case "utf-8":
          return Oe(v).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return d * 2;
        case "hex":
          return d >>> 1;
        case "base64":
          return St(v).length;
        default:
          if (B)
            return O ? -1 : Oe(v).length;
          u = ("" + u).toLowerCase(), B = !0;
      }
  }
  o.byteLength = E;
  function D(v, u, d) {
    var O = !1;
    if ((u === void 0 || u < 0) && (u = 0), u > this.length || ((d === void 0 || d > this.length) && (d = this.length), d <= 0) || (d >>>= 0, u >>>= 0, d <= u))
      return "";
    for (v || (v = "utf8"); ; )
      switch (v) {
        case "hex":
          return se(this, u, d);
        case "utf8":
        case "utf-8":
          return N(this, u, d);
        case "ascii":
          return Z(this, u, d);
        case "latin1":
        case "binary":
          return z(this, u, d);
        case "base64":
          return $(this, u, d);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return G(this, u, d);
        default:
          if (O) throw new TypeError("Unknown encoding: " + v);
          v = (v + "").toLowerCase(), O = !0;
      }
  }
  o.prototype._isBuffer = !0;
  function T(v, u, d) {
    var O = v[u];
    v[u] = v[d], v[d] = O;
  }
  o.prototype.swap16 = function() {
    var u = this.length;
    if (u % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var d = 0; d < u; d += 2)
      T(this, d, d + 1);
    return this;
  }, o.prototype.swap32 = function() {
    var u = this.length;
    if (u % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var d = 0; d < u; d += 4)
      T(this, d, d + 3), T(this, d + 1, d + 2);
    return this;
  }, o.prototype.swap64 = function() {
    var u = this.length;
    if (u % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var d = 0; d < u; d += 8)
      T(this, d, d + 7), T(this, d + 1, d + 6), T(this, d + 2, d + 5), T(this, d + 3, d + 4);
    return this;
  }, o.prototype.toString = function() {
    var u = this.length;
    return u === 0 ? "" : arguments.length === 0 ? N(this, 0, u) : D.apply(this, arguments);
  }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(u) {
    if (!o.isBuffer(u)) throw new TypeError("Argument must be a Buffer");
    return this === u ? !0 : o.compare(this, u) === 0;
  }, o.prototype.inspect = function() {
    var u = "", d = e.INSPECT_MAX_BYTES;
    return u = this.toString("hex", 0, d).replace(/(.{2})/g, "$1 ").trim(), this.length > d && (u += " ... "), "<Buffer " + u + ">";
  }, i && (o.prototype[i] = o.prototype.inspect), o.prototype.compare = function(u, d, O, B, K) {
    if (De(u, Uint8Array) && (u = o.from(u, u.offset, u.byteLength)), !o.isBuffer(u))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof u
      );
    if (d === void 0 && (d = 0), O === void 0 && (O = u ? u.length : 0), B === void 0 && (B = 0), K === void 0 && (K = this.length), d < 0 || O > u.length || B < 0 || K > this.length)
      throw new RangeError("out of range index");
    if (B >= K && d >= O)
      return 0;
    if (B >= K)
      return -1;
    if (d >= O)
      return 1;
    if (d >>>= 0, O >>>= 0, B >>>= 0, K >>>= 0, this === u) return 0;
    for (var X = K - B, pe = O - d, ge = Math.min(X, pe), he = this.slice(B, K), Be = u.slice(d, O), ue = 0; ue < ge; ++ue)
      if (he[ue] !== Be[ue]) {
        X = he[ue], pe = Be[ue];
        break;
      }
    return X < pe ? -1 : pe < X ? 1 : 0;
  };
  function H(v, u, d, O, B) {
    if (v.length === 0) return -1;
    if (typeof d == "string" ? (O = d, d = 0) : d > 2147483647 ? d = 2147483647 : d < -2147483648 && (d = -2147483648), d = +d, ft(d) && (d = B ? 0 : v.length - 1), d < 0 && (d = v.length + d), d >= v.length) {
      if (B) return -1;
      d = v.length - 1;
    } else if (d < 0)
      if (B) d = 0;
      else return -1;
    if (typeof u == "string" && (u = o.from(u, O)), o.isBuffer(u))
      return u.length === 0 ? -1 : k(v, u, d, O, B);
    if (typeof u == "number")
      return u = u & 255, typeof Uint8Array.prototype.indexOf == "function" ? B ? Uint8Array.prototype.indexOf.call(v, u, d) : Uint8Array.prototype.lastIndexOf.call(v, u, d) : k(v, [u], d, O, B);
    throw new TypeError("val must be string, number or Buffer");
  }
  function k(v, u, d, O, B) {
    var K = 1, X = v.length, pe = u.length;
    if (O !== void 0 && (O = String(O).toLowerCase(), O === "ucs2" || O === "ucs-2" || O === "utf16le" || O === "utf-16le")) {
      if (v.length < 2 || u.length < 2)
        return -1;
      K = 2, X /= 2, pe /= 2, d /= 2;
    }
    function ge(rt, Ct) {
      return K === 1 ? rt[Ct] : rt.readUInt16BE(Ct * K);
    }
    var he;
    if (B) {
      var Be = -1;
      for (he = d; he < X; he++)
        if (ge(v, he) === ge(u, Be === -1 ? 0 : he - Be)) {
          if (Be === -1 && (Be = he), he - Be + 1 === pe) return Be * K;
        } else
          Be !== -1 && (he -= he - Be), Be = -1;
    } else
      for (d + pe > X && (d = X - pe), he = d; he >= 0; he--) {
        for (var ue = !0, ht = 0; ht < pe; ht++)
          if (ge(v, he + ht) !== ge(u, ht)) {
            ue = !1;
            break;
          }
        if (ue) return he;
      }
    return -1;
  }
  o.prototype.includes = function(u, d, O) {
    return this.indexOf(u, d, O) !== -1;
  }, o.prototype.indexOf = function(u, d, O) {
    return H(this, u, d, O, !0);
  }, o.prototype.lastIndexOf = function(u, d, O) {
    return H(this, u, d, O, !1);
  };
  function A(v, u, d, O) {
    d = Number(d) || 0;
    var B = v.length - d;
    O ? (O = Number(O), O > B && (O = B)) : O = B;
    var K = u.length;
    O > K / 2 && (O = K / 2);
    for (var X = 0; X < O; ++X) {
      var pe = parseInt(u.substr(X * 2, 2), 16);
      if (ft(pe)) return X;
      v[d + X] = pe;
    }
    return X;
  }
  function L(v, u, d, O) {
    return Ie(Oe(u, v.length - d), v, d, O);
  }
  function S(v, u, d, O) {
    return Ie(Xe(u), v, d, O);
  }
  function P(v, u, d, O) {
    return Ie(St(u), v, d, O);
  }
  function I(v, u, d, O) {
    return Ie(tt(u, v.length - d), v, d, O);
  }
  o.prototype.write = function(u, d, O, B) {
    if (d === void 0)
      B = "utf8", O = this.length, d = 0;
    else if (O === void 0 && typeof d == "string")
      B = d, O = this.length, d = 0;
    else if (isFinite(d))
      d = d >>> 0, isFinite(O) ? (O = O >>> 0, B === void 0 && (B = "utf8")) : (B = O, O = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var K = this.length - d;
    if ((O === void 0 || O > K) && (O = K), u.length > 0 && (O < 0 || d < 0) || d > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    B || (B = "utf8");
    for (var X = !1; ; )
      switch (B) {
        case "hex":
          return A(this, u, d, O);
        case "utf8":
        case "utf-8":
          return L(this, u, d, O);
        case "ascii":
        case "latin1":
        case "binary":
          return S(this, u, d, O);
        case "base64":
          return P(this, u, d, O);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return I(this, u, d, O);
        default:
          if (X) throw new TypeError("Unknown encoding: " + B);
          B = ("" + B).toLowerCase(), X = !0;
      }
  }, o.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function $(v, u, d) {
    return u === 0 && d === v.length ? t.fromByteArray(v) : t.fromByteArray(v.slice(u, d));
  }
  function N(v, u, d) {
    d = Math.min(v.length, d);
    for (var O = [], B = u; B < d; ) {
      var K = v[B], X = null, pe = K > 239 ? 4 : K > 223 ? 3 : K > 191 ? 2 : 1;
      if (B + pe <= d) {
        var ge, he, Be, ue;
        switch (pe) {
          case 1:
            K < 128 && (X = K);
            break;
          case 2:
            ge = v[B + 1], (ge & 192) === 128 && (ue = (K & 31) << 6 | ge & 63, ue > 127 && (X = ue));
            break;
          case 3:
            ge = v[B + 1], he = v[B + 2], (ge & 192) === 128 && (he & 192) === 128 && (ue = (K & 15) << 12 | (ge & 63) << 6 | he & 63, ue > 2047 && (ue < 55296 || ue > 57343) && (X = ue));
            break;
          case 4:
            ge = v[B + 1], he = v[B + 2], Be = v[B + 3], (ge & 192) === 128 && (he & 192) === 128 && (Be & 192) === 128 && (ue = (K & 15) << 18 | (ge & 63) << 12 | (he & 63) << 6 | Be & 63, ue > 65535 && ue < 1114112 && (X = ue));
        }
      }
      X === null ? (X = 65533, pe = 1) : X > 65535 && (X -= 65536, O.push(X >>> 10 & 1023 | 55296), X = 56320 | X & 1023), O.push(X), B += pe;
    }
    return M(O);
  }
  var U = 4096;
  function M(v) {
    var u = v.length;
    if (u <= U)
      return String.fromCharCode.apply(String, v);
    for (var d = "", O = 0; O < u; )
      d += String.fromCharCode.apply(
        String,
        v.slice(O, O += U)
      );
    return d;
  }
  function Z(v, u, d) {
    var O = "";
    d = Math.min(v.length, d);
    for (var B = u; B < d; ++B)
      O += String.fromCharCode(v[B] & 127);
    return O;
  }
  function z(v, u, d) {
    var O = "";
    d = Math.min(v.length, d);
    for (var B = u; B < d; ++B)
      O += String.fromCharCode(v[B]);
    return O;
  }
  function se(v, u, d) {
    var O = v.length;
    (!u || u < 0) && (u = 0), (!d || d < 0 || d > O) && (d = O);
    for (var B = "", K = u; K < d; ++K)
      B += Le[v[K]];
    return B;
  }
  function G(v, u, d) {
    for (var O = v.slice(u, d), B = "", K = 0; K < O.length - 1; K += 2)
      B += String.fromCharCode(O[K] + O[K + 1] * 256);
    return B;
  }
  o.prototype.slice = function(u, d) {
    var O = this.length;
    u = ~~u, d = d === void 0 ? O : ~~d, u < 0 ? (u += O, u < 0 && (u = 0)) : u > O && (u = O), d < 0 ? (d += O, d < 0 && (d = 0)) : d > O && (d = O), d < u && (d = u);
    var B = this.subarray(u, d);
    return Object.setPrototypeOf(B, o.prototype), B;
  };
  function Q(v, u, d) {
    if (v % 1 !== 0 || v < 0) throw new RangeError("offset is not uint");
    if (v + u > d) throw new RangeError("Trying to access beyond buffer length");
  }
  o.prototype.readUintLE = o.prototype.readUIntLE = function(u, d, O) {
    u = u >>> 0, d = d >>> 0, O || Q(u, d, this.length);
    for (var B = this[u], K = 1, X = 0; ++X < d && (K *= 256); )
      B += this[u + X] * K;
    return B;
  }, o.prototype.readUintBE = o.prototype.readUIntBE = function(u, d, O) {
    u = u >>> 0, d = d >>> 0, O || Q(u, d, this.length);
    for (var B = this[u + --d], K = 1; d > 0 && (K *= 256); )
      B += this[u + --d] * K;
    return B;
  }, o.prototype.readUint8 = o.prototype.readUInt8 = function(u, d) {
    return u = u >>> 0, d || Q(u, 1, this.length), this[u];
  }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(u, d) {
    return u = u >>> 0, d || Q(u, 2, this.length), this[u] | this[u + 1] << 8;
  }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(u, d) {
    return u = u >>> 0, d || Q(u, 2, this.length), this[u] << 8 | this[u + 1];
  }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(u, d) {
    return u = u >>> 0, d || Q(u, 4, this.length), (this[u] | this[u + 1] << 8 | this[u + 2] << 16) + this[u + 3] * 16777216;
  }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(u, d) {
    return u = u >>> 0, d || Q(u, 4, this.length), this[u] * 16777216 + (this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3]);
  }, o.prototype.readIntLE = function(u, d, O) {
    u = u >>> 0, d = d >>> 0, O || Q(u, d, this.length);
    for (var B = this[u], K = 1, X = 0; ++X < d && (K *= 256); )
      B += this[u + X] * K;
    return K *= 128, B >= K && (B -= Math.pow(2, 8 * d)), B;
  }, o.prototype.readIntBE = function(u, d, O) {
    u = u >>> 0, d = d >>> 0, O || Q(u, d, this.length);
    for (var B = d, K = 1, X = this[u + --B]; B > 0 && (K *= 256); )
      X += this[u + --B] * K;
    return K *= 128, X >= K && (X -= Math.pow(2, 8 * d)), X;
  }, o.prototype.readInt8 = function(u, d) {
    return u = u >>> 0, d || Q(u, 1, this.length), this[u] & 128 ? (255 - this[u] + 1) * -1 : this[u];
  }, o.prototype.readInt16LE = function(u, d) {
    u = u >>> 0, d || Q(u, 2, this.length);
    var O = this[u] | this[u + 1] << 8;
    return O & 32768 ? O | 4294901760 : O;
  }, o.prototype.readInt16BE = function(u, d) {
    u = u >>> 0, d || Q(u, 2, this.length);
    var O = this[u + 1] | this[u] << 8;
    return O & 32768 ? O | 4294901760 : O;
  }, o.prototype.readInt32LE = function(u, d) {
    return u = u >>> 0, d || Q(u, 4, this.length), this[u] | this[u + 1] << 8 | this[u + 2] << 16 | this[u + 3] << 24;
  }, o.prototype.readInt32BE = function(u, d) {
    return u = u >>> 0, d || Q(u, 4, this.length), this[u] << 24 | this[u + 1] << 16 | this[u + 2] << 8 | this[u + 3];
  }, o.prototype.readFloatLE = function(u, d) {
    return u = u >>> 0, d || Q(u, 4, this.length), r.read(this, u, !0, 23, 4);
  }, o.prototype.readFloatBE = function(u, d) {
    return u = u >>> 0, d || Q(u, 4, this.length), r.read(this, u, !1, 23, 4);
  }, o.prototype.readDoubleLE = function(u, d) {
    return u = u >>> 0, d || Q(u, 8, this.length), r.read(this, u, !0, 52, 8);
  }, o.prototype.readDoubleBE = function(u, d) {
    return u = u >>> 0, d || Q(u, 8, this.length), r.read(this, u, !1, 52, 8);
  };
  function ee(v, u, d, O, B, K) {
    if (!o.isBuffer(v)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (u > B || u < K) throw new RangeError('"value" argument is out of bounds');
    if (d + O > v.length) throw new RangeError("Index out of range");
  }
  o.prototype.writeUintLE = o.prototype.writeUIntLE = function(u, d, O, B) {
    if (u = +u, d = d >>> 0, O = O >>> 0, !B) {
      var K = Math.pow(2, 8 * O) - 1;
      ee(this, u, d, O, K, 0);
    }
    var X = 1, pe = 0;
    for (this[d] = u & 255; ++pe < O && (X *= 256); )
      this[d + pe] = u / X & 255;
    return d + O;
  }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(u, d, O, B) {
    if (u = +u, d = d >>> 0, O = O >>> 0, !B) {
      var K = Math.pow(2, 8 * O) - 1;
      ee(this, u, d, O, K, 0);
    }
    var X = O - 1, pe = 1;
    for (this[d + X] = u & 255; --X >= 0 && (pe *= 256); )
      this[d + X] = u / pe & 255;
    return d + O;
  }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 1, 255, 0), this[d] = u & 255, d + 1;
  }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 2, 65535, 0), this[d] = u & 255, this[d + 1] = u >>> 8, d + 2;
  }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 2, 65535, 0), this[d] = u >>> 8, this[d + 1] = u & 255, d + 2;
  }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 4, 4294967295, 0), this[d + 3] = u >>> 24, this[d + 2] = u >>> 16, this[d + 1] = u >>> 8, this[d] = u & 255, d + 4;
  }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 4, 4294967295, 0), this[d] = u >>> 24, this[d + 1] = u >>> 16, this[d + 2] = u >>> 8, this[d + 3] = u & 255, d + 4;
  }, o.prototype.writeIntLE = function(u, d, O, B) {
    if (u = +u, d = d >>> 0, !B) {
      var K = Math.pow(2, 8 * O - 1);
      ee(this, u, d, O, K - 1, -K);
    }
    var X = 0, pe = 1, ge = 0;
    for (this[d] = u & 255; ++X < O && (pe *= 256); )
      u < 0 && ge === 0 && this[d + X - 1] !== 0 && (ge = 1), this[d + X] = (u / pe >> 0) - ge & 255;
    return d + O;
  }, o.prototype.writeIntBE = function(u, d, O, B) {
    if (u = +u, d = d >>> 0, !B) {
      var K = Math.pow(2, 8 * O - 1);
      ee(this, u, d, O, K - 1, -K);
    }
    var X = O - 1, pe = 1, ge = 0;
    for (this[d + X] = u & 255; --X >= 0 && (pe *= 256); )
      u < 0 && ge === 0 && this[d + X + 1] !== 0 && (ge = 1), this[d + X] = (u / pe >> 0) - ge & 255;
    return d + O;
  }, o.prototype.writeInt8 = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 1, 127, -128), u < 0 && (u = 255 + u + 1), this[d] = u & 255, d + 1;
  }, o.prototype.writeInt16LE = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 2, 32767, -32768), this[d] = u & 255, this[d + 1] = u >>> 8, d + 2;
  }, o.prototype.writeInt16BE = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 2, 32767, -32768), this[d] = u >>> 8, this[d + 1] = u & 255, d + 2;
  }, o.prototype.writeInt32LE = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 4, 2147483647, -2147483648), this[d] = u & 255, this[d + 1] = u >>> 8, this[d + 2] = u >>> 16, this[d + 3] = u >>> 24, d + 4;
  }, o.prototype.writeInt32BE = function(u, d, O) {
    return u = +u, d = d >>> 0, O || ee(this, u, d, 4, 2147483647, -2147483648), u < 0 && (u = 4294967295 + u + 1), this[d] = u >>> 24, this[d + 1] = u >>> 16, this[d + 2] = u >>> 8, this[d + 3] = u & 255, d + 4;
  };
  function V(v, u, d, O, B, K) {
    if (d + O > v.length) throw new RangeError("Index out of range");
    if (d < 0) throw new RangeError("Index out of range");
  }
  function fe(v, u, d, O, B) {
    return u = +u, d = d >>> 0, B || V(v, u, d, 4), r.write(v, u, d, O, 23, 4), d + 4;
  }
  o.prototype.writeFloatLE = function(u, d, O) {
    return fe(this, u, d, !0, O);
  }, o.prototype.writeFloatBE = function(u, d, O) {
    return fe(this, u, d, !1, O);
  };
  function ie(v, u, d, O, B) {
    return u = +u, d = d >>> 0, B || V(v, u, d, 8), r.write(v, u, d, O, 52, 8), d + 8;
  }
  o.prototype.writeDoubleLE = function(u, d, O) {
    return ie(this, u, d, !0, O);
  }, o.prototype.writeDoubleBE = function(u, d, O) {
    return ie(this, u, d, !1, O);
  }, o.prototype.copy = function(u, d, O, B) {
    if (!o.isBuffer(u)) throw new TypeError("argument should be a Buffer");
    if (O || (O = 0), !B && B !== 0 && (B = this.length), d >= u.length && (d = u.length), d || (d = 0), B > 0 && B < O && (B = O), B === O || u.length === 0 || this.length === 0) return 0;
    if (d < 0)
      throw new RangeError("targetStart out of bounds");
    if (O < 0 || O >= this.length) throw new RangeError("Index out of range");
    if (B < 0) throw new RangeError("sourceEnd out of bounds");
    B > this.length && (B = this.length), u.length - d < B - O && (B = u.length - d + O);
    var K = B - O;
    return this === u && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(d, O, B) : Uint8Array.prototype.set.call(
      u,
      this.subarray(O, B),
      d
    ), K;
  }, o.prototype.fill = function(u, d, O, B) {
    if (typeof u == "string") {
      if (typeof d == "string" ? (B = d, d = 0, O = this.length) : typeof O == "string" && (B = O, O = this.length), B !== void 0 && typeof B != "string")
        throw new TypeError("encoding must be a string");
      if (typeof B == "string" && !o.isEncoding(B))
        throw new TypeError("Unknown encoding: " + B);
      if (u.length === 1) {
        var K = u.charCodeAt(0);
        (B === "utf8" && K < 128 || B === "latin1") && (u = K);
      }
    } else typeof u == "number" ? u = u & 255 : typeof u == "boolean" && (u = Number(u));
    if (d < 0 || this.length < d || this.length < O)
      throw new RangeError("Out of range index");
    if (O <= d)
      return this;
    d = d >>> 0, O = O === void 0 ? this.length : O >>> 0, u || (u = 0);
    var X;
    if (typeof u == "number")
      for (X = d; X < O; ++X)
        this[X] = u;
    else {
      var pe = o.isBuffer(u) ? u : o.from(u, B), ge = pe.length;
      if (ge === 0)
        throw new TypeError('The value "' + u + '" is invalid for argument "value"');
      for (X = 0; X < O - d; ++X)
        this[X + d] = pe[X % ge];
    }
    return this;
  };
  var ae = /[^+/0-9A-Za-z-_]/g;
  function Pe(v) {
    if (v = v.split("=")[0], v = v.trim().replace(ae, ""), v.length < 2) return "";
    for (; v.length % 4 !== 0; )
      v = v + "=";
    return v;
  }
  function Oe(v, u) {
    u = u || 1 / 0;
    for (var d, O = v.length, B = null, K = [], X = 0; X < O; ++X) {
      if (d = v.charCodeAt(X), d > 55295 && d < 57344) {
        if (!B) {
          if (d > 56319) {
            (u -= 3) > -1 && K.push(239, 191, 189);
            continue;
          } else if (X + 1 === O) {
            (u -= 3) > -1 && K.push(239, 191, 189);
            continue;
          }
          B = d;
          continue;
        }
        if (d < 56320) {
          (u -= 3) > -1 && K.push(239, 191, 189), B = d;
          continue;
        }
        d = (B - 55296 << 10 | d - 56320) + 65536;
      } else B && (u -= 3) > -1 && K.push(239, 191, 189);
      if (B = null, d < 128) {
        if ((u -= 1) < 0) break;
        K.push(d);
      } else if (d < 2048) {
        if ((u -= 2) < 0) break;
        K.push(
          d >> 6 | 192,
          d & 63 | 128
        );
      } else if (d < 65536) {
        if ((u -= 3) < 0) break;
        K.push(
          d >> 12 | 224,
          d >> 6 & 63 | 128,
          d & 63 | 128
        );
      } else if (d < 1114112) {
        if ((u -= 4) < 0) break;
        K.push(
          d >> 18 | 240,
          d >> 12 & 63 | 128,
          d >> 6 & 63 | 128,
          d & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return K;
  }
  function Xe(v) {
    for (var u = [], d = 0; d < v.length; ++d)
      u.push(v.charCodeAt(d) & 255);
    return u;
  }
  function tt(v, u) {
    for (var d, O, B, K = [], X = 0; X < v.length && !((u -= 2) < 0); ++X)
      d = v.charCodeAt(X), O = d >> 8, B = d % 256, K.push(B), K.push(O);
    return K;
  }
  function St(v) {
    return t.toByteArray(Pe(v));
  }
  function Ie(v, u, d, O) {
    for (var B = 0; B < O && !(B + d >= u.length || B >= v.length); ++B)
      u[B + d] = v[B];
    return B;
  }
  function De(v, u) {
    return v instanceof u || v != null && v.constructor != null && v.constructor.name != null && v.constructor.name === u.name;
  }
  function ft(v) {
    return v !== v;
  }
  var Le = function() {
    for (var v = "0123456789abcdef", u = new Array(256), d = 0; d < 16; ++d)
      for (var O = d * 16, B = 0; B < 16; ++B)
        u[O + B] = v[d] + v[B];
    return u;
  }();
})(_o);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var r = _o, i = r.Buffer;
  function a(n, o) {
    for (var l in n)
      o[l] = n[l];
  }
  i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = r : (a(r, t), t.Buffer = s);
  function s(n, o, l) {
    return i(n, o, l);
  }
  s.prototype = Object.create(i.prototype), a(i, s), s.from = function(n, o, l) {
    if (typeof n == "number")
      throw new TypeError("Argument must not be a number");
    return i(n, o, l);
  }, s.alloc = function(n, o, l) {
    if (typeof n != "number")
      throw new TypeError("Argument must be a number");
    var p = i(n);
    return o !== void 0 ? typeof l == "string" ? p.fill(o, l) : p.fill(o) : p.fill(0), p;
  }, s.allocUnsafe = function(n) {
    if (typeof n != "number")
      throw new TypeError("Argument must be a number");
    return i(n);
  }, s.allocUnsafeSlow = function(n) {
    if (typeof n != "number")
      throw new TypeError("Argument must be a number");
    return r.SlowBuffer(n);
  };
})(qa, qa.exports);
var wo = qa.exports, vy = {}.toString, xy = Array.isArray || function(e) {
  return vy.call(e) == "[object Array]";
}, Jn = TypeError, Oc = Object, Sy = Error, Ey = EvalError, ky = RangeError, Py = ReferenceError, Cc = SyntaxError, Ay = URIError, Ty = Math.abs, Oy = Math.floor, Cy = Math.max, Ly = Math.min, Ry = Math.pow, $y = Math.round, Iy = Number.isNaN || function(t) {
  return t !== t;
}, Dy = Iy, Hy = function(t) {
  return Dy(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, Fy = Object.getOwnPropertyDescriptor, Rs = Fy;
if (Rs)
  try {
    Rs([], "length");
  } catch {
    Rs = null;
  }
var Qn = Rs, $s = Object.defineProperty || !1;
if ($s)
  try {
    $s({}, "a", { value: 1 });
  } catch {
    $s = !1;
  }
var ui = $s, Wi, Hl;
function Lc() {
  return Hl || (Hl = 1, Wi = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, r = Symbol("test"), i = Object(r);
    if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]")
      return !1;
    var a = 42;
    t[r] = a;
    for (var s in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var n = Object.getOwnPropertySymbols(t);
    if (n.length !== 1 || n[0] !== r || !Object.prototype.propertyIsEnumerable.call(t, r))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, r)
      );
      if (o.value !== a || o.enumerable !== !0)
        return !1;
    }
    return !0;
  }), Wi;
}
var Mi, Fl;
function By() {
  if (Fl) return Mi;
  Fl = 1;
  var e = typeof Symbol < "u" && Symbol, t = Lc();
  return Mi = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Mi;
}
var qi, Bl;
function Rc() {
  return Bl || (Bl = 1, qi = typeof Reflect < "u" && Reflect.getPrototypeOf || null), qi;
}
var Ki, Nl;
function $c() {
  if (Nl) return Ki;
  Nl = 1;
  var e = Oc;
  return Ki = e.getPrototypeOf || null, Ki;
}
var Ny = "Function.prototype.bind called on incompatible ", jy = Object.prototype.toString, Uy = Math.max, Wy = "[object Function]", jl = function(t, r) {
  for (var i = [], a = 0; a < t.length; a += 1)
    i[a] = t[a];
  for (var s = 0; s < r.length; s += 1)
    i[s + t.length] = r[s];
  return i;
}, My = function(t, r) {
  for (var i = [], a = r, s = 0; a < t.length; a += 1, s += 1)
    i[s] = t[a];
  return i;
}, qy = function(e, t) {
  for (var r = "", i = 0; i < e.length; i += 1)
    r += e[i], i + 1 < e.length && (r += t);
  return r;
}, Ky = function(t) {
  var r = this;
  if (typeof r != "function" || jy.apply(r) !== Wy)
    throw new TypeError(Ny + r);
  for (var i = My(arguments, 1), a, s = function() {
    if (this instanceof a) {
      var c = r.apply(
        this,
        jl(i, arguments)
      );
      return Object(c) === c ? c : this;
    }
    return r.apply(
      t,
      jl(i, arguments)
    );
  }, n = Uy(0, r.length - i.length), o = [], l = 0; l < n; l++)
    o[l] = "$" + l;
  if (a = Function("binder", "return function (" + qy(o, ",") + "){ return binder.apply(this,arguments); }")(s), r.prototype) {
    var p = function() {
    };
    p.prototype = r.prototype, a.prototype = new p(), p.prototype = null;
  }
  return a;
}, zy = Ky, es = Function.prototype.bind || zy, bo = Function.prototype.call, zi, Ul;
function vo() {
  return Ul || (Ul = 1, zi = Function.prototype.apply), zi;
}
var Gy = typeof Reflect < "u" && Reflect && Reflect.apply, Vy = es, Zy = vo(), Yy = bo, Xy = Gy, Ic = Xy || Vy.call(Yy, Zy), Jy = es, Qy = Jn, e0 = bo, t0 = Ic, xo = function(t) {
  if (t.length < 1 || typeof t[0] != "function")
    throw new Qy("a function is required");
  return t0(Jy, e0, t);
}, Gi, Wl;
function r0() {
  if (Wl) return Gi;
  Wl = 1;
  var e = xo, t = Qn, r;
  try {
    r = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (n) {
    if (!n || typeof n != "object" || !("code" in n) || n.code !== "ERR_PROTO_ACCESS")
      throw n;
  }
  var i = !!r && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), a = Object, s = a.getPrototypeOf;
  return Gi = i && typeof i.get == "function" ? e([i.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(o) {
      return s(o == null ? o : a(o));
    }
  ) : !1, Gi;
}
var Vi, Ml;
function Dc() {
  if (Ml) return Vi;
  Ml = 1;
  var e = Rc(), t = $c(), r = r0();
  return Vi = e ? function(a) {
    return e(a);
  } : t ? function(a) {
    if (!a || typeof a != "object" && typeof a != "function")
      throw new TypeError("getProto: not an object");
    return t(a);
  } : r ? function(a) {
    return r(a);
  } : null, Vi;
}
var Zi, ql;
function n0() {
  if (ql) return Zi;
  ql = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = es;
  return Zi = r.call(e, t), Zi;
}
var ye, s0 = Oc, i0 = Sy, a0 = Ey, o0 = ky, l0 = Py, fn = Cc, an = Jn, f0 = Ay, p0 = Ty, c0 = Oy, u0 = Cy, d0 = Ly, h0 = Ry, m0 = $y, y0 = Hy, Hc = Function, Yi = function(e) {
  try {
    return Hc('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Bn = Qn, _0 = ui, Xi = function() {
  throw new an();
}, g0 = Bn ? function() {
  try {
    return arguments.callee, Xi;
  } catch {
    try {
      return Bn(arguments, "callee").get;
    } catch {
      return Xi;
    }
  }
}() : Xi, Gr = By()(), Ge = Dc(), w0 = $c(), b0 = Rc(), Fc = vo(), ts = bo, Jr = {}, v0 = typeof Uint8Array > "u" || !Ge ? ye : Ge(Uint8Array), Cr = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? ye : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ye : ArrayBuffer,
  "%ArrayIteratorPrototype%": Gr && Ge ? Ge([][Symbol.iterator]()) : ye,
  "%AsyncFromSyncIteratorPrototype%": ye,
  "%AsyncFunction%": Jr,
  "%AsyncGenerator%": Jr,
  "%AsyncGeneratorFunction%": Jr,
  "%AsyncIteratorPrototype%": Jr,
  "%Atomics%": typeof Atomics > "u" ? ye : Atomics,
  "%BigInt%": typeof BigInt > "u" ? ye : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? ye : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? ye : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? ye : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": i0,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": a0,
  "%Float16Array%": typeof Float16Array > "u" ? ye : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? ye : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? ye : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ye : FinalizationRegistry,
  "%Function%": Hc,
  "%GeneratorFunction%": Jr,
  "%Int8Array%": typeof Int8Array > "u" ? ye : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? ye : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? ye : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Gr && Ge ? Ge(Ge([][Symbol.iterator]())) : ye,
  "%JSON%": typeof JSON == "object" ? JSON : ye,
  "%Map%": typeof Map > "u" ? ye : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Gr || !Ge ? ye : Ge((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": s0,
  "%Object.getOwnPropertyDescriptor%": Bn,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? ye : Promise,
  "%Proxy%": typeof Proxy > "u" ? ye : Proxy,
  "%RangeError%": o0,
  "%ReferenceError%": l0,
  "%Reflect%": typeof Reflect > "u" ? ye : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? ye : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Gr || !Ge ? ye : Ge((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ye : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Gr && Ge ? Ge(""[Symbol.iterator]()) : ye,
  "%Symbol%": Gr ? Symbol : ye,
  "%SyntaxError%": fn,
  "%ThrowTypeError%": g0,
  "%TypedArray%": v0,
  "%TypeError%": an,
  "%Uint8Array%": typeof Uint8Array > "u" ? ye : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ye : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? ye : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? ye : Uint32Array,
  "%URIError%": f0,
  "%WeakMap%": typeof WeakMap > "u" ? ye : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? ye : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? ye : WeakSet,
  "%Function.prototype.call%": ts,
  "%Function.prototype.apply%": Fc,
  "%Object.defineProperty%": _0,
  "%Object.getPrototypeOf%": w0,
  "%Math.abs%": p0,
  "%Math.floor%": c0,
  "%Math.max%": u0,
  "%Math.min%": d0,
  "%Math.pow%": h0,
  "%Math.round%": m0,
  "%Math.sign%": y0,
  "%Reflect.getPrototypeOf%": b0
};
if (Ge)
  try {
    null.error;
  } catch (e) {
    var x0 = Ge(Ge(e));
    Cr["%Error.prototype%"] = x0;
  }
var S0 = function e(t) {
  var r;
  if (t === "%AsyncFunction%")
    r = Yi("async function () {}");
  else if (t === "%GeneratorFunction%")
    r = Yi("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    r = Yi("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var i = e("%AsyncGeneratorFunction%");
    i && (r = i.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var a = e("%AsyncGenerator%");
    a && Ge && (r = Ge(a.prototype));
  }
  return Cr[t] = r, r;
}, Kl = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, rs = es, Vs = n0(), E0 = rs.call(ts, Array.prototype.concat), k0 = rs.call(Fc, Array.prototype.splice), zl = rs.call(ts, String.prototype.replace), Zs = rs.call(ts, String.prototype.slice), P0 = rs.call(ts, RegExp.prototype.exec), A0 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, T0 = /\\(\\)?/g, O0 = function(t) {
  var r = Zs(t, 0, 1), i = Zs(t, -1);
  if (r === "%" && i !== "%")
    throw new fn("invalid intrinsic syntax, expected closing `%`");
  if (i === "%" && r !== "%")
    throw new fn("invalid intrinsic syntax, expected opening `%`");
  var a = [];
  return zl(t, A0, function(s, n, o, l) {
    a[a.length] = o ? zl(l, T0, "$1") : n || s;
  }), a;
}, C0 = function(t, r) {
  var i = t, a;
  if (Vs(Kl, i) && (a = Kl[i], i = "%" + a[0] + "%"), Vs(Cr, i)) {
    var s = Cr[i];
    if (s === Jr && (s = S0(i)), typeof s > "u" && !r)
      throw new an("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: a,
      name: i,
      value: s
    };
  }
  throw new fn("intrinsic " + t + " does not exist!");
}, Bc = function(t, r) {
  if (typeof t != "string" || t.length === 0)
    throw new an("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new an('"allowMissing" argument must be a boolean');
  if (P0(/^%?[^%]*%?$/, t) === null)
    throw new fn("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var i = O0(t), a = i.length > 0 ? i[0] : "", s = C0("%" + a + "%", r), n = s.name, o = s.value, l = !1, p = s.alias;
  p && (a = p[0], k0(i, E0([0, 1], p)));
  for (var c = 1, m = !0; c < i.length; c += 1) {
    var h = i[c], g = Zs(h, 0, 1), R = Zs(h, -1);
    if ((g === '"' || g === "'" || g === "`" || R === '"' || R === "'" || R === "`") && g !== R)
      throw new fn("property names with quotes must have matching quotes");
    if ((h === "constructor" || !m) && (l = !0), a += "." + h, n = "%" + a + "%", Vs(Cr, n))
      o = Cr[n];
    else if (o != null) {
      if (!(h in o)) {
        if (!r)
          throw new an("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Bn && c + 1 >= i.length) {
        var y = Bn(o, h);
        m = !!y, m && "get" in y && !("originalValue" in y.get) ? o = y.get : o = o[h];
      } else
        m = Vs(o, h), o = o[h];
      m && !l && (Cr[n] = o);
    }
  }
  return o;
}, Nc = Bc, jc = xo, L0 = jc([Nc("%String.prototype.indexOf%")]), Uc = function(t, r) {
  var i = (
    /** @type {(this: unknown, ...args: unknown[]) => unknown} */
    Nc(t, !!r)
  );
  return typeof i == "function" && L0(t, ".prototype.") > -1 ? jc(
    /** @type {const} */
    [i]
  ) : i;
}, Ji, Gl;
function R0() {
  if (Gl) return Ji;
  Gl = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, r, i;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      r = Object.defineProperty({}, "length", {
        get: function() {
          throw i;
        }
      }), i = {}, t(function() {
        throw 42;
      }, null, r);
    } catch (C) {
      C !== i && (t = null);
    }
  else
    t = null;
  var a = /^\s*class\b/, s = function(E) {
    try {
      var D = e.call(E);
      return a.test(D);
    } catch {
      return !1;
    }
  }, n = function(E) {
    try {
      return s(E) ? !1 : (e.call(E), !0);
    } catch {
      return !1;
    }
  }, o = Object.prototype.toString, l = "[object Object]", p = "[object Function]", c = "[object GeneratorFunction]", m = "[object HTMLAllCollection]", h = "[object HTML document.all class]", g = "[object HTMLCollection]", R = typeof Symbol == "function" && !!Symbol.toStringTag, y = !(0 in [,]), _ = function() {
    return !1;
  };
  if (typeof document == "object") {
    var w = document.all;
    o.call(w) === o.call(document.all) && (_ = function(E) {
      if ((y || !E) && (typeof E > "u" || typeof E == "object"))
        try {
          var D = o.call(E);
          return (D === m || D === h || D === g || D === l) && E("") == null;
        } catch {
        }
      return !1;
    });
  }
  return Ji = t ? function(E) {
    if (_(E))
      return !0;
    if (!E || typeof E != "function" && typeof E != "object")
      return !1;
    try {
      t(E, null, r);
    } catch (D) {
      if (D !== i)
        return !1;
    }
    return !s(E) && n(E);
  } : function(E) {
    if (_(E))
      return !0;
    if (!E || typeof E != "function" && typeof E != "object")
      return !1;
    if (R)
      return n(E);
    if (s(E))
      return !1;
    var D = o.call(E);
    return D !== p && D !== c && !/^\[object HTML/.test(D) ? !1 : n(E);
  }, Ji;
}
var Qi, Vl;
function $0() {
  if (Vl) return Qi;
  Vl = 1;
  var e = R0(), t = Object.prototype.toString, r = Object.prototype.hasOwnProperty, i = function(l, p, c) {
    for (var m = 0, h = l.length; m < h; m++)
      r.call(l, m) && (c == null ? p(l[m], m, l) : p.call(c, l[m], m, l));
  }, a = function(l, p, c) {
    for (var m = 0, h = l.length; m < h; m++)
      c == null ? p(l.charAt(m), m, l) : p.call(c, l.charAt(m), m, l);
  }, s = function(l, p, c) {
    for (var m in l)
      r.call(l, m) && (c == null ? p(l[m], m, l) : p.call(c, l[m], m, l));
  };
  function n(o) {
    return t.call(o) === "[object Array]";
  }
  return Qi = function(l, p, c) {
    if (!e(p))
      throw new TypeError("iterator must be a function");
    var m;
    arguments.length >= 3 && (m = c), n(l) ? i(l, p, m) : typeof l == "string" ? a(l, p, m) : s(l, p, m);
  }, Qi;
}
var ea, Zl;
function I0() {
  return Zl || (Zl = 1, ea = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), ea;
}
var ta, Yl;
function D0() {
  if (Yl) return ta;
  Yl = 1;
  var e = I0(), t = typeof globalThis > "u" ? Sp : globalThis;
  return ta = function() {
    for (var i = [], a = 0; a < e.length; a++)
      typeof t[e[a]] == "function" && (i[i.length] = e[a]);
    return i;
  }, ta;
}
var ra = { exports: {} }, na, Xl;
function H0() {
  if (Xl) return na;
  Xl = 1;
  var e = ui, t = Cc, r = Jn, i = Qn;
  return na = function(s, n, o) {
    if (!s || typeof s != "object" && typeof s != "function")
      throw new r("`obj` must be an object or a function`");
    if (typeof n != "string" && typeof n != "symbol")
      throw new r("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new r("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new r("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new r("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new r("`loose`, if provided, must be a boolean");
    var l = arguments.length > 3 ? arguments[3] : null, p = arguments.length > 4 ? arguments[4] : null, c = arguments.length > 5 ? arguments[5] : null, m = arguments.length > 6 ? arguments[6] : !1, h = !!i && i(s, n);
    if (e)
      e(s, n, {
        configurable: c === null && h ? h.configurable : !c,
        enumerable: l === null && h ? h.enumerable : !l,
        value: o,
        writable: p === null && h ? h.writable : !p
      });
    else if (m || !l && !p && !c)
      s[n] = o;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, na;
}
var sa, Jl;
function F0() {
  if (Jl) return sa;
  Jl = 1;
  var e = ui, t = function() {
    return !!e;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, sa = t, sa;
}
var ia, Ql;
function B0() {
  if (Ql) return ia;
  Ql = 1;
  var e = Bc, t = H0(), r = F0()(), i = Qn, a = Jn, s = e("%Math.floor%");
  return ia = function(o, l) {
    if (typeof o != "function")
      throw new a("`fn` is not a function");
    if (typeof l != "number" || l < 0 || l > 4294967295 || s(l) !== l)
      throw new a("`length` must be a positive 32-bit integer");
    var p = arguments.length > 2 && !!arguments[2], c = !0, m = !0;
    if ("length" in o && i) {
      var h = i(o, "length");
      h && !h.configurable && (c = !1), h && !h.writable && (m = !1);
    }
    return (c || m || !p) && (r ? t(
      /** @type {Parameters<define>[0]} */
      o,
      "length",
      l,
      !0,
      !0
    ) : t(
      /** @type {Parameters<define>[0]} */
      o,
      "length",
      l
    )), o;
  }, ia;
}
var aa, ef;
function N0() {
  if (ef) return aa;
  ef = 1;
  var e = es, t = vo(), r = Ic;
  return aa = function() {
    return r(e, t, arguments);
  }, aa;
}
var tf;
function j0() {
  return tf || (tf = 1, function(e) {
    var t = B0(), r = ui, i = xo, a = N0();
    e.exports = function(n) {
      var o = i(arguments), l = n.length - (arguments.length - 1);
      return t(
        o,
        1 + (l > 0 ? l : 0),
        !0
      );
    }, r ? r(e.exports, "apply", { value: a }) : e.exports.apply = a;
  }(ra)), ra.exports;
}
var oa, rf;
function U0() {
  if (rf) return oa;
  rf = 1;
  var e = Lc();
  return oa = function() {
    return e() && !!Symbol.toStringTag;
  }, oa;
}
var la, nf;
function W0() {
  if (nf) return la;
  nf = 1;
  var e = $0(), t = D0(), r = j0(), i = Uc, a = Qn, s = Dc(), n = i("Object.prototype.toString"), o = U0()(), l = typeof globalThis > "u" ? Sp : globalThis, p = t(), c = i("String.prototype.slice"), m = i("Array.prototype.indexOf", !0) || function(_, w) {
    for (var C = 0; C < _.length; C += 1)
      if (_[C] === w)
        return C;
    return -1;
  }, h = { __proto__: null };
  o && a && s ? e(p, function(y) {
    var _ = new l[y]();
    if (Symbol.toStringTag in _ && s) {
      var w = s(_), C = a(w, Symbol.toStringTag);
      if (!C && w) {
        var E = s(w);
        C = a(E, Symbol.toStringTag);
      }
      h["$" + y] = r(C.get);
    }
  }) : e(p, function(y) {
    var _ = new l[y](), w = _.slice || _.set;
    w && (h[
      /** @type {`$${import('.').TypedArrayName}`} */
      "$" + y
    ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
    // @ts-expect-error TODO FIXME
    r(w));
  });
  var g = function(_) {
    var w = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      h,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(C, E) {
        if (!w)
          try {
            "$" + C(_) === E && (w = /** @type {import('.').TypedArrayName} */
            c(E, 1));
          } catch {
          }
      }
    ), w;
  }, R = function(_) {
    var w = !1;
    return e(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      h,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(C, E) {
        if (!w)
          try {
            C(_), w = /** @type {import('.').TypedArrayName} */
            c(E, 1);
          } catch {
          }
      }
    ), w;
  };
  return la = function(_) {
    if (!_ || typeof _ != "object")
      return !1;
    if (!o) {
      var w = c(n(_), 8, -1);
      return m(p, w) > -1 ? w : w !== "Object" ? !1 : R(_);
    }
    return a ? g(_) : null;
  }, la;
}
var fa, sf;
function M0() {
  if (sf) return fa;
  sf = 1;
  var e = W0();
  return fa = function(r) {
    return !!e(r);
  }, fa;
}
var q0 = Jn, K0 = Uc, z0 = K0("TypedArray.prototype.buffer", !0), G0 = M0(), V0 = z0 || function(t) {
  if (!G0(t))
    throw new q0("Not a Typed Array");
  return t.buffer;
}, Rt = wo.Buffer, Z0 = xy, Y0 = V0, X0 = ArrayBuffer.isView || function(t) {
  try {
    return Y0(t), !0;
  } catch {
    return !1;
  }
}, J0 = typeof Uint8Array < "u", Wc = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", Q0 = Wc && (Rt.prototype instanceof Uint8Array || Rt.TYPED_ARRAY_SUPPORT), e_ = function(t, r) {
  if (Rt.isBuffer(t))
    return t.constructor && !("isBuffer" in t) ? Rt.from(t) : t;
  if (typeof t == "string")
    return Rt.from(t, r);
  if (Wc && X0(t)) {
    if (t.byteLength === 0)
      return Rt.alloc(0);
    if (Q0) {
      var i = Rt.from(t.buffer, t.byteOffset, t.byteLength);
      if (i.byteLength === t.byteLength)
        return i;
    }
    var a = t instanceof Uint8Array ? t : new Uint8Array(t.buffer, t.byteOffset, t.byteLength), s = Rt.from(a);
    if (s.length === t.byteLength)
      return s;
  }
  if (J0 && t instanceof Uint8Array)
    return Rt.from(t);
  var n = Z0(t);
  if (n)
    for (var o = 0; o < t.length; o += 1) {
      var l = t[o];
      if (typeof l != "number" || l < 0 || l > 255 || ~~l !== l)
        throw new RangeError("Array items must be numbers in the range 0-255.");
    }
  if (n || Rt.isBuffer(t) && t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t))
    return Rt.from(t);
  throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
}, t_ = wo.Buffer, r_ = e_;
function di(e, t) {
  this._block = t_.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0;
}
di.prototype.update = function(e, t) {
  e = r_(e, t || "utf8");
  for (var r = this._block, i = this._blockSize, a = e.length, s = this._len, n = 0; n < a; ) {
    for (var o = s % i, l = Math.min(a - n, i - o), p = 0; p < l; p++)
      r[o + p] = e[n + p];
    s += l, n += l, s % i === 0 && this._update(r);
  }
  return this._len += a, this;
};
di.prototype.digest = function(e) {
  var t = this._len % this._blockSize;
  this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var r = this._len * 8;
  if (r <= 4294967295)
    this._block.writeUInt32BE(r, this._blockSize - 4);
  else {
    var i = (r & 4294967295) >>> 0, a = (r - i) / 4294967296;
    this._block.writeUInt32BE(a, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4);
  }
  this._update(this._block);
  var s = this._hash();
  return e ? s.toString(e) : s;
};
di.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var n_ = di, s_ = uy, Mc = n_, i_ = wo.Buffer, a_ = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], o_ = new Array(80);
function ns() {
  this.init(), this._w = o_, Mc.call(this, 64, 56);
}
s_(ns, Mc);
ns.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function l_(e) {
  return e << 1 | e >>> 31;
}
function f_(e) {
  return e << 5 | e >>> 27;
}
function p_(e) {
  return e << 30 | e >>> 2;
}
function c_(e, t, r, i) {
  return e === 0 ? t & r | ~t & i : e === 2 ? t & r | t & i | r & i : t ^ r ^ i;
}
ns.prototype._update = function(e) {
  for (var t = this._w, r = this._a | 0, i = this._b | 0, a = this._c | 0, s = this._d | 0, n = this._e | 0, o = 0; o < 16; ++o)
    t[o] = e.readInt32BE(o * 4);
  for (; o < 80; ++o)
    t[o] = l_(t[o - 3] ^ t[o - 8] ^ t[o - 14] ^ t[o - 16]);
  for (var l = 0; l < 80; ++l) {
    var p = ~~(l / 20), c = f_(r) + c_(p, i, a, s) + n + t[l] + a_[p] | 0;
    n = s, s = a, a = p_(i), i = r, r = c;
  }
  this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = a + this._c | 0, this._d = s + this._d | 0, this._e = n + this._e | 0;
};
ns.prototype._hash = function() {
  var e = i_.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var u_ = ns;
const d_ = /* @__PURE__ */ to(u_);
function h_(e) {
  let t = "";
  for (const r of new Uint8Array(e))
    r < 16 && (t += "0"), t += r.toString(16);
  return t;
}
let pa = null;
async function Ys(e) {
  return pa === null && (pa = await y_()), pa ? qc(e) : m_(e);
}
function m_(e) {
  return new d_().update(e).digest("hex");
}
async function qc(e) {
  const t = await crypto.subtle.digest("SHA-1", e);
  return h_(t);
}
async function y_() {
  try {
    if (await qc(new Uint8Array([])) === "da39a3ee5e6b4b0d3255bfef95601890afd80709") return !0;
  } catch {
  }
  return !1;
}
function __(e) {
  const t = [];
  let r = 0, i = 0;
  do {
    r = e.readUInt8();
    const a = r & 127;
    t.push(a), i = r & 128;
  } while (i);
  return t.reduce((a, s) => a + 1 << 7 | s, -1);
}
function g_(e, t) {
  let r = t, i = 4, a = null;
  do
    a = e.readUInt8(), r |= (a & 127) << i, i += 7;
  while (a & 128);
  return r;
}
class pn {
  constructor(t) {
    Object.assign(this, t), this.offsetCache = {};
  }
  static async fromIdx({ idx: t, getExternalRefDelta: r }) {
    const i = new Kt(t);
    if (i.slice(4).toString("hex") !== "ff744f63")
      return;
    const s = i.readUInt32BE();
    if (s !== 2)
      throw new ke(
        `Unable to read version ${s} packfile IDX. (Only version 2 supported)`
      );
    if (t.byteLength > 2048 * 1024 * 1024)
      throw new ke(
        "To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size."
      );
    i.seek(i.tell() + 4 * 255);
    const n = i.readUInt32BE(), o = [];
    for (let c = 0; c < n; c++) {
      const m = i.slice(20).toString("hex");
      o[c] = m;
    }
    i.seek(i.tell() + 4 * n);
    const l = /* @__PURE__ */ new Map();
    for (let c = 0; c < n; c++)
      l.set(o[c], i.readUInt32BE());
    const p = i.slice(20).toString("hex");
    return new pn({
      hashes: o,
      crcs: {},
      offsets: l,
      packfileSha: p,
      getExternalRefDelta: r
    });
  }
  static async fromPack({ pack: t, getExternalRefDelta: r, onProgress: i }) {
    const a = {
      1: "commit",
      2: "tree",
      3: "blob",
      4: "tag",
      6: "ofs-delta",
      7: "ref-delta"
    }, s = {}, n = t.slice(-20).toString("hex"), o = [], l = {}, p = /* @__PURE__ */ new Map();
    let c = null, m = null;
    await fy([t], async ({ data: _, type: w, reference: C, offset: E, num: D }) => {
      c === null && (c = D);
      const T = Math.floor(
        (c - D) * 100 / c
      );
      T !== m && i && await i({
        phase: "Receiving objects",
        loaded: c - D,
        total: c
      }), m = T, w = a[w], ["commit", "tree", "blob", "tag"].includes(w) ? s[E] = {
        type: w,
        offset: E
      } : w === "ofs-delta" ? s[E] = {
        type: w,
        offset: E
      } : w === "ref-delta" && (s[E] = {
        type: w,
        offset: E
      });
    });
    const h = Object.keys(s).map(Number);
    for (const [_, w] of h.entries()) {
      const C = _ + 1 === h.length ? t.byteLength - 20 : h[_ + 1], E = s[w], D = hh.buf(t.slice(w, C)) >>> 0;
      E.end = C, E.crc = D;
    }
    const g = new pn({
      pack: Promise.resolve(t),
      packfileSha: n,
      crcs: l,
      hashes: o,
      offsets: p,
      getExternalRefDelta: r
    });
    m = null;
    let R = 0;
    const y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (let _ in s) {
      _ = Number(_);
      const w = Math.floor(R * 100 / c);
      w !== m && i && await i({
        phase: "Resolving deltas",
        loaded: R,
        total: c
      }), R++, m = w;
      const C = s[_];
      if (!C.oid)
        try {
          g.readDepth = 0, g.externalReadDepth = 0;
          const { type: E, object: D } = await g.readSlice({ start: _ });
          y[g.readDepth] += 1;
          const T = await Ys(mh.wrap({ type: E, object: D }));
          C.oid = T, o.push(T), p.set(T, _), l[T] = C.crc;
        } catch {
          continue;
        }
    }
    return o.sort(), g;
  }
  async toBuffer() {
    const t = [], r = (p, c) => {
      t.push(Buffer.from(p, c));
    };
    r("ff744f63", "hex"), r("00000002", "hex");
    const i = new Kt(Buffer.alloc(256 * 4));
    for (let p = 0; p < 256; p++) {
      let c = 0;
      for (const m of this.hashes)
        parseInt(m.slice(0, 2), 16) <= p && c++;
      i.writeUInt32BE(c);
    }
    t.push(i.buffer);
    for (const p of this.hashes)
      r(p, "hex");
    const a = new Kt(Buffer.alloc(this.hashes.length * 4));
    for (const p of this.hashes)
      a.writeUInt32BE(this.crcs[p]);
    t.push(a.buffer);
    const s = new Kt(Buffer.alloc(this.hashes.length * 4));
    for (const p of this.hashes)
      s.writeUInt32BE(this.offsets.get(p));
    t.push(s.buffer), r(this.packfileSha, "hex");
    const n = Buffer.concat(t), o = await Ys(n), l = Buffer.alloc(20);
    return l.write(o, "hex"), Buffer.concat([n, l]);
  }
  async load({ pack: t }) {
    this.pack = t;
  }
  async unload() {
    this.pack = null;
  }
  async read({ oid: t }) {
    if (!this.offsets.get(t)) {
      if (this.getExternalRefDelta)
        return this.externalReadDepth++, this.getExternalRefDelta(t);
      throw new ke(`Could not read object ${t} from packfile`);
    }
    const r = this.offsets.get(t);
    return this.readSlice({ start: r });
  }
  async readSlice({ start: t }) {
    if (this.offsetCache[t])
      return Object.assign({}, this.offsetCache[t]);
    this.readDepth++;
    const r = {
      16: "commit",
      32: "tree",
      48: "blob",
      64: "tag",
      96: "ofs_delta",
      112: "ref_delta"
    };
    if (!this.pack)
      throw new ke(
        "Tried to read from a GitPackIndex with no packfile loaded into memory"
      );
    const i = (await this.pack).slice(t), a = new Kt(i), s = a.readUInt8(), n = s & 112;
    let o = r[n];
    if (o === void 0)
      throw new ke("Unrecognized type: 0b" + n.toString(2));
    const l = s & 15;
    let p = l;
    s & 128 && (p = g_(a, l));
    let m = null, h = null;
    if (o === "ofs_delta") {
      const R = __(a), y = t - R;
      ({ object: m, type: o } = await this.readSlice({ start: y }));
    }
    if (o === "ref_delta") {
      const R = a.slice(20).toString("hex");
      ({ object: m, type: o } = await this.read({ oid: R }));
    }
    const g = i.slice(a.tell());
    if (h = Buffer.from(await cy(g)), h.byteLength !== p)
      throw new ke(
        `Packfile told us object would have length ${p} but it had length ${h.byteLength}`
      );
    return m && (h = Buffer.from(yh(h, m))), this.readDepth > 3 && (this.offsetCache[t] = { type: o, object: h }), { type: o, format: "content", object: h };
  }
}
class Nn extends un {
  /**
   * @param {string} value
   */
  constructor(t) {
    super(`Expected a 40-char hex object id but saw "${t}".`), this.code = this.name = Nn.code, this.data = { value: t };
  }
}
Nn.code = "InvalidOidError";
class hi extends un {
  /**
   * @param {string} oid
   * @param {'blob'|'commit'|'tag'|'tree'} actual
   * @param {'blob'|'commit'|'tag'|'tree'} expected
   * @param {string} [filepath]
   */
  constructor(t, r, i, a) {
    super(
      `Object ${t} ${a ? `at ${a}` : ""}was anticipated to be a ${i} but it is a ${r}.`
    ), this.code = this.name = hi.code, this.data = { oid: t, actual: r, expected: i, filepath: a };
  }
}
hi.code = "ObjectTypeError";
function w_(e) {
  let t = e > 0 ? e >> 12 : 0;
  t !== 4 && t !== 8 && t !== 10 && t !== 14 && (t = 8);
  let r = e & 511;
  return r & 73 ? r = 493 : r = 420, t !== 8 && (r = 0), (t << 12) + r;
}
const Ut = 2 ** 32;
function af(e, t, r, i) {
  if (e !== void 0 && t !== void 0)
    return [e, t];
  r === void 0 && (r = i.valueOf());
  const a = Math.floor(r / 1e3), s = (r - a * 1e3) * 1e6;
  return [a, s];
}
function of(e) {
  const [t, r] = af(
    e.ctimeSeconds,
    e.ctimeNanoseconds,
    e.ctimeMs,
    e.ctime
  ), [i, a] = af(
    e.mtimeSeconds,
    e.mtimeNanoseconds,
    e.mtimeMs,
    e.mtime
  );
  return {
    ctimeSeconds: t % Ut,
    ctimeNanoseconds: r % Ut,
    mtimeSeconds: i % Ut,
    mtimeNanoseconds: a % Ut,
    dev: e.dev % Ut,
    ino: e.ino % Ut,
    mode: w_(e.mode % Ut),
    uid: e.uid % Ut,
    gid: e.gid % Ut,
    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
    size: e.size > -1 ? e.size % Ut : 0
  };
}
function b_(e) {
  return {
    assumeValid: !!(e & 32768),
    extended: !!(e & 16384),
    stage: (e & 12288) >> 12,
    nameLength: e & 4095
  };
}
function v_(e) {
  const t = e.flags;
  return t.extended = !1, t.nameLength = Math.min(Buffer.from(e.path).length, 4095), (t.assumeValid ? 32768 : 0) + (t.extended ? 16384 : 0) + ((t.stage & 3) << 12) + (t.nameLength & 4095);
}
class Pr {
  /*::
   _entries: Map<string, CacheEntry>
   _dirty: boolean // Used to determine if index needs to be saved to filesystem
   */
  constructor(t, r) {
    this._dirty = !1, this._unmergedPaths = r || /* @__PURE__ */ new Set(), this._entries = t || /* @__PURE__ */ new Map();
  }
  _addEntry(t) {
    if (t.flags.stage === 0)
      t.stages = [t], this._entries.set(t.path, t), this._unmergedPaths.delete(t.path);
    else {
      let r = this._entries.get(t.path);
      r || (this._entries.set(t.path, t), r = t), r.stages[t.flags.stage] = t, this._unmergedPaths.add(t.path);
    }
  }
  static async from(t) {
    if (Buffer.isBuffer(t))
      return Pr.fromBuffer(t);
    if (t === null)
      return new Pr(null);
    throw new ke("invalid type passed to GitIndex.from");
  }
  static async fromBuffer(t) {
    if (t.length === 0)
      throw new ke("Index file is empty (.git/index)");
    const r = new Pr(), i = new Kt(t), a = i.toString("utf8", 4);
    if (a !== "DIRC")
      throw new ke(`Invalid dircache magic file number: ${a}`);
    const s = await Ys(t.slice(0, -20)), n = t.slice(-20).toString("hex");
    if (n !== s)
      throw new ke(
        `Invalid checksum in GitIndex buffer: expected ${n} but saw ${s}`
      );
    const o = i.readUInt32BE();
    if (o !== 2)
      throw new ke(`Unsupported dircache version: ${o}`);
    const l = i.readUInt32BE();
    let p = 0;
    for (; !i.eof() && p < l; ) {
      const c = {};
      c.ctimeSeconds = i.readUInt32BE(), c.ctimeNanoseconds = i.readUInt32BE(), c.mtimeSeconds = i.readUInt32BE(), c.mtimeNanoseconds = i.readUInt32BE(), c.dev = i.readUInt32BE(), c.ino = i.readUInt32BE(), c.mode = i.readUInt32BE(), c.uid = i.readUInt32BE(), c.gid = i.readUInt32BE(), c.size = i.readUInt32BE(), c.oid = i.slice(20).toString("hex");
      const m = i.readUInt16BE();
      c.flags = b_(m);
      const h = t.indexOf(0, i.tell() + 1) - i.tell();
      if (h < 1)
        throw new ke(`Got a path length of: ${h}`);
      if (c.path = i.toString("utf8", h), c.path.includes("..\\") || c.path.includes("../"))
        throw new Gn(c.path);
      let g = 8 - (i.tell() - 12) % 8;
      for (g === 0 && (g = 8); g--; ) {
        const R = i.readUInt8();
        if (R !== 0)
          throw new ke(
            `Expected 1-8 null characters but got '${R}' after ${c.path}`
          );
        if (i.eof())
          throw new ke("Unexpected end of file");
      }
      c.stages = [], r._addEntry(c), p++;
    }
    return r;
  }
  get unmergedPaths() {
    return [...this._unmergedPaths];
  }
  get entries() {
    return [...this._entries.values()].sort(Bp);
  }
  get entriesMap() {
    return this._entries;
  }
  get entriesFlat() {
    return [...this.entries].flatMap((t) => t.stages.length > 1 ? t.stages.filter((r) => r) : t);
  }
  *[Symbol.iterator]() {
    for (const t of this.entries)
      yield t;
  }
  insert({ filepath: t, stats: r, oid: i, stage: a = 0 }) {
    r || (r = {
      ctimeSeconds: 0,
      ctimeNanoseconds: 0,
      mtimeSeconds: 0,
      mtimeNanoseconds: 0,
      dev: 0,
      ino: 0,
      mode: 0,
      uid: 0,
      gid: 0,
      size: 0
    }), r = of(r);
    const s = Buffer.from(t), n = {
      ctimeSeconds: r.ctimeSeconds,
      ctimeNanoseconds: r.ctimeNanoseconds,
      mtimeSeconds: r.mtimeSeconds,
      mtimeNanoseconds: r.mtimeNanoseconds,
      dev: r.dev,
      ino: r.ino,
      // We provide a fallback value for `mode` here because not all fs
      // implementations assign it, but we use it in GitTree.
      // '100644' is for a "regular non-executable file"
      mode: r.mode || 33188,
      uid: r.uid,
      gid: r.gid,
      size: r.size,
      path: t,
      oid: i,
      flags: {
        assumeValid: !1,
        extended: !1,
        stage: a,
        nameLength: s.length < 4095 ? s.length : 4095
      },
      stages: []
    };
    this._addEntry(n), this._dirty = !0;
  }
  delete({ filepath: t }) {
    if (this._entries.has(t))
      this._entries.delete(t);
    else
      for (const r of this._entries.keys())
        r.startsWith(t + "/") && this._entries.delete(r);
    this._unmergedPaths.has(t) && this._unmergedPaths.delete(t), this._dirty = !0;
  }
  clear() {
    this._entries.clear(), this._dirty = !0;
  }
  has({ filepath: t }) {
    return this._entries.has(t);
  }
  render() {
    return this.entries.map((t) => `${t.mode.toString(8)} ${t.oid}    ${t.path}`).join(`
`);
  }
  static async _entryToBuffer(t) {
    const r = Buffer.from(t.path), i = Math.ceil((62 + r.length + 1) / 8) * 8, a = Buffer.alloc(i), s = new Kt(a), n = of(t);
    return s.writeUInt32BE(n.ctimeSeconds), s.writeUInt32BE(n.ctimeNanoseconds), s.writeUInt32BE(n.mtimeSeconds), s.writeUInt32BE(n.mtimeNanoseconds), s.writeUInt32BE(n.dev), s.writeUInt32BE(n.ino), s.writeUInt32BE(n.mode), s.writeUInt32BE(n.uid), s.writeUInt32BE(n.gid), s.writeUInt32BE(n.size), s.write(t.oid, 20, "hex"), s.writeUInt16BE(v_(t)), s.write(t.path, r.length, "utf8"), a;
  }
  async toObject() {
    const t = Buffer.alloc(12), r = new Kt(t);
    r.write("DIRC", 4, "utf8"), r.writeUInt32BE(2), r.writeUInt32BE(this.entriesFlat.length);
    let i = [];
    for (const o of this.entries)
      if (i.push(Pr._entryToBuffer(o)), o.stages.length > 1)
        for (const l of o.stages)
          l && l !== o && i.push(Pr._entryToBuffer(l));
    i = await Promise.all(i);
    const a = Buffer.concat(i), s = Buffer.concat([t, a]), n = await Ys(s);
    return Buffer.concat([s, Buffer.from(n, "hex")]);
  }
}
async function Kc(e, t) {
  const r = Dp(e);
  for (; ; ) {
    const { value: i, done: a } = await r.next();
    if (i && await t(i), a) break;
  }
  r.return && r.return();
}
async function jn(e) {
  let t = 0;
  const r = [];
  await Kc(e, (s) => {
    r.push(s), t += s.byteLength;
  });
  const i = new Uint8Array(t);
  let a = 0;
  for (const s of r)
    i.set(s, a), a += s.byteLength;
  return i;
}
class ca {
  constructor() {
    this._queue = [];
  }
  write(t) {
    if (this._ended)
      throw Error("You cannot write to a FIFO that has already been ended!");
    if (this._waiting) {
      const r = this._waiting;
      this._waiting = null, r({ value: t });
    } else
      this._queue.push(t);
  }
  end() {
    if (this._ended = !0, this._waiting) {
      const t = this._waiting;
      this._waiting = null, t({ done: !0 });
    }
  }
  destroy(t) {
    this.error = t, this.end();
  }
  async next() {
    if (this._queue.length > 0)
      return { value: this._queue.shift() };
    if (this._ended)
      return { done: !0 };
    if (this._waiting)
      throw Error(
        "You cannot call read until the previous call to read has returned!"
      );
    return new Promise((t) => {
      this._waiting = t;
    });
  }
}
class x_ {
  static demux(t) {
    const r = Ye.streamReader(t), i = new ca(), a = new ca(), s = new ca(), n = async function() {
      const o = await r();
      if (o === null) return n();
      if (o === !0) {
        i.end(), s.end(), t.error ? a.destroy(t.error) : a.end();
        return;
      }
      switch (o[0]) {
        case 1: {
          a.write(o.slice(1));
          break;
        }
        case 2: {
          s.write(o.slice(1));
          break;
        }
        case 3: {
          const l = o.slice(1);
          s.write(l), i.end(), s.end(), a.destroy(new Error(l.toString("utf8")));
          return;
        }
        default:
          i.write(o);
      }
      n();
    };
    return n(), {
      packetlines: i,
      packfile: a,
      progress: s
    };
  }
  // static mux ({
  //   protocol, // 'side-band' or 'side-band-64k'
  //   packetlines,
  //   packfile,
  //   progress,
  //   error
  // }) {
  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
  //   let output = new PassThrough()
  //   packetlines.on('data', data => {
  //     if (data === null) {
  //       output.write(GitPktLine.flush())
  //     } else {
  //       output.write(GitPktLine.encode(data))
  //     }
  //   })
  //   let packfileWasEmpty = true
  //   let packfileEnded = false
  //   let progressEnded = false
  //   let errorEnded = false
  //   let goodbye = Buffer.concat([
  //     GitPktLine.encode(Buffer.from('010A', 'hex')),
  //     GitPktLine.flush()
  //   ])
  //   packfile
  //     .on('data', data => {
  //       packfileWasEmpty = false
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       packfileEnded = true
  //       if (!packfileWasEmpty) output.write(goodbye)
  //       if (progressEnded && errorEnded) output.end()
  //     })
  //   progress
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       progressEnded = true
  //       if (packfileEnded && errorEnded) output.end()
  //     })
  //   error
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       errorEnded = true
  //       if (progressEnded && packfileEnded) output.end()
  //     })
  //   return output
  // }
}
async function zc(e) {
  const { packetlines: t, packfile: r, progress: i } = x_.demux(e), a = [], s = [], n = [];
  let o = !1, l = !1;
  return new Promise((p, c) => {
    Kc(t, (m) => {
      const h = m.toString("utf8").trim();
      if (h.startsWith("shallow")) {
        const g = h.slice(-41).trim();
        g.length !== 40 && c(new Nn(g)), a.push(g);
      } else if (h.startsWith("unshallow")) {
        const g = h.slice(-41).trim();
        g.length !== 40 && c(new Nn(g)), s.push(g);
      } else if (h.startsWith("ACK")) {
        const [, g, R] = h.split(" ");
        n.push({ oid: g, status: R }), R || (l = !0);
      } else h.startsWith("NAK") ? (o = !0, l = !0) : (l = !0, o = !0);
      l && (e.error ? c(e.error) : p({ shallows: a, unshallows: s, acks: n, nak: o, packfile: r, progress: i }));
    }).finally(() => {
      l || (e.error ? c(e.error) : p({ shallows: a, unshallows: s, acks: n, nak: o, packfile: r, progress: i }));
    });
  });
}
typeof globalThis.Buffer > "u" && (globalThis.Buffer = _o.Buffer);
class Un extends Error {
  constructor(t, r) {
    super(
      `Authentication required to access private repository: ${t}`
    ), this.name = "GitAuthenticationError", this.repoUrl = t, this.status = r;
  }
}
async function S_(e, t, r, i) {
  const a = (i == null ? void 0 : i.additionalHeaders) || {}, s = await Vc(
    e,
    t,
    a
  ), n = await C_(s.idx, t, r), o = r.map((g) => n[g].oid), l = o.length > 0 ? await L_(e, o, a) : null, p = {};
  if (await Promise.all(
    r.map(async (g) => {
      l && (p[g] = await Zc(
        l.idx,
        n[g].oid
      ));
    })
  ), !(i != null && i.withObjects))
    return { files: p };
  const c = [], m = await s.idx.toBuffer();
  if (c.push({
    name: `pack-${s.idx.packfileSha}`,
    pack: s.packfile,
    index: Wn(m),
    promisor: s.promisor
  }), l) {
    const g = await l.idx.toBuffer();
    c.push({
      name: `pack-${l.idx.packfileSha}`,
      pack: l.packfile,
      index: Wn(g),
      promisor: l.promisor
    });
  }
  const h = {};
  for (const g of r)
    h[g] = n[g].oid;
  return {
    files: p,
    packfiles: c,
    objects: [
      ...await lf(s),
      ...await lf(l)
    ],
    fileOids: h
  };
}
const E_ = /^[0-9a-f]{40}$/i;
async function k_(e, t, r = {}) {
  const i = await Vc(
    e,
    t,
    r
  ), a = await O_(i.idx, t);
  return a != null && a.object ? Gc(a) : [];
}
async function P_(e, t, r = {}) {
  const i = await T_(e, t);
  if (i.resolvedOid)
    return i.resolvedOid;
  const a = await Ka(e, i.refname, r);
  if (!a)
    throw new Error(`Git ref "${i.refname}" not found at ${e}`);
  return a;
}
function Gc(e) {
  return e.object.map((t) => {
    if (t.type === "blob")
      return {
        name: t.path,
        type: "file"
      };
    if (t.type === "tree" && t.object)
      return {
        name: t.path,
        type: "folder",
        children: Gc(t)
      };
  }).filter((t) => !!(t != null && t.name));
}
async function A_(e, t, r = {}) {
  const i = Buffer.from(
    await jn([
      Ye.encode(`command=ls-refs
`),
      Ye.encode(`agent=git/2.37.3
`),
      Ye.encode(`object-format=sha1
`),
      Ye.delim(),
      Ye.encode(`peel
`),
      Ye.encode(`ref-prefix ${t}
`),
      Ye.flush()
    ])
  ), a = await fetch(e + "/git-upload-pack", {
    method: "POST",
    headers: {
      Accept: "application/x-git-upload-pack-advertisement",
      "content-type": "application/x-git-upload-pack-request",
      "Content-Length": `${i.length}`,
      "Git-Protocol": "version=2",
      ...r
    },
    body: i
  });
  if (!a.ok)
    throw a.status === 401 || a.status === 403 ? new Un(e, a.status) : new Error(
      `Failed to fetch git refs from ${e}: ${a.status} ${a.statusText}`
    );
  const s = {};
  for await (const n of R_(a)) {
    const o = n.indexOf(" "), l = n.slice(0, o), c = n.slice(o + 1, n.length - 1).split(" ")[0];
    s[c] = l;
  }
  return s;
}
async function T_(e, t) {
  switch (t.type ?? "infer") {
    case "commit":
      return {
        kind: "commit",
        refname: t.value,
        resolvedOid: t.value
      };
    case "branch":
      return {
        kind: "refname",
        refname: `refs/heads/${t.value.trim()}`
      };
    case "tag":
      return {
        kind: "refname",
        refname: `refs/tags/${t.value.trim()}`
      };
    case "refname":
      return {
        kind: "refname",
        refname: t.value.trim()
      };
    case "infer": {
      const i = t.value.trim();
      if (i === "" || i === "HEAD")
        return {
          kind: "refname",
          refname: "HEAD"
        };
      if (i.startsWith("refs/"))
        return {
          kind: "refname",
          refname: i
        };
      if (E_.test(i))
        return {
          kind: "commit",
          refname: i,
          resolvedOid: i
        };
      const a = `refs/heads/${i}`, s = await Ka(e, a);
      if (s)
        return {
          kind: "refname",
          refname: a,
          resolvedOid: s
        };
      const n = `refs/tags/${i}`, o = await Ka(e, n);
      if (o)
        return {
          kind: "refname",
          refname: n,
          resolvedOid: o
        };
      throw new Error(`Git ref "${t.value}" not found at ${e}`);
    }
    default:
      throw new Error(`Invalid ref type: ${t.type}`);
  }
}
async function Ka(e, t, r) {
  const i = await A_(e, t, r), a = [t, `${t}^{}`];
  for (const s of a) {
    const n = s.trim();
    if (n in i)
      return i[n];
  }
  return null;
}
async function Vc(e, t, r) {
  const i = Buffer.from(
    await jn([
      Ye.encode(
        `want ${t} multi_ack_detailed no-done side-band-64k thin-pack ofs-delta agent=git/2.37.3 filter 
`
      ),
      Ye.encode(`filter blob:none
`),
      Ye.encode(`shallow ${t}
`),
      Ye.encode(`deepen 1
`),
      Ye.flush(),
      Ye.encode(`done
`),
      Ye.encode(`done
`)
    ])
  ), a = await fetch(e + "/git-upload-pack", {
    method: "POST",
    headers: {
      Accept: "application/x-git-upload-pack-advertisement",
      "content-type": "application/x-git-upload-pack-request",
      "Content-Length": `${i.length}`,
      ...r
    },
    body: i
  });
  if (!a.ok)
    throw a.status === 401 || a.status === 403 ? new Un(e, a.status) : new Error(
      `Failed to fetch git objects from ${e}: ${a.status} ${a.statusText}`
    );
  const s = Yc(a.body), n = await zc(s), o = Buffer.from(await jn(n.packfile)), l = await pn.fromPack({
    pack: o
  }), p = l.read;
  return l.read = async function({ oid: c, ...m }) {
    const h = await p.call(this, { oid: c, ...m });
    return h.oid = c, h;
  }, {
    idx: l,
    packfile: Wn(o),
    promisor: !0
  };
}
async function O_(e, t) {
  const r = await e.read({
    oid: t
  });
  Lr(r);
  const i = await e.read({ oid: r.object.tree }), a = [i];
  for (; a.length > 0; ) {
    const s = a.pop(), n = await e.read({ oid: s.oid });
    if (Lr(n), s.object = n.object, n.type === "tree")
      for (const o of n.object)
        o.type === "tree" && a.push(o);
  }
  return i;
}
async function lf(e) {
  if (!e)
    return [];
  const t = [], r = /* @__PURE__ */ new Set();
  for (const i of e.idx.hashes ?? []) {
    if (r.has(i))
      continue;
    const a = e.idx.offsets.get(i);
    if (a === void 0)
      continue;
    const { type: s, object: n } = await e.idx.readSlice({ start: a });
    s === "ofs_delta" || s === "ref_delta" || n && (r.add(i), t.push({
      oid: i,
      type: s,
      body: Wn(n)
    }));
  }
  return t;
}
async function C_(e, t, r) {
  const i = await e.read({
    oid: t
  });
  Lr(i);
  const a = await e.read({ oid: i.object.tree });
  Lr(a);
  const s = {};
  for (const n of r) {
    let o = a;
    const l = n.split("/");
    for (const p of l) {
      if (o.type !== "tree")
        throw new Error(`Path not found in the repo: ${n}`);
      let c = !1;
      for (const m of o.object)
        if (m.path === p) {
          try {
            o = await e.read({ oid: m.oid }), Lr(o);
          } catch {
            o = m;
          }
          c = !0;
          break;
        }
      if (!c)
        throw new Error(`Path not found in the repo: ${n}`);
    }
    s[n] = o;
  }
  return s;
}
async function L_(e, t, r) {
  const i = Buffer.from(
    await jn([
      ...t.map(
        (p) => Ye.encode(
          `want ${p} multi_ack_detailed no-done side-band-64k thin-pack ofs-delta agent=git/2.37.3 
`
        )
      ),
      Ye.flush(),
      Ye.encode(`done
`)
    ])
  ), a = await fetch(e + "/git-upload-pack", {
    method: "POST",
    headers: {
      Accept: "application/x-git-upload-pack-advertisement",
      "content-type": "application/x-git-upload-pack-request",
      "Content-Length": `${i.length}`,
      ...r
    },
    body: i
  });
  if (!a.ok)
    throw a.status === 401 || a.status === 403 ? new Un(e, a.status) : new Error(
      `Failed to fetch git objects from ${e}: ${a.status} ${a.statusText}`
    );
  const s = Yc(a.body), n = await zc(s), o = Buffer.from(await jn(n.packfile));
  return o.byteLength === 0 ? {
    idx: await pn.fromPack({
      pack: o
    }),
    packfile: new Uint8Array(),
    promisor: !1
  } : {
    idx: await pn.fromPack({
      pack: o
    }),
    packfile: Wn(o),
    promisor: !1
  };
}
async function Zc(e, t) {
  const r = await e.read({ oid: t });
  if (Lr(r), r.type === "blob")
    return r.object;
  const i = {};
  for (const { path: a, oid: s, type: n } of r.object)
    if (n === "blob") {
      const o = await e.read({ oid: s });
      Lr(o), i[a] = o.object;
    } else n === "tree" && (i[a] = await Zc(e, s));
  return i;
}
function Lr(e) {
  if (e.object instanceof Buffer)
    switch (e.type) {
      case "commit":
        e.object = _t.from(e.object).parse();
        break;
      case "tree":
        e.object = oo.from(e.object).entries();
        break;
      case "blob":
        e.object = new Uint8Array(e.object), e.format = "content";
        break;
      case "tag":
        e.object = Pn.from(e.object).parse();
        break;
      default:
        throw new hi(
          e.oid,
          e.type,
          "blob|commit|tag|tree"
        );
    }
}
async function* R_(e) {
  const t = await e.text();
  let r = 0;
  for (; r <= t.length; ) {
    const i = parseInt(t.substring(r, r + 4), 16);
    if (i === 0)
      break;
    yield t.substring(r + 4, r + i), r += i;
  }
}
function Yc(e) {
  if (e[Symbol.asyncIterator])
    return e;
  const t = e.getReader();
  return {
    next() {
      return t.read();
    },
    return() {
      return t.releaseLock(), {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function Wn(e) {
  return e instanceof Uint8Array, Uint8Array.from(e);
}
const $_ = yo.deflate, I_ = /^[0-9a-f]{40}$/i;
async function D_(e) {
  const t = {}, r = new TextEncoder();
  return await Promise.all(
    e.map(async ({ oid: i, type: a, body: s }) => {
      if (!i || s.length === 0)
        return;
      const n = r.encode(`${a} ${s.length}\0`), o = new Uint8Array(n.length + s.length);
      o.set(n, 0), o.set(s, n.length);
      const l = await $_(o), p = i.slice(0, 2), c = i.slice(2);
      t[`.git/objects/${p}/${c}`] = l;
    })
  ), t;
}
function H_(e, t, r) {
  const i = (e == null ? void 0 : e.trim()) ?? "";
  let a = null;
  switch (t) {
    case "branch":
      i && (a = `refs/heads/${i}`);
      break;
    case "refname":
      a = i || null;
      break;
    case "tag":
      i.startsWith("refs/") ? a = i : i && (a = `refs/tags/${i}`);
      break;
    case "commit":
      a = null;
      break;
    default:
      i.startsWith("refs/") ? a = i : I_.test(i) ? a = null : i && i !== "HEAD" && (a = `refs/heads/${i}`);
      break;
  }
  const s = a ? `ref: ${a}
` : `${r}
`, n = a && a.startsWith("refs/heads/") ? a : void 0, o = n == null ? void 0 : n.slice(11), l = a && a.startsWith("refs/tags/") ? a : void 0, p = l == null ? void 0 : l.slice(10);
  return {
    headContent: s,
    branchName: o,
    branchRef: n,
    tagName: p
  };
}
function F_(e, {
  branchName: t,
  partialCloneFilter: r
}) {
  const a = [
    "[core]",
    `	repositoryformatversion = ${r ? 1 : 0}`,
    "	filemode = true",
    "	bare = false",
    "	logallrefupdates = true",
    "	ignorecase = true",
    "	precomposeunicode = true",
    '[remote "origin"]',
    `	url = ${e}`,
    "	fetch = +refs/heads/*:refs/remotes/origin/*",
    "	fetch = +refs/tags/*:refs/tags/*"
  ];
  return r && (a.push("	promisor = true"), a.push(`	partialclonefilter = ${r}`), a.push("[extensions]"), a.push("	partialclone = origin")), t && a.push(
    `[branch "${t}"]`,
    "	remote = origin",
    `	merge = refs/heads/${t}`
  ), a.join(`
`) + `
`;
}
async function B_({
  repoUrl: e,
  commitHash: t,
  ref: r,
  refType: i,
  objects: a,
  fileOids: s,
  pathPrefix: n
}) {
  const o = {}, l = H_(r, i, t);
  o[".git/HEAD"] = l.headContent, o[".git/config"] = F_(e, {
    branchName: l.branchName
  }), o[".git/description"] = `WordPress Playground clone
`, o[".git/shallow"] = `${t}
`, o[".git/refs/heads/.gitkeep"] = "", o[".git/refs/tags/.gitkeep"] = "", o[".git/refs/remotes/.gitkeep"] = "", l.branchRef && l.branchName && (o[".git/logs/HEAD"] = `ref: ${l.branchRef}
`, o[`.git/${l.branchRef}`] = `${t}
`, o[`.git/refs/remotes/origin/${l.branchName}`] = `${t}
`, o[".git/refs/remotes/origin/HEAD"] = `ref: refs/remotes/origin/${l.branchName}
`), l.tagName && (o[`.git/refs/tags/${l.tagName}`] = `${t}
`), Object.assign(o, await D_(a));
  const p = new Pr();
  for (const [m, h] of Object.entries(s)) {
    const g = m.substring(n.length).replace(/^\/+/, "");
    p.insert({
      filepath: g,
      oid: h,
      stats: {
        ctimeSeconds: 0,
        ctimeNanoseconds: 0,
        mtimeSeconds: 0,
        mtimeNanoseconds: 0,
        dev: 0,
        ino: 0,
        mode: 33188,
        // Regular file
        uid: 0,
        gid: 0,
        size: 0
      }
    });
  }
  const c = await p.toObject();
  return o[".git/index"] = Uint8Array.from(c), o;
}
function N_(e, t) {
  t = ii(t);
  const r = ["", ".", "/"].includes(t);
  let i = e;
  if (r)
    t = "";
  else {
    const n = t.split("/");
    for (const o of n) {
      const l = i == null ? void 0 : i.find(
        (p) => p.name === o
      );
      if ((l == null ? void 0 : l.type) === "folder")
        i = l.children;
      else return l ? [l.name] : [];
    }
  }
  const a = [], s = [{ tree: i, path: t }];
  for (; s.length > 0; ) {
    const { tree: n, path: o } = s.pop();
    for (const l of n) {
      const p = `${o}${o ? "/" : ""}${l.name}`;
      l.type === "folder" ? s.push({
        tree: l.children,
        path: p
      }) : a.push(p);
    }
  }
  return a;
}
const Mn = 15, za = 30, Ga = 19, j_ = 29, Xs = 256, So = Xs + 1 + j_, ff = 2 * So + 1, wn = 256, U_ = 7, pf = 16, cf = 17, uf = 18, ua = 8 * 2, Js = -1, W_ = 1, hs = 2, M_ = 0, Qr = 0, df = 1, q_ = 3, pt = 4, $t = 0, Xc = 1, ms = 2, Dt = -2, K_ = -3, Vr = -5;
function mi(e) {
  return yi(e.map(([t, r]) => new Array(t).fill(r, 0, t)));
}
function yi(e) {
  return e.reduce((t, r) => t.concat(Array.isArray(r) ? yi(r) : r), []);
}
const hf = [0, 1, 2, 3].concat(...mi([
  [2, 4],
  [2, 5],
  [4, 6],
  [4, 7],
  [8, 8],
  [8, 9],
  [16, 10],
  [16, 11],
  [32, 12],
  [32, 13],
  [64, 14],
  [64, 15],
  [2, 0],
  [1, 16],
  [1, 17],
  [2, 18],
  [2, 19],
  [4, 20],
  [4, 21],
  [8, 22],
  [8, 23],
  [16, 24],
  [16, 25],
  [32, 26],
  [32, 27],
  [64, 28],
  [64, 29]
]));
function Re() {
  const e = this;
  function t(a) {
    const s = e.dyn_tree, n = e.stat_desc.static_tree, o = e.stat_desc.extra_bits, l = e.stat_desc.extra_base, p = e.stat_desc.max_length;
    let c, m, h, g, R, y, _ = 0;
    for (g = 0; g <= Mn; g++)
      a.bl_count[g] = 0;
    for (s[a.heap[a.heap_max] * 2 + 1] = 0, c = a.heap_max + 1; c < ff; c++)
      m = a.heap[c], g = s[s[m * 2 + 1] * 2 + 1] + 1, g > p && (g = p, _++), s[m * 2 + 1] = g, !(m > e.max_code) && (a.bl_count[g]++, R = 0, m >= l && (R = o[m - l]), y = s[m * 2], a.opt_len += y * (g + R), n && (a.static_len += y * (n[m * 2 + 1] + R)));
    if (_ !== 0) {
      do {
        for (g = p - 1; a.bl_count[g] === 0; )
          g--;
        a.bl_count[g]--, a.bl_count[g + 1] += 2, a.bl_count[p]--, _ -= 2;
      } while (_ > 0);
      for (g = p; g !== 0; g--)
        for (m = a.bl_count[g]; m !== 0; )
          h = a.heap[--c], !(h > e.max_code) && (s[h * 2 + 1] != g && (a.opt_len += (g - s[h * 2 + 1]) * s[h * 2], s[h * 2 + 1] = g), m--);
    }
  }
  function r(a, s) {
    let n = 0;
    do
      n |= a & 1, a >>>= 1, n <<= 1;
    while (--s > 0);
    return n >>> 1;
  }
  function i(a, s, n) {
    const o = [];
    let l = 0, p, c, m;
    for (p = 1; p <= Mn; p++)
      o[p] = l = l + n[p - 1] << 1;
    for (c = 0; c <= s; c++)
      m = a[c * 2 + 1], m !== 0 && (a[c * 2] = r(o[m]++, m));
  }
  e.build_tree = function(a) {
    const s = e.dyn_tree, n = e.stat_desc.static_tree, o = e.stat_desc.elems;
    let l, p, c = -1, m;
    for (a.heap_len = 0, a.heap_max = ff, l = 0; l < o; l++)
      s[l * 2] !== 0 ? (a.heap[++a.heap_len] = c = l, a.depth[l] = 0) : s[l * 2 + 1] = 0;
    for (; a.heap_len < 2; )
      m = a.heap[++a.heap_len] = c < 2 ? ++c : 0, s[m * 2] = 1, a.depth[m] = 0, a.opt_len--, n && (a.static_len -= n[m * 2 + 1]);
    for (e.max_code = c, l = Math.floor(a.heap_len / 2); l >= 1; l--)
      a.pqdownheap(s, l);
    m = o;
    do
      l = a.heap[1], a.heap[1] = a.heap[a.heap_len--], a.pqdownheap(s, 1), p = a.heap[1], a.heap[--a.heap_max] = l, a.heap[--a.heap_max] = p, s[m * 2] = s[l * 2] + s[p * 2], a.depth[m] = Math.max(a.depth[l], a.depth[p]) + 1, s[l * 2 + 1] = s[p * 2 + 1] = m, a.heap[1] = m++, a.pqdownheap(s, 1);
    while (a.heap_len >= 2);
    a.heap[--a.heap_max] = a.heap[1], t(a), i(s, e.max_code, a.bl_count);
  };
}
Re._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...mi([
  [2, 8],
  [2, 9],
  [2, 10],
  [2, 11],
  [4, 12],
  [4, 13],
  [4, 14],
  [4, 15],
  [8, 16],
  [8, 17],
  [8, 18],
  [8, 19],
  [16, 20],
  [16, 21],
  [16, 22],
  [16, 23],
  [32, 24],
  [32, 25],
  [32, 26],
  [31, 27],
  [1, 28]
]));
Re.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];
Re.base_dist = [
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
];
Re.d_code = function(e) {
  return e < 256 ? hf[e] : hf[256 + (e >>> 7)];
};
Re.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
Re.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
Re.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
Re.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
function Je(e, t, r, i, a) {
  const s = this;
  s.static_tree = e, s.extra_bits = t, s.extra_base = r, s.elems = i, s.max_length = a;
}
const z_ = [
  12,
  140,
  76,
  204,
  44,
  172,
  108,
  236,
  28,
  156,
  92,
  220,
  60,
  188,
  124,
  252,
  2,
  130,
  66,
  194,
  34,
  162,
  98,
  226,
  18,
  146,
  82,
  210,
  50,
  178,
  114,
  242,
  10,
  138,
  74,
  202,
  42,
  170,
  106,
  234,
  26,
  154,
  90,
  218,
  58,
  186,
  122,
  250,
  6,
  134,
  70,
  198,
  38,
  166,
  102,
  230,
  22,
  150,
  86,
  214,
  54,
  182,
  118,
  246,
  14,
  142,
  78,
  206,
  46,
  174,
  110,
  238,
  30,
  158,
  94,
  222,
  62,
  190,
  126,
  254,
  1,
  129,
  65,
  193,
  33,
  161,
  97,
  225,
  17,
  145,
  81,
  209,
  49,
  177,
  113,
  241,
  9,
  137,
  73,
  201,
  41,
  169,
  105,
  233,
  25,
  153,
  89,
  217,
  57,
  185,
  121,
  249,
  5,
  133,
  69,
  197,
  37,
  165,
  101,
  229,
  21,
  149,
  85,
  213,
  53,
  181,
  117,
  245,
  13,
  141,
  77,
  205,
  45,
  173,
  109,
  237,
  29,
  157,
  93,
  221,
  61,
  189,
  125,
  253,
  19,
  275,
  147,
  403,
  83,
  339,
  211,
  467,
  51,
  307,
  179,
  435,
  115,
  371,
  243,
  499,
  11,
  267,
  139,
  395,
  75,
  331,
  203,
  459,
  43,
  299,
  171,
  427,
  107,
  363,
  235,
  491,
  27,
  283,
  155,
  411,
  91,
  347,
  219,
  475,
  59,
  315,
  187,
  443,
  123,
  379,
  251,
  507,
  7,
  263,
  135,
  391,
  71,
  327,
  199,
  455,
  39,
  295,
  167,
  423,
  103,
  359,
  231,
  487,
  23,
  279,
  151,
  407,
  87,
  343,
  215,
  471,
  55,
  311,
  183,
  439,
  119,
  375,
  247,
  503,
  15,
  271,
  143,
  399,
  79,
  335,
  207,
  463,
  47,
  303,
  175,
  431,
  111,
  367,
  239,
  495,
  31,
  287,
  159,
  415,
  95,
  351,
  223,
  479,
  63,
  319,
  191,
  447,
  127,
  383,
  255,
  511,
  0,
  64,
  32,
  96,
  16,
  80,
  48,
  112,
  8,
  72,
  40,
  104,
  24,
  88,
  56,
  120,
  4,
  68,
  36,
  100,
  20,
  84,
  52,
  116,
  3,
  131,
  67,
  195,
  35,
  163,
  99,
  227
], G_ = mi([[144, 8], [112, 9], [24, 7], [8, 8]]);
Je.static_ltree = yi(z_.map((e, t) => [e, G_[t]]));
const V_ = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23], Z_ = mi([[30, 5]]);
Je.static_dtree = yi(V_.map((e, t) => [e, Z_[t]]));
Je.static_l_desc = new Je(Je.static_ltree, Re.extra_lbits, Xs + 1, So, Mn);
Je.static_d_desc = new Je(Je.static_dtree, Re.extra_dbits, 0, za, Mn);
Je.static_bl_desc = new Je(null, Re.extra_blbits, 0, Ga, U_);
const Y_ = 9, X_ = 8;
function Wt(e, t, r, i, a) {
  const s = this;
  s.good_length = e, s.max_lazy = t, s.nice_length = r, s.max_chain = i, s.func = a;
}
const Jc = 0, Is = 1, Er = 2, Lt = [
  new Wt(0, 0, 0, 0, Jc),
  new Wt(4, 4, 8, 4, Is),
  new Wt(4, 5, 16, 8, Is),
  new Wt(4, 6, 32, 32, Is),
  new Wt(4, 4, 16, 16, Er),
  new Wt(8, 16, 32, 32, Er),
  new Wt(8, 16, 128, 128, Er),
  new Wt(8, 32, 128, 256, Er),
  new Wt(32, 128, 258, 1024, Er),
  new Wt(32, 258, 258, 4096, Er)
], ys = [
  "need dictionary",
  // Z_NEED_DICT
  // 2
  "stream end",
  // Z_STREAM_END 1
  "",
  // Z_OK 0
  "",
  // Z_ERRNO (-1)
  "stream error",
  // Z_STREAM_ERROR (-2)
  "data error",
  // Z_DATA_ERROR (-3)
  "",
  // Z_MEM_ERROR (-4)
  "buffer error",
  // Z_BUF_ERROR (-5)
  "",
  // Z_VERSION_ERROR (-6)
  ""
], Et = 0, _s = 1, bn = 2, gs = 3, J_ = 32, da = 42, ws = 113, vn = 666, ha = 8, Q_ = 0, ma = 1, eg = 2, Fe = 3, Ds = 258, yt = Ds + Fe + 1;
function mf(e, t, r, i) {
  const a = e[t * 2], s = e[r * 2];
  return a < s || a == s && i[t] <= i[r];
}
function tg() {
  const e = this;
  let t, r, i, a, s, n, o, l, p, c, m, h, g, R, y, _, w, C, E, D, T, H, k, A, L, S, P, I, $, N, U, M, Z;
  const z = new Re(), se = new Re(), G = new Re();
  e.depth = [];
  let Q, ee, V, fe, ie, ae;
  e.bl_count = [], e.heap = [], U = [], M = [], Z = [];
  function Pe() {
    p = 2 * s, m[g - 1] = 0;
    for (let W = 0; W < g - 1; W++)
      m[W] = 0;
    S = Lt[P].max_lazy, $ = Lt[P].good_length, N = Lt[P].nice_length, L = Lt[P].max_chain, T = 0, w = 0, k = 0, C = A = Fe - 1, D = 0, h = 0;
  }
  function Oe() {
    let W;
    for (W = 0; W < So; W++)
      U[W * 2] = 0;
    for (W = 0; W < za; W++)
      M[W * 2] = 0;
    for (W = 0; W < Ga; W++)
      Z[W * 2] = 0;
    U[wn * 2] = 1, e.opt_len = e.static_len = 0, ee = V = 0;
  }
  function Xe() {
    z.dyn_tree = U, z.stat_desc = Je.static_l_desc, se.dyn_tree = M, se.stat_desc = Je.static_d_desc, G.dyn_tree = Z, G.stat_desc = Je.static_bl_desc, ie = 0, ae = 0, fe = 8, Oe();
  }
  e.pqdownheap = function(W, Y) {
    const q = e.heap, J = q[Y];
    let ne = Y << 1;
    for (; ne <= e.heap_len && (ne < e.heap_len && mf(W, q[ne + 1], q[ne], e.depth) && ne++, !mf(W, J, q[ne], e.depth)); )
      q[Y] = q[ne], Y = ne, ne <<= 1;
    q[Y] = J;
  };
  function tt(W, Y) {
    let q = -1, J, ne = W[0 * 2 + 1], le = 0, de = 7, We = 4;
    ne === 0 && (de = 138, We = 3), W[(Y + 1) * 2 + 1] = 65535;
    for (let ce = 0; ce <= Y; ce++)
      J = ne, ne = W[(ce + 1) * 2 + 1], !(++le < de && J == ne) && (le < We ? Z[J * 2] += le : J !== 0 ? (J != q && Z[J * 2]++, Z[pf * 2]++) : le <= 10 ? Z[cf * 2]++ : Z[uf * 2]++, le = 0, q = J, ne === 0 ? (de = 138, We = 3) : J == ne ? (de = 6, We = 3) : (de = 7, We = 4));
  }
  function St() {
    let W;
    for (tt(U, z.max_code), tt(M, se.max_code), G.build_tree(e), W = Ga - 1; W >= 3 && Z[Re.bl_order[W] * 2 + 1] === 0; W--)
      ;
    return e.opt_len += 3 * (W + 1) + 5 + 5 + 4, W;
  }
  function Ie(W) {
    e.pending_buf[e.pending++] = W;
  }
  function De(W) {
    Ie(W & 255), Ie(W >>> 8 & 255);
  }
  function ft(W) {
    Ie(W >> 8 & 255), Ie(W & 255 & 255);
  }
  function Le(W, Y) {
    let q;
    const J = Y;
    ae > ua - J ? (q = W, ie |= q << ae & 65535, De(ie), ie = q >>> ua - ae, ae += J - ua) : (ie |= W << ae & 65535, ae += J);
  }
  function v(W, Y) {
    const q = W * 2;
    Le(Y[q] & 65535, Y[q + 1] & 65535);
  }
  function u(W, Y) {
    let q, J = -1, ne, le = W[0 * 2 + 1], de = 0, We = 7, ce = 4;
    for (le === 0 && (We = 138, ce = 3), q = 0; q <= Y; q++)
      if (ne = le, le = W[(q + 1) * 2 + 1], !(++de < We && ne == le)) {
        if (de < ce)
          do
            v(ne, Z);
          while (--de !== 0);
        else ne !== 0 ? (ne != J && (v(ne, Z), de--), v(pf, Z), Le(de - 3, 2)) : de <= 10 ? (v(cf, Z), Le(de - 3, 3)) : (v(uf, Z), Le(de - 11, 7));
        de = 0, J = ne, le === 0 ? (We = 138, ce = 3) : ne == le ? (We = 6, ce = 3) : (We = 7, ce = 4);
      }
  }
  function d(W, Y, q) {
    let J;
    for (Le(W - 257, 5), Le(Y - 1, 5), Le(q - 4, 4), J = 0; J < q; J++)
      Le(Z[Re.bl_order[J] * 2 + 1], 3);
    u(U, W - 1), u(M, Y - 1);
  }
  function O() {
    ae == 16 ? (De(ie), ie = 0, ae = 0) : ae >= 8 && (Ie(ie & 255), ie >>>= 8, ae -= 8);
  }
  function B() {
    Le(ma << 1, 3), v(wn, Je.static_ltree), O(), 1 + fe + 10 - ae < 9 && (Le(ma << 1, 3), v(wn, Je.static_ltree), O()), fe = 7;
  }
  function K(W, Y) {
    let q, J, ne;
    if (e.dist_buf[ee] = W, e.lc_buf[ee] = Y & 255, ee++, W === 0 ? U[Y * 2]++ : (V++, W--, U[(Re._length_code[Y] + Xs + 1) * 2]++, M[Re.d_code(W) * 2]++), !(ee & 8191) && P > 2) {
      for (q = ee * 8, J = T - w, ne = 0; ne < za; ne++)
        q += M[ne * 2] * (5 + Re.extra_dbits[ne]);
      if (q >>>= 3, V < Math.floor(ee / 2) && q < Math.floor(J / 2))
        return !0;
    }
    return ee == Q - 1;
  }
  function X(W, Y) {
    let q, J, ne = 0, le, de;
    if (ee !== 0)
      do
        q = e.dist_buf[ne], J = e.lc_buf[ne], ne++, q === 0 ? v(J, W) : (le = Re._length_code[J], v(le + Xs + 1, W), de = Re.extra_lbits[le], de !== 0 && (J -= Re.base_length[le], Le(J, de)), q--, le = Re.d_code(q), v(le, Y), de = Re.extra_dbits[le], de !== 0 && (q -= Re.base_dist[le], Le(q, de)));
      while (ne < ee);
    v(wn, W), fe = W[wn * 2 + 1];
  }
  function pe() {
    ae > 8 ? De(ie) : ae > 0 && Ie(ie & 255), ie = 0, ae = 0;
  }
  function ge(W, Y, q) {
    pe(), fe = 8, De(Y), De(~Y), e.pending_buf.set(l.subarray(W, W + Y), e.pending), e.pending += Y;
  }
  function he(W, Y, q) {
    Le((Q_ << 1) + (q ? 1 : 0), 3), ge(W, Y);
  }
  function Be(W, Y, q) {
    let J, ne, le = 0;
    P > 0 ? (z.build_tree(e), se.build_tree(e), le = St(), J = e.opt_len + 3 + 7 >>> 3, ne = e.static_len + 3 + 7 >>> 3, ne <= J && (J = ne)) : J = ne = Y + 5, Y + 4 <= J && W != -1 ? he(W, Y, q) : ne == J ? (Le((ma << 1) + (q ? 1 : 0), 3), X(Je.static_ltree, Je.static_dtree)) : (Le((eg << 1) + (q ? 1 : 0), 3), d(z.max_code + 1, se.max_code + 1, le + 1), X(U, M)), Oe(), q && pe();
  }
  function ue(W) {
    Be(w >= 0 ? w : -1, T - w, W), w = T, t.flush_pending();
  }
  function ht() {
    let W, Y, q, J;
    do {
      if (J = p - k - T, J === 0 && T === 0 && k === 0)
        J = s;
      else if (J == -1)
        J--;
      else if (T >= s + s - yt) {
        l.set(l.subarray(s, s + s), 0), H -= s, T -= s, w -= s, W = g, q = W;
        do
          Y = m[--q] & 65535, m[q] = Y >= s ? Y - s : 0;
        while (--W !== 0);
        W = s, q = W;
        do
          Y = c[--q] & 65535, c[q] = Y >= s ? Y - s : 0;
        while (--W !== 0);
        J += s;
      }
      if (t.avail_in === 0)
        return;
      W = t.read_buf(l, T + k, J), k += W, k >= Fe && (h = l[T] & 255, h = (h << _ ^ l[T + 1] & 255) & y);
    } while (k < yt && t.avail_in !== 0);
  }
  function rt(W) {
    let Y = 65535, q;
    for (Y > i - 5 && (Y = i - 5); ; ) {
      if (k <= 1) {
        if (ht(), k === 0 && W == Qr)
          return Et;
        if (k === 0)
          break;
      }
      if (T += k, k = 0, q = w + Y, (T === 0 || T >= q) && (k = T - q, T = q, ue(!1), t.avail_out === 0) || T - w >= s - yt && (ue(!1), t.avail_out === 0))
        return Et;
    }
    return ue(W == pt), t.avail_out === 0 ? W == pt ? bn : Et : W == pt ? gs : _s;
  }
  function Ct(W) {
    let Y = L, q = T, J, ne, le = A;
    const de = T > s - yt ? T - (s - yt) : 0;
    let We = N;
    const ce = o, ve = T + Ds;
    let j = l[q + le - 1], oe = l[q + le];
    A >= $ && (Y >>= 2), We > k && (We = k);
    do
      if (J = W, !(l[J + le] != oe || l[J + le - 1] != j || l[J] != l[q] || l[++J] != l[q + 1])) {
        q += 2, J++;
        do
          ;
        while (l[++q] == l[++J] && l[++q] == l[++J] && l[++q] == l[++J] && l[++q] == l[++J] && l[++q] == l[++J] && l[++q] == l[++J] && l[++q] == l[++J] && l[++q] == l[++J] && q < ve);
        if (ne = Ds - (ve - q), q = ve - Ds, ne > le) {
          if (H = W, le = ne, ne >= We)
            break;
          j = l[q + le - 1], oe = l[q + le];
        }
      }
    while ((W = c[W & ce] & 65535) > de && --Y !== 0);
    return le <= k ? le : k;
  }
  function wi(W) {
    let Y = 0, q;
    for (; ; ) {
      if (k < yt) {
        if (ht(), k < yt && W == Qr)
          return Et;
        if (k === 0)
          break;
      }
      if (k >= Fe && (h = (h << _ ^ l[T + (Fe - 1)] & 255) & y, Y = m[h] & 65535, c[T & o] = m[h], m[h] = T), Y !== 0 && (T - Y & 65535) <= s - yt && I != hs && (C = Ct(Y)), C >= Fe)
        if (q = K(T - H, C - Fe), k -= C, C <= S && k >= Fe) {
          C--;
          do
            T++, h = (h << _ ^ l[T + (Fe - 1)] & 255) & y, Y = m[h] & 65535, c[T & o] = m[h], m[h] = T;
          while (--C !== 0);
          T++;
        } else
          T += C, C = 0, h = l[T] & 255, h = (h << _ ^ l[T + 1] & 255) & y;
      else
        q = K(0, l[T] & 255), k--, T++;
      if (q && (ue(!1), t.avail_out === 0))
        return Et;
    }
    return ue(W == pt), t.avail_out === 0 ? W == pt ? bn : Et : W == pt ? gs : _s;
  }
  function nt(W) {
    let Y = 0, q, J;
    for (; ; ) {
      if (k < yt) {
        if (ht(), k < yt && W == Qr)
          return Et;
        if (k === 0)
          break;
      }
      if (k >= Fe && (h = (h << _ ^ l[T + (Fe - 1)] & 255) & y, Y = m[h] & 65535, c[T & o] = m[h], m[h] = T), A = C, E = H, C = Fe - 1, Y !== 0 && A < S && (T - Y & 65535) <= s - yt && (I != hs && (C = Ct(Y)), C <= 5 && (I == W_ || C == Fe && T - H > 4096) && (C = Fe - 1)), A >= Fe && C <= A) {
        J = T + k - Fe, q = K(T - 1 - E, A - Fe), k -= A - 1, A -= 2;
        do
          ++T <= J && (h = (h << _ ^ l[T + (Fe - 1)] & 255) & y, Y = m[h] & 65535, c[T & o] = m[h], m[h] = T);
        while (--A !== 0);
        if (D = 0, C = Fe - 1, T++, q && (ue(!1), t.avail_out === 0))
          return Et;
      } else if (D !== 0) {
        if (q = K(0, l[T - 1] & 255), q && ue(!1), T++, k--, t.avail_out === 0)
          return Et;
      } else
        D = 1, T++, k--;
    }
    return D !== 0 && (q = K(0, l[T - 1] & 255), D = 0), ue(W == pt), t.avail_out === 0 ? W == pt ? bn : Et : W == pt ? gs : _s;
  }
  function Mr(W) {
    return W.total_in = W.total_out = 0, W.msg = null, e.pending = 0, e.pending_out = 0, r = ws, a = Qr, Xe(), Pe(), $t;
  }
  e.deflateInit = function(W, Y, q, J, ne, le) {
    return J || (J = ha), ne || (ne = X_), le || (le = M_), W.msg = null, Y == Js && (Y = 6), ne < 1 || ne > Y_ || J != ha || q < 9 || q > 15 || Y < 0 || Y > 9 || le < 0 || le > hs ? Dt : (W.dstate = e, n = q, s = 1 << n, o = s - 1, R = ne + 7, g = 1 << R, y = g - 1, _ = Math.floor((R + Fe - 1) / Fe), l = new Uint8Array(s * 2), c = [], m = [], Q = 1 << ne + 6, e.pending_buf = new Uint8Array(Q * 4), i = Q * 4, e.dist_buf = new Uint16Array(Q), e.lc_buf = new Uint8Array(Q), P = Y, I = le, Mr(W));
  }, e.deflateEnd = function() {
    return r != da && r != ws && r != vn ? Dt : (e.lc_buf = null, e.dist_buf = null, e.pending_buf = null, m = null, c = null, l = null, e.dstate = null, r == ws ? K_ : $t);
  }, e.deflateParams = function(W, Y, q) {
    let J = $t;
    return Y == Js && (Y = 6), Y < 0 || Y > 9 || q < 0 || q > hs ? Dt : (Lt[P].func != Lt[Y].func && W.total_in !== 0 && (J = W.deflate(df)), P != Y && (P = Y, S = Lt[P].max_lazy, $ = Lt[P].good_length, N = Lt[P].nice_length, L = Lt[P].max_chain), I = q, J);
  }, e.deflateSetDictionary = function(W, Y, q) {
    let J = q, ne, le = 0;
    if (!Y || r != da)
      return Dt;
    if (J < Fe)
      return $t;
    for (J > s - yt && (J = s - yt, le = q - J), l.set(Y.subarray(le, le + J), 0), T = J, w = J, h = l[0] & 255, h = (h << _ ^ l[1] & 255) & y, ne = 0; ne <= J - Fe; ne++)
      h = (h << _ ^ l[ne + (Fe - 1)] & 255) & y, c[ne & o] = m[h], m[h] = ne;
    return $t;
  }, e.deflate = function(W, Y) {
    let q, J, ne, le, de;
    if (Y > pt || Y < 0)
      return Dt;
    if (!W.next_out || !W.next_in && W.avail_in !== 0 || r == vn && Y != pt)
      return W.msg = ys[ms - Dt], Dt;
    if (W.avail_out === 0)
      return W.msg = ys[ms - Vr], Vr;
    if (t = W, le = a, a = Y, r == da && (J = ha + (n - 8 << 4) << 8, ne = (P - 1 & 255) >> 1, ne > 3 && (ne = 3), J |= ne << 6, T !== 0 && (J |= J_), J += 31 - J % 31, r = ws, ft(J)), e.pending !== 0) {
      if (t.flush_pending(), t.avail_out === 0)
        return a = -1, $t;
    } else if (t.avail_in === 0 && Y <= le && Y != pt)
      return t.msg = ys[ms - Vr], Vr;
    if (r == vn && t.avail_in !== 0)
      return W.msg = ys[ms - Vr], Vr;
    if (t.avail_in !== 0 || k !== 0 || Y != Qr && r != vn) {
      switch (de = -1, Lt[P].func) {
        case Jc:
          de = rt(Y);
          break;
        case Is:
          de = wi(Y);
          break;
        case Er:
          de = nt(Y);
          break;
      }
      if ((de == bn || de == gs) && (r = vn), de == Et || de == bn)
        return t.avail_out === 0 && (a = -1), $t;
      if (de == _s) {
        if (Y == df)
          B();
        else if (he(0, 0, !1), Y == q_)
          for (q = 0; q < g; q++)
            m[q] = 0;
        if (t.flush_pending(), t.avail_out === 0)
          return a = -1, $t;
      }
    }
    return Y != pt ? $t : Xc;
  };
}
function Qc() {
  const e = this;
  e.next_in_index = 0, e.next_out_index = 0, e.avail_in = 0, e.total_in = 0, e.avail_out = 0, e.total_out = 0;
}
Qc.prototype = {
  deflateInit(e, t) {
    const r = this;
    return r.dstate = new tg(), t || (t = Mn), r.dstate.deflateInit(r, e, t);
  },
  deflate(e) {
    const t = this;
    return t.dstate ? t.dstate.deflate(t, e) : Dt;
  },
  deflateEnd() {
    const e = this;
    if (!e.dstate)
      return Dt;
    const t = e.dstate.deflateEnd();
    return e.dstate = null, t;
  },
  deflateParams(e, t) {
    const r = this;
    return r.dstate ? r.dstate.deflateParams(r, e, t) : Dt;
  },
  deflateSetDictionary(e, t) {
    const r = this;
    return r.dstate ? r.dstate.deflateSetDictionary(r, e, t) : Dt;
  },
  // Read a new buffer from the current input stream, update the
  // total number of bytes read. All deflate() input goes through
  // this function so some applications may wish to modify it to avoid
  // allocating a large strm->next_in buffer and copying from it.
  // (See also flush_pending()).
  read_buf(e, t, r) {
    const i = this;
    let a = i.avail_in;
    return a > r && (a = r), a === 0 ? 0 : (i.avail_in -= a, e.set(i.next_in.subarray(i.next_in_index, i.next_in_index + a), t), i.next_in_index += a, i.total_in += a, a);
  },
  // Flush as much pending output as possible. All deflate() output goes
  // through this function so some applications may wish to modify it
  // to avoid allocating a large strm->next_out buffer and copying into it.
  // (See also read_buf()).
  flush_pending() {
    const e = this;
    let t = e.dstate.pending;
    t > e.avail_out && (t = e.avail_out), t !== 0 && (e.next_out.set(e.dstate.pending_buf.subarray(e.dstate.pending_out, e.dstate.pending_out + t), e.next_out_index), e.next_out_index += t, e.dstate.pending_out += t, e.total_out += t, e.avail_out -= t, e.dstate.pending -= t, e.dstate.pending === 0 && (e.dstate.pending_out = 0));
  }
};
function rg(e) {
  const t = this, r = new Qc(), i = ng(e && e.chunkSize ? e.chunkSize : 64 * 1024), a = Qr, s = new Uint8Array(i);
  let n = e ? e.level : Js;
  typeof n > "u" && (n = Js), r.deflateInit(n), r.next_out = s, t.append = function(o, l) {
    let p, c, m = 0, h = 0, g = 0;
    const R = [];
    if (o.length) {
      r.next_in_index = 0, r.next_in = o, r.avail_in = o.length;
      do {
        if (r.next_out_index = 0, r.avail_out = i, p = r.deflate(a), p != $t)
          throw new Error("deflating: " + r.msg);
        r.next_out_index && (r.next_out_index == i ? R.push(new Uint8Array(s)) : R.push(s.subarray(0, r.next_out_index))), g += r.next_out_index, l && r.next_in_index > 0 && r.next_in_index != m && (l(r.next_in_index), m = r.next_in_index);
      } while (r.avail_in > 0 || r.avail_out === 0);
      return R.length > 1 ? (c = new Uint8Array(g), R.forEach(function(y) {
        c.set(y, h), h += y.length;
      })) : c = R[0] ? new Uint8Array(R[0]) : new Uint8Array(), c;
    }
  }, t.flush = function() {
    let o, l, p = 0, c = 0;
    const m = [];
    do {
      if (r.next_out_index = 0, r.avail_out = i, o = r.deflate(pt), o != Xc && o != $t)
        throw new Error("deflating: " + r.msg);
      i - r.avail_out > 0 && m.push(s.slice(0, r.next_out_index)), c += r.next_out_index;
    } while (r.avail_in > 0 || r.avail_out === 0);
    return r.deflateEnd(), l = new Uint8Array(c), m.forEach(function(h) {
      l.set(h, p), p += h.length;
    }), l;
  };
}
function ng(e) {
  return e + 5 * (Math.floor(e / 16383) + 1);
}
const sg = 15, be = 0, sr = 1, ig = 2, ct = -2, $e = -3, yf = -4, ir = -5, gt = [
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
], eu = 1440, ag = 0, og = 4, lg = 9, fg = 5, pg = [
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  192,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  160,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  224,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  144,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  208,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  176,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  240,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  200,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  168,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  232,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  152,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  216,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  184,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  248,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  196,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  164,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  228,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  148,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  212,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  180,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  244,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  204,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  172,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  236,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  156,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  220,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  188,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  252,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  194,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  162,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  226,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  146,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  210,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  178,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  242,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  202,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  170,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  234,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  154,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  218,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  186,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  250,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  198,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  166,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  230,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  150,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  214,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  182,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  246,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  206,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  174,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  238,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  158,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  222,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  190,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  254,
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  193,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  161,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  225,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  145,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  209,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  177,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  241,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  201,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  169,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  233,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  153,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  217,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  185,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  249,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  197,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  165,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  229,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  149,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  213,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  181,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  245,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  205,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  173,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  237,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  157,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  221,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  189,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  253,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  195,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  163,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  227,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  147,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  211,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  179,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  243,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  203,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  171,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  235,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  155,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  219,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  187,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  251,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  199,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  167,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  231,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  151,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  215,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  183,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  247,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  207,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  175,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  239,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  159,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  223,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  191,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  255
], cg = [
  80,
  5,
  1,
  87,
  5,
  257,
  83,
  5,
  17,
  91,
  5,
  4097,
  81,
  5,
  5,
  89,
  5,
  1025,
  85,
  5,
  65,
  93,
  5,
  16385,
  80,
  5,
  3,
  88,
  5,
  513,
  84,
  5,
  33,
  92,
  5,
  8193,
  82,
  5,
  9,
  90,
  5,
  2049,
  86,
  5,
  129,
  192,
  5,
  24577,
  80,
  5,
  2,
  87,
  5,
  385,
  83,
  5,
  25,
  91,
  5,
  6145,
  81,
  5,
  7,
  89,
  5,
  1537,
  85,
  5,
  97,
  93,
  5,
  24577,
  80,
  5,
  4,
  88,
  5,
  769,
  84,
  5,
  49,
  92,
  5,
  12289,
  82,
  5,
  13,
  90,
  5,
  3073,
  86,
  5,
  193,
  192,
  5,
  24577
], ug = [
  // Copy lengths for literal codes 257..285
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
], dg = [
  // Extra bits for literal codes 257..285
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  112,
  112
  // 112==invalid
], hg = [
  // Copy offsets for distance codes 0..29
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
], mg = [
  // Extra bits for distance codes
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
], fr = 15;
function Va() {
  const e = this;
  let t, r, i, a, s, n;
  function o(p, c, m, h, g, R, y, _, w, C, E) {
    let D, T, H, k, A, L, S, P, I, $, N, U, M, Z, z;
    $ = 0, A = m;
    do
      i[p[c + $]]++, $++, A--;
    while (A !== 0);
    if (i[0] == m)
      return y[0] = -1, _[0] = 0, be;
    for (P = _[0], L = 1; L <= fr && i[L] === 0; L++)
      ;
    for (S = L, P < L && (P = L), A = fr; A !== 0 && i[A] === 0; A--)
      ;
    for (H = A, P > A && (P = A), _[0] = P, Z = 1 << L; L < A; L++, Z <<= 1)
      if ((Z -= i[L]) < 0)
        return $e;
    if ((Z -= i[A]) < 0)
      return $e;
    for (i[A] += Z, n[1] = L = 0, $ = 1, M = 2; --A !== 0; )
      n[M] = L += i[$], M++, $++;
    A = 0, $ = 0;
    do
      (L = p[c + $]) !== 0 && (E[n[L]++] = A), $++;
    while (++A < m);
    for (m = n[H], n[0] = A = 0, $ = 0, k = -1, U = -P, s[0] = 0, N = 0, z = 0; S <= H; S++)
      for (D = i[S]; D-- !== 0; ) {
        for (; S > U + P; ) {
          if (k++, U += P, z = H - U, z = z > P ? P : z, (T = 1 << (L = S - U)) > D + 1 && (T -= D + 1, M = S, L < z))
            for (; ++L < z && !((T <<= 1) <= i[++M]); )
              T -= i[M];
          if (z = 1 << L, C[0] + z > eu)
            return $e;
          s[k] = N = /* hp+ */
          C[0], C[0] += z, k !== 0 ? (n[k] = A, a[0] = /* (byte) */
          L, a[1] = /* (byte) */
          P, L = A >>> U - P, a[2] = /* (int) */
          N - s[k - 1] - L, w.set(a, (s[k - 1] + L) * 3)) : y[0] = N;
        }
        for (a[1] = /* (byte) */
        S - U, $ >= m ? a[0] = 192 : E[$] < h ? (a[0] = /* (byte) */
        E[$] < 256 ? 0 : 96, a[2] = E[$++]) : (a[0] = /* (byte) */
        R[E[$] - h] + 16 + 64, a[2] = g[E[$++] - h]), T = 1 << S - U, L = A >>> U; L < z; L += T)
          w.set(a, (N + L) * 3);
        for (L = 1 << S - 1; A & L; L >>>= 1)
          A ^= L;
        for (A ^= L, I = (1 << U) - 1; (A & I) != n[k]; )
          k--, U -= P, I = (1 << U) - 1;
      }
    return Z !== 0 && H != 1 ? ir : be;
  }
  function l(p) {
    let c;
    for (t || (t = [], r = [], i = new Int32Array(fr + 1), a = [], s = new Int32Array(fr), n = new Int32Array(fr + 1)), r.length < p && (r = []), c = 0; c < p; c++)
      r[c] = 0;
    for (c = 0; c < fr + 1; c++)
      i[c] = 0;
    for (c = 0; c < 3; c++)
      a[c] = 0;
    s.set(i.subarray(0, fr), 0), n.set(i.subarray(0, fr + 1), 0);
  }
  e.inflate_trees_bits = function(p, c, m, h, g) {
    let R;
    return l(19), t[0] = 0, R = o(p, 0, 19, 19, null, null, m, c, h, t, r), R == $e ? g.msg = "oversubscribed dynamic bit lengths tree" : (R == ir || c[0] === 0) && (g.msg = "incomplete dynamic bit lengths tree", R = $e), R;
  }, e.inflate_trees_dynamic = function(p, c, m, h, g, R, y, _, w) {
    let C;
    return l(288), t[0] = 0, C = o(m, 0, p, 257, ug, dg, R, h, _, t, r), C != be || h[0] === 0 ? (C == $e ? w.msg = "oversubscribed literal/length tree" : C != yf && (w.msg = "incomplete literal/length tree", C = $e), C) : (l(288), C = o(m, p, c, 0, hg, mg, y, g, _, t, r), C != be || g[0] === 0 && p > 257 ? (C == $e ? w.msg = "oversubscribed distance tree" : C == ir ? (w.msg = "incomplete distance tree", C = $e) : C != yf && (w.msg = "empty distance tree with lengths", C = $e), C) : be);
  };
}
Va.inflate_trees_fixed = function(e, t, r, i) {
  return e[0] = lg, t[0] = fg, r[0] = pg, i[0] = cg, be;
};
const bs = 0, _f = 1, gf = 2, wf = 3, bf = 4, vf = 5, xf = 6, ya = 7, Sf = 8, vs = 9;
function yg() {
  const e = this;
  let t, r = 0, i, a = 0, s = 0, n = 0, o = 0, l = 0, p = 0, c = 0, m, h = 0, g, R = 0;
  function y(_, w, C, E, D, T, H, k) {
    let A, L, S, P, I, $, N, U, M, Z, z, se, G, Q, ee, V;
    N = k.next_in_index, U = k.avail_in, I = H.bitb, $ = H.bitk, M = H.write, Z = M < H.read ? H.read - M - 1 : H.end - M, z = gt[_], se = gt[w];
    do {
      for (; $ < 20; )
        U--, I |= (k.read_byte(N++) & 255) << $, $ += 8;
      if (A = I & z, L = C, S = E, V = (S + A) * 3, (P = L[V]) === 0) {
        I >>= L[V + 1], $ -= L[V + 1], H.win[M++] = /* (byte) */
        L[V + 2], Z--;
        continue;
      }
      do {
        if (I >>= L[V + 1], $ -= L[V + 1], P & 16) {
          for (P &= 15, G = L[V + 2] + /* (int) */
          (I & gt[P]), I >>= P, $ -= P; $ < 15; )
            U--, I |= (k.read_byte(N++) & 255) << $, $ += 8;
          A = I & se, L = D, S = T, V = (S + A) * 3, P = L[V];
          do
            if (I >>= L[V + 1], $ -= L[V + 1], P & 16) {
              for (P &= 15; $ < P; )
                U--, I |= (k.read_byte(N++) & 255) << $, $ += 8;
              if (Q = L[V + 2] + (I & gt[P]), I >>= P, $ -= P, Z -= G, M >= Q)
                ee = M - Q, M - ee > 0 && 2 > M - ee ? (H.win[M++] = H.win[ee++], H.win[M++] = H.win[ee++], G -= 2) : (H.win.set(H.win.subarray(ee, ee + 2), M), M += 2, ee += 2, G -= 2);
              else {
                ee = M - Q;
                do
                  ee += H.end;
                while (ee < 0);
                if (P = H.end - ee, G > P) {
                  if (G -= P, M - ee > 0 && P > M - ee)
                    do
                      H.win[M++] = H.win[ee++];
                    while (--P !== 0);
                  else
                    H.win.set(H.win.subarray(ee, ee + P), M), M += P, ee += P, P = 0;
                  ee = 0;
                }
              }
              if (M - ee > 0 && G > M - ee)
                do
                  H.win[M++] = H.win[ee++];
                while (--G !== 0);
              else
                H.win.set(H.win.subarray(ee, ee + G), M), M += G, ee += G, G = 0;
              break;
            } else if (!(P & 64))
              A += L[V + 2], A += I & gt[P], V = (S + A) * 3, P = L[V];
            else
              return k.msg = "invalid distance code", G = k.avail_in - U, G = $ >> 3 < G ? $ >> 3 : G, U += G, N -= G, $ -= G << 3, H.bitb = I, H.bitk = $, k.avail_in = U, k.total_in += N - k.next_in_index, k.next_in_index = N, H.write = M, $e;
          while (!0);
          break;
        }
        if (P & 64)
          return P & 32 ? (G = k.avail_in - U, G = $ >> 3 < G ? $ >> 3 : G, U += G, N -= G, $ -= G << 3, H.bitb = I, H.bitk = $, k.avail_in = U, k.total_in += N - k.next_in_index, k.next_in_index = N, H.write = M, sr) : (k.msg = "invalid literal/length code", G = k.avail_in - U, G = $ >> 3 < G ? $ >> 3 : G, U += G, N -= G, $ -= G << 3, H.bitb = I, H.bitk = $, k.avail_in = U, k.total_in += N - k.next_in_index, k.next_in_index = N, H.write = M, $e);
        if (A += L[V + 2], A += I & gt[P], V = (S + A) * 3, (P = L[V]) === 0) {
          I >>= L[V + 1], $ -= L[V + 1], H.win[M++] = /* (byte) */
          L[V + 2], Z--;
          break;
        }
      } while (!0);
    } while (Z >= 258 && U >= 10);
    return G = k.avail_in - U, G = $ >> 3 < G ? $ >> 3 : G, U += G, N -= G, $ -= G << 3, H.bitb = I, H.bitk = $, k.avail_in = U, k.total_in += N - k.next_in_index, k.next_in_index = N, H.write = M, be;
  }
  e.init = function(_, w, C, E, D, T) {
    t = bs, p = /* (byte) */
    _, c = /* (byte) */
    w, m = C, h = E, g = D, R = T, i = null;
  }, e.proc = function(_, w, C) {
    let E, D, T, H = 0, k = 0, A = 0, L, S, P, I;
    for (A = w.next_in_index, L = w.avail_in, H = _.bitb, k = _.bitk, S = _.write, P = S < _.read ? _.read - S - 1 : _.end - S; ; )
      switch (t) {
        case bs:
          if (P >= 258 && L >= 10 && (_.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, C = y(p, c, m, h, g, R, _, w), A = w.next_in_index, L = w.avail_in, H = _.bitb, k = _.bitk, S = _.write, P = S < _.read ? _.read - S - 1 : _.end - S, C != be)) {
            t = C == sr ? ya : vs;
            break;
          }
          s = p, i = m, a = h, t = _f;
        case _f:
          for (E = s; k < E; ) {
            if (L !== 0)
              C = be;
            else
              return _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
            L--, H |= (w.read_byte(A++) & 255) << k, k += 8;
          }
          if (D = (a + (H & gt[E])) * 3, H >>>= i[D + 1], k -= i[D + 1], T = i[D], T === 0) {
            n = i[D + 2], t = xf;
            break;
          }
          if (T & 16) {
            o = T & 15, r = i[D + 2], t = gf;
            break;
          }
          if (!(T & 64)) {
            s = T, a = D / 3 + i[D + 2];
            break;
          }
          if (T & 32) {
            t = ya;
            break;
          }
          return t = vs, w.msg = "invalid literal/length code", C = $e, _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
        case gf:
          for (E = o; k < E; ) {
            if (L !== 0)
              C = be;
            else
              return _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
            L--, H |= (w.read_byte(A++) & 255) << k, k += 8;
          }
          r += H & gt[E], H >>= E, k -= E, s = c, i = g, a = R, t = wf;
        case wf:
          for (E = s; k < E; ) {
            if (L !== 0)
              C = be;
            else
              return _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
            L--, H |= (w.read_byte(A++) & 255) << k, k += 8;
          }
          if (D = (a + (H & gt[E])) * 3, H >>= i[D + 1], k -= i[D + 1], T = i[D], T & 16) {
            o = T & 15, l = i[D + 2], t = bf;
            break;
          }
          if (!(T & 64)) {
            s = T, a = D / 3 + i[D + 2];
            break;
          }
          return t = vs, w.msg = "invalid distance code", C = $e, _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
        case bf:
          for (E = o; k < E; ) {
            if (L !== 0)
              C = be;
            else
              return _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
            L--, H |= (w.read_byte(A++) & 255) << k, k += 8;
          }
          l += H & gt[E], H >>= E, k -= E, t = vf;
        case vf:
          for (I = S - l; I < 0; )
            I += _.end;
          for (; r !== 0; ) {
            if (P === 0 && (S == _.end && _.read !== 0 && (S = 0, P = S < _.read ? _.read - S - 1 : _.end - S), P === 0 && (_.write = S, C = _.inflate_flush(w, C), S = _.write, P = S < _.read ? _.read - S - 1 : _.end - S, S == _.end && _.read !== 0 && (S = 0, P = S < _.read ? _.read - S - 1 : _.end - S), P === 0)))
              return _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
            _.win[S++] = _.win[I++], P--, I == _.end && (I = 0), r--;
          }
          t = bs;
          break;
        case xf:
          if (P === 0 && (S == _.end && _.read !== 0 && (S = 0, P = S < _.read ? _.read - S - 1 : _.end - S), P === 0 && (_.write = S, C = _.inflate_flush(w, C), S = _.write, P = S < _.read ? _.read - S - 1 : _.end - S, S == _.end && _.read !== 0 && (S = 0, P = S < _.read ? _.read - S - 1 : _.end - S), P === 0)))
            return _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
          C = be, _.win[S++] = /* (byte) */
          n, P--, t = bs;
          break;
        case ya:
          if (k > 7 && (k -= 8, L++, A--), _.write = S, C = _.inflate_flush(w, C), S = _.write, P = S < _.read ? _.read - S - 1 : _.end - S, _.read != _.write)
            return _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
          t = Sf;
        case Sf:
          return C = sr, _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
        case vs:
          return C = $e, _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
        default:
          return C = ct, _.bitb = H, _.bitk = k, w.avail_in = L, w.total_in += A - w.next_in_index, w.next_in_index = A, _.write = S, _.inflate_flush(w, C);
      }
  }, e.free = function() {
  };
}
const Ef = [
  // Order of the bit length code lengths
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
], Zr = 0, _a = 1, kf = 2, Pf = 3, Af = 4, Tf = 5, xs = 6, Ss = 7, Of = 8, Sr = 9;
function _g(e, t) {
  const r = this;
  let i = Zr, a = 0, s = 0, n = 0, o;
  const l = [0], p = [0], c = new yg();
  let m = 0, h = new Int32Array(eu * 3);
  const g = 0, R = new Va();
  r.bitk = 0, r.bitb = 0, r.win = new Uint8Array(t), r.end = t, r.read = 0, r.write = 0, r.reset = function(y, _) {
    _ && (_[0] = g), i == xs && c.free(y), i = Zr, r.bitk = 0, r.bitb = 0, r.read = r.write = 0;
  }, r.reset(e, null), r.inflate_flush = function(y, _) {
    let w, C, E;
    return C = y.next_out_index, E = r.read, w = /* (int) */
    (E <= r.write ? r.write : r.end) - E, w > y.avail_out && (w = y.avail_out), w !== 0 && _ == ir && (_ = be), y.avail_out -= w, y.total_out += w, y.next_out.set(r.win.subarray(E, E + w), C), C += w, E += w, E == r.end && (E = 0, r.write == r.end && (r.write = 0), w = r.write - E, w > y.avail_out && (w = y.avail_out), w !== 0 && _ == ir && (_ = be), y.avail_out -= w, y.total_out += w, y.next_out.set(r.win.subarray(E, E + w), C), C += w, E += w), y.next_out_index = C, r.read = E, _;
  }, r.proc = function(y, _) {
    let w, C, E, D, T, H, k, A;
    for (D = y.next_in_index, T = y.avail_in, C = r.bitb, E = r.bitk, H = r.write, k = /* (int) */
    H < r.read ? r.read - H - 1 : r.end - H; ; ) {
      let L, S, P, I, $, N, U, M;
      switch (i) {
        case Zr:
          for (; E < 3; ) {
            if (T !== 0)
              _ = be;
            else
              return r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
            T--, C |= (y.read_byte(D++) & 255) << E, E += 8;
          }
          switch (w = /* (int) */
          C & 7, m = w & 1, w >>> 1) {
            case 0:
              C >>>= 3, E -= 3, w = E & 7, C >>>= w, E -= w, i = _a;
              break;
            case 1:
              L = [], S = [], P = [[]], I = [[]], Va.inflate_trees_fixed(L, S, P, I), c.init(L[0], S[0], P[0], 0, I[0], 0), C >>>= 3, E -= 3, i = xs;
              break;
            case 2:
              C >>>= 3, E -= 3, i = Pf;
              break;
            case 3:
              return C >>>= 3, E -= 3, i = Sr, y.msg = "invalid block type", _ = $e, r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
          }
          break;
        case _a:
          for (; E < 32; ) {
            if (T !== 0)
              _ = be;
            else
              return r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
            T--, C |= (y.read_byte(D++) & 255) << E, E += 8;
          }
          if ((~C >>> 16 & 65535) != (C & 65535))
            return i = Sr, y.msg = "invalid stored block lengths", _ = $e, r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
          a = C & 65535, C = E = 0, i = a !== 0 ? kf : m !== 0 ? Ss : Zr;
          break;
        case kf:
          if (T === 0 || k === 0 && (H == r.end && r.read !== 0 && (H = 0, k = /* (int) */
          H < r.read ? r.read - H - 1 : r.end - H), k === 0 && (r.write = H, _ = r.inflate_flush(y, _), H = r.write, k = /* (int) */
          H < r.read ? r.read - H - 1 : r.end - H, H == r.end && r.read !== 0 && (H = 0, k = /* (int) */
          H < r.read ? r.read - H - 1 : r.end - H), k === 0)))
            return r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
          if (_ = be, w = a, w > T && (w = T), w > k && (w = k), r.win.set(y.read_buf(D, w), H), D += w, T -= w, H += w, k -= w, (a -= w) !== 0)
            break;
          i = m !== 0 ? Ss : Zr;
          break;
        case Pf:
          for (; E < 14; ) {
            if (T !== 0)
              _ = be;
            else
              return r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
            T--, C |= (y.read_byte(D++) & 255) << E, E += 8;
          }
          if (s = w = C & 16383, (w & 31) > 29 || (w >> 5 & 31) > 29)
            return i = Sr, y.msg = "too many length or distance symbols", _ = $e, r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
          if (w = 258 + (w & 31) + (w >> 5 & 31), !o || o.length < w)
            o = [];
          else
            for (A = 0; A < w; A++)
              o[A] = 0;
          C >>>= 14, E -= 14, n = 0, i = Af;
        case Af:
          for (; n < 4 + (s >>> 10); ) {
            for (; E < 3; ) {
              if (T !== 0)
                _ = be;
              else
                return r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
              T--, C |= (y.read_byte(D++) & 255) << E, E += 8;
            }
            o[Ef[n++]] = C & 7, C >>>= 3, E -= 3;
          }
          for (; n < 19; )
            o[Ef[n++]] = 0;
          if (l[0] = 7, w = R.inflate_trees_bits(o, l, p, h, y), w != be)
            return _ = w, _ == $e && (o = null, i = Sr), r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
          n = 0, i = Tf;
        case Tf:
          for (; w = s, !(n >= 258 + (w & 31) + (w >> 5 & 31)); ) {
            let Z, z;
            for (w = l[0]; E < w; ) {
              if (T !== 0)
                _ = be;
              else
                return r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
              T--, C |= (y.read_byte(D++) & 255) << E, E += 8;
            }
            if (w = h[(p[0] + (C & gt[w])) * 3 + 1], z = h[(p[0] + (C & gt[w])) * 3 + 2], z < 16)
              C >>>= w, E -= w, o[n++] = z;
            else {
              for (A = z == 18 ? 7 : z - 14, Z = z == 18 ? 11 : 3; E < w + A; ) {
                if (T !== 0)
                  _ = be;
                else
                  return r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
                T--, C |= (y.read_byte(D++) & 255) << E, E += 8;
              }
              if (C >>>= w, E -= w, Z += C & gt[A], C >>>= A, E -= A, A = n, w = s, A + Z > 258 + (w & 31) + (w >> 5 & 31) || z == 16 && A < 1)
                return o = null, i = Sr, y.msg = "invalid bit length repeat", _ = $e, r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
              z = z == 16 ? o[A - 1] : 0;
              do
                o[A++] = z;
              while (--Z !== 0);
              n = A;
            }
          }
          if (p[0] = -1, $ = [], N = [], U = [], M = [], $[0] = 9, N[0] = 6, w = s, w = R.inflate_trees_dynamic(257 + (w & 31), 1 + (w >> 5 & 31), o, $, N, U, M, h, y), w != be)
            return w == $e && (o = null, i = Sr), _ = w, r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
          c.init($[0], N[0], h, U[0], h, M[0]), i = xs;
        case xs:
          if (r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, (_ = c.proc(r, y, _)) != sr)
            return r.inflate_flush(y, _);
          if (_ = be, c.free(y), D = y.next_in_index, T = y.avail_in, C = r.bitb, E = r.bitk, H = r.write, k = /* (int) */
          H < r.read ? r.read - H - 1 : r.end - H, m === 0) {
            i = Zr;
            break;
          }
          i = Ss;
        case Ss:
          if (r.write = H, _ = r.inflate_flush(y, _), H = r.write, k = /* (int) */
          H < r.read ? r.read - H - 1 : r.end - H, r.read != r.write)
            return r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
          i = Of;
        case Of:
          return _ = sr, r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
        case Sr:
          return _ = $e, r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
        default:
          return _ = ct, r.bitb = C, r.bitk = E, y.avail_in = T, y.total_in += D - y.next_in_index, y.next_in_index = D, r.write = H, r.inflate_flush(y, _);
      }
    }
  }, r.free = function(y) {
    r.reset(y, null), r.win = null, h = null;
  }, r.set_dictionary = function(y, _, w) {
    r.win.set(y.subarray(_, _ + w), 0), r.read = r.write = w;
  }, r.sync_point = function() {
    return i == _a ? 1 : 0;
  };
}
const gg = 32, wg = 8, bg = 0, Cf = 1, Lf = 2, Rf = 3, $f = 4, If = 5, ga = 6, xn = 7, Df = 12, pr = 13, vg = [0, 0, 255, 255];
function xg() {
  const e = this;
  e.mode = 0, e.method = 0, e.was = [0], e.need = 0, e.marker = 0, e.wbits = 0;
  function t(r) {
    return !r || !r.istate ? ct : (r.total_in = r.total_out = 0, r.msg = null, r.istate.mode = xn, r.istate.blocks.reset(r, null), be);
  }
  e.inflateEnd = function(r) {
    return e.blocks && e.blocks.free(r), e.blocks = null, be;
  }, e.inflateInit = function(r, i) {
    return r.msg = null, e.blocks = null, i < 8 || i > 15 ? (e.inflateEnd(r), ct) : (e.wbits = i, r.istate.blocks = new _g(r, 1 << i), t(r), be);
  }, e.inflate = function(r, i) {
    let a, s;
    if (!r || !r.istate || !r.next_in)
      return ct;
    const n = r.istate;
    for (i = i == og ? ir : be, a = ir; ; )
      switch (n.mode) {
        case bg:
          if (r.avail_in === 0)
            return a;
          if (a = i, r.avail_in--, r.total_in++, ((n.method = r.read_byte(r.next_in_index++)) & 15) != wg) {
            n.mode = pr, r.msg = "unknown compression method", n.marker = 5;
            break;
          }
          if ((n.method >> 4) + 8 > n.wbits) {
            n.mode = pr, r.msg = "invalid win size", n.marker = 5;
            break;
          }
          n.mode = Cf;
        case Cf:
          if (r.avail_in === 0)
            return a;
          if (a = i, r.avail_in--, r.total_in++, s = r.read_byte(r.next_in_index++) & 255, ((n.method << 8) + s) % 31 !== 0) {
            n.mode = pr, r.msg = "incorrect header check", n.marker = 5;
            break;
          }
          if (!(s & gg)) {
            n.mode = xn;
            break;
          }
          n.mode = Lf;
        case Lf:
          if (r.avail_in === 0)
            return a;
          a = i, r.avail_in--, r.total_in++, n.need = (r.read_byte(r.next_in_index++) & 255) << 24 & 4278190080, n.mode = Rf;
        case Rf:
          if (r.avail_in === 0)
            return a;
          a = i, r.avail_in--, r.total_in++, n.need += (r.read_byte(r.next_in_index++) & 255) << 16 & 16711680, n.mode = $f;
        case $f:
          if (r.avail_in === 0)
            return a;
          a = i, r.avail_in--, r.total_in++, n.need += (r.read_byte(r.next_in_index++) & 255) << 8 & 65280, n.mode = If;
        case If:
          return r.avail_in === 0 ? a : (a = i, r.avail_in--, r.total_in++, n.need += r.read_byte(r.next_in_index++) & 255, n.mode = ga, ig);
        case ga:
          return n.mode = pr, r.msg = "need dictionary", n.marker = 0, ct;
        case xn:
          if (a = n.blocks.proc(r, a), a == $e) {
            n.mode = pr, n.marker = 0;
            break;
          }
          if (a == be && (a = i), a != sr)
            return a;
          a = i, n.blocks.reset(r, n.was), n.mode = Df;
        case Df:
          return r.avail_in = 0, sr;
        case pr:
          return $e;
        default:
          return ct;
      }
  }, e.inflateSetDictionary = function(r, i, a) {
    let s = 0, n = a;
    if (!r || !r.istate || r.istate.mode != ga)
      return ct;
    const o = r.istate;
    return n >= 1 << o.wbits && (n = (1 << o.wbits) - 1, s = a - n), o.blocks.set_dictionary(i, s, n), o.mode = xn, be;
  }, e.inflateSync = function(r) {
    let i, a, s, n, o;
    if (!r || !r.istate)
      return ct;
    const l = r.istate;
    if (l.mode != pr && (l.mode = pr, l.marker = 0), (i = r.avail_in) === 0)
      return ir;
    for (a = r.next_in_index, s = l.marker; i !== 0 && s < 4; )
      r.read_byte(a) == vg[s] ? s++ : r.read_byte(a) !== 0 ? s = 0 : s = 4 - s, a++, i--;
    return r.total_in += a - r.next_in_index, r.next_in_index = a, r.avail_in = i, l.marker = s, s != 4 ? $e : (n = r.total_in, o = r.total_out, t(r), r.total_in = n, r.total_out = o, l.mode = xn, be);
  }, e.inflateSyncPoint = function(r) {
    return !r || !r.istate || !r.istate.blocks ? ct : r.istate.blocks.sync_point();
  };
}
function tu() {
}
tu.prototype = {
  inflateInit(e) {
    const t = this;
    return t.istate = new xg(), e || (e = sg), t.istate.inflateInit(t, e);
  },
  inflate(e) {
    const t = this;
    return t.istate ? t.istate.inflate(t, e) : ct;
  },
  inflateEnd() {
    const e = this;
    if (!e.istate)
      return ct;
    const t = e.istate.inflateEnd(e);
    return e.istate = null, t;
  },
  inflateSync() {
    const e = this;
    return e.istate ? e.istate.inflateSync(e) : ct;
  },
  inflateSetDictionary(e, t) {
    const r = this;
    return r.istate ? r.istate.inflateSetDictionary(r, e, t) : ct;
  },
  read_byte(e) {
    return this.next_in[e];
  },
  read_buf(e, t) {
    return this.next_in.subarray(e, e + t);
  }
};
function Sg(e) {
  const t = this, r = new tu(), i = e && e.chunkSize ? Math.floor(e.chunkSize * 2) : 128 * 1024, a = ag, s = new Uint8Array(i);
  let n = !1;
  r.inflateInit(), r.next_out = s, t.append = function(o, l) {
    const p = [];
    let c, m, h = 0, g = 0, R = 0;
    if (o.length !== 0) {
      r.next_in_index = 0, r.next_in = o, r.avail_in = o.length;
      do {
        if (r.next_out_index = 0, r.avail_out = i, r.avail_in === 0 && !n && (r.next_in_index = 0, n = !0), c = r.inflate(a), n && c === ir) {
          if (r.avail_in !== 0)
            throw new Error("inflating: bad input");
        } else if (c !== be && c !== sr)
          throw new Error("inflating: " + r.msg);
        if ((n || c === sr) && r.avail_in === o.length)
          throw new Error("inflating: bad input");
        r.next_out_index && (r.next_out_index === i ? p.push(new Uint8Array(s)) : p.push(s.subarray(0, r.next_out_index))), R += r.next_out_index, l && r.next_in_index > 0 && r.next_in_index != h && (l(r.next_in_index), h = r.next_in_index);
      } while (r.avail_in > 0 || r.avail_out === 0);
      return p.length > 1 ? (m = new Uint8Array(R), p.forEach(function(y) {
        m.set(y, g), g += y.length;
      })) : m = p[0] ? new Uint8Array(p[0]) : new Uint8Array(), m;
    }
  }, t.flush = function() {
    r.inflateEnd();
  };
}
const Rr = 4294967295, mr = 65535, Eg = 8, kg = 0, Pg = 99, Ag = 67324752, Tg = 134695760, Hf = 33639248, Og = 101010256, Ff = 101075792, Cg = 117853008, Yr = 22, wa = 20, ba = 56, Lg = 1, Rg = 39169, $g = 10, Ig = 1, Dg = 21589, Hg = 28789, Fg = 25461, Bg = 6534, Bf = 1, Ng = 6, Nf = 8, jf = 2048, Uf = 16, Wf = 16384, Mf = 73, qf = "/", lt = void 0, xr = "undefined", ss = "function";
class Kf {
  constructor(t) {
    return class extends TransformStream {
      constructor(r, i) {
        const a = new t(i);
        super({
          transform(s, n) {
            n.enqueue(a.append(s));
          },
          flush(s) {
            const n = a.flush();
            n && s.enqueue(n);
          }
        });
      }
    };
  }
}
const jg = 64;
let ru = 2;
try {
  typeof navigator != xr && navigator.hardwareConcurrency && (ru = navigator.hardwareConcurrency);
} catch {
}
const Ug = {
  chunkSize: 512 * 1024,
  maxWorkers: ru,
  terminateWorkerTimeout: 5e3,
  useWebWorkers: !0,
  useCompressionStream: !0,
  workerScripts: lt,
  CompressionStreamNative: typeof CompressionStream != xr && CompressionStream,
  DecompressionStreamNative: typeof DecompressionStream != xr && DecompressionStream
}, yr = Object.assign({}, Ug);
function Wg() {
  return yr;
}
function Mg(e) {
  return Math.max(e.chunkSize, jg);
}
function Eo(e) {
  const {
    baseURL: t,
    chunkSize: r,
    maxWorkers: i,
    terminateWorkerTimeout: a,
    useCompressionStream: s,
    useWebWorkers: n,
    Deflate: o,
    Inflate: l,
    CompressionStream: p,
    DecompressionStream: c,
    workerScripts: m
  } = e;
  if (cr("baseURL", t), cr("chunkSize", r), cr("maxWorkers", i), cr("terminateWorkerTimeout", a), cr("useCompressionStream", s), cr("useWebWorkers", n), o && (yr.CompressionStream = new Kf(o)), l && (yr.DecompressionStream = new Kf(l)), cr("CompressionStream", p), cr("DecompressionStream", c), m !== lt) {
    const { deflate: h, inflate: g } = m;
    if ((h || g) && (yr.workerScripts || (yr.workerScripts = {})), h) {
      if (!Array.isArray(h))
        throw new Error("workerScripts.deflate must be an array");
      yr.workerScripts.deflate = h;
    }
    if (g) {
      if (!Array.isArray(g))
        throw new Error("workerScripts.inflate must be an array");
      yr.workerScripts.inflate = g;
    }
  }
}
function cr(e, t) {
  t !== lt && (yr[e] = t);
}
const va = {
  application: {
    "andrew-inset": "ez",
    annodex: "anx",
    "atom+xml": "atom",
    "atomcat+xml": "atomcat",
    "atomserv+xml": "atomsrv",
    bbolin: "lin",
    "cu-seeme": "cu",
    "davmount+xml": "davmount",
    dsptype: "tsp",
    ecmascript: [
      "es",
      "ecma"
    ],
    futuresplash: "spl",
    hta: "hta",
    "java-archive": "jar",
    "java-serialized-object": "ser",
    "java-vm": "class",
    m3g: "m3g",
    "mac-binhex40": "hqx",
    mathematica: [
      "nb",
      "ma",
      "mb"
    ],
    msaccess: "mdb",
    msword: [
      "doc",
      "dot",
      "wiz"
    ],
    mxf: "mxf",
    oda: "oda",
    ogg: "ogx",
    pdf: "pdf",
    "pgp-keys": "key",
    "pgp-signature": [
      "asc",
      "sig"
    ],
    "pics-rules": "prf",
    postscript: [
      "ps",
      "ai",
      "eps",
      "epsi",
      "epsf",
      "eps2",
      "eps3"
    ],
    rar: "rar",
    "rdf+xml": "rdf",
    "rss+xml": "rss",
    rtf: "rtf",
    "xhtml+xml": [
      "xhtml",
      "xht"
    ],
    xml: [
      "xml",
      "xsl",
      "xsd",
      "xpdl"
    ],
    "xspf+xml": "xspf",
    zip: "zip",
    "vnd.android.package-archive": "apk",
    "vnd.cinderella": "cdy",
    "vnd.google-earth.kml+xml": "kml",
    "vnd.google-earth.kmz": "kmz",
    "vnd.mozilla.xul+xml": "xul",
    "vnd.ms-excel": [
      "xls",
      "xlb",
      "xlt",
      "xlm",
      "xla",
      "xlc",
      "xlw"
    ],
    "vnd.ms-pki.seccat": "cat",
    "vnd.ms-pki.stl": "stl",
    "vnd.ms-powerpoint": [
      "ppt",
      "pps",
      "pot",
      "ppa",
      "pwz"
    ],
    "vnd.oasis.opendocument.chart": "odc",
    "vnd.oasis.opendocument.database": "odb",
    "vnd.oasis.opendocument.formula": "odf",
    "vnd.oasis.opendocument.graphics": "odg",
    "vnd.oasis.opendocument.graphics-template": "otg",
    "vnd.oasis.opendocument.image": "odi",
    "vnd.oasis.opendocument.presentation": "odp",
    "vnd.oasis.opendocument.presentation-template": "otp",
    "vnd.oasis.opendocument.spreadsheet": "ods",
    "vnd.oasis.opendocument.spreadsheet-template": "ots",
    "vnd.oasis.opendocument.text": "odt",
    "vnd.oasis.opendocument.text-master": [
      "odm",
      "otm"
    ],
    "vnd.oasis.opendocument.text-template": "ott",
    "vnd.oasis.opendocument.text-web": "oth",
    "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
    "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
    "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
    "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
    "vnd.openxmlformats-officedocument.presentationml.template": "potx",
    "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
    "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
    "vnd.smaf": "mmf",
    "vnd.stardivision.calc": "sdc",
    "vnd.stardivision.chart": "sds",
    "vnd.stardivision.draw": "sda",
    "vnd.stardivision.impress": "sdd",
    "vnd.stardivision.math": [
      "sdf",
      "smf"
    ],
    "vnd.stardivision.writer": [
      "sdw",
      "vor"
    ],
    "vnd.stardivision.writer-global": "sgl",
    "vnd.sun.xml.calc": "sxc",
    "vnd.sun.xml.calc.template": "stc",
    "vnd.sun.xml.draw": "sxd",
    "vnd.sun.xml.draw.template": "std",
    "vnd.sun.xml.impress": "sxi",
    "vnd.sun.xml.impress.template": "sti",
    "vnd.sun.xml.math": "sxm",
    "vnd.sun.xml.writer": "sxw",
    "vnd.sun.xml.writer.global": "sxg",
    "vnd.sun.xml.writer.template": "stw",
    "vnd.symbian.install": [
      "sis",
      "sisx"
    ],
    "vnd.visio": [
      "vsd",
      "vst",
      "vss",
      "vsw",
      "vsdx",
      "vssx",
      "vstx",
      "vssm",
      "vstm"
    ],
    "vnd.wap.wbxml": "wbxml",
    "vnd.wap.wmlc": "wmlc",
    "vnd.wap.wmlscriptc": "wmlsc",
    "vnd.wordperfect": "wpd",
    "vnd.wordperfect5.1": "wp5",
    "x-123": "wk",
    "x-7z-compressed": "7z",
    "x-abiword": "abw",
    "x-apple-diskimage": "dmg",
    "x-bcpio": "bcpio",
    "x-bittorrent": "torrent",
    "x-cbr": [
      "cbr",
      "cba",
      "cbt",
      "cb7"
    ],
    "x-cbz": "cbz",
    "x-cdf": [
      "cdf",
      "cda"
    ],
    "x-cdlink": "vcd",
    "x-chess-pgn": "pgn",
    "x-cpio": "cpio",
    "x-csh": "csh",
    "x-director": [
      "dir",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ],
    "x-dms": "dms",
    "x-doom": "wad",
    "x-dvi": "dvi",
    "x-httpd-eruby": "rhtml",
    "x-font": "pcf.Z",
    "x-freemind": "mm",
    "x-gnumeric": "gnumeric",
    "x-go-sgf": "sgf",
    "x-graphing-calculator": "gcf",
    "x-gtar": [
      "gtar",
      "taz"
    ],
    "x-hdf": "hdf",
    "x-httpd-php": [
      "phtml",
      "pht",
      "php"
    ],
    "x-httpd-php-source": "phps",
    "x-httpd-php3": "php3",
    "x-httpd-php3-preprocessed": "php3p",
    "x-httpd-php4": "php4",
    "x-httpd-php5": "php5",
    "x-ica": "ica",
    "x-info": "info",
    "x-internet-signup": [
      "ins",
      "isp"
    ],
    "x-iphone": "iii",
    "x-iso9660-image": "iso",
    "x-java-jnlp-file": "jnlp",
    "x-jmol": "jmz",
    "x-killustrator": "kil",
    "x-latex": "latex",
    "x-lyx": "lyx",
    "x-lzx": "lzx",
    "x-maker": [
      "frm",
      "fb",
      "fbdoc"
    ],
    "x-ms-wmd": "wmd",
    "x-msdos-program": [
      "com",
      "exe",
      "bat",
      "dll"
    ],
    "x-netcdf": [
      "nc"
    ],
    "x-ns-proxy-autoconfig": [
      "pac",
      "dat"
    ],
    "x-nwc": "nwc",
    "x-object": "o",
    "x-oz-application": "oza",
    "x-pkcs7-certreqresp": "p7r",
    "x-python-code": [
      "pyc",
      "pyo"
    ],
    "x-qgis": [
      "qgs",
      "shp",
      "shx"
    ],
    "x-quicktimeplayer": "qtl",
    "x-redhat-package-manager": [
      "rpm",
      "rpa"
    ],
    "x-ruby": "rb",
    "x-sh": "sh",
    "x-shar": "shar",
    "x-shockwave-flash": [
      "swf",
      "swfl"
    ],
    "x-silverlight": "scr",
    "x-stuffit": "sit",
    "x-sv4cpio": "sv4cpio",
    "x-sv4crc": "sv4crc",
    "x-tar": "tar",
    "x-tex-gf": "gf",
    "x-tex-pk": "pk",
    "x-texinfo": [
      "texinfo",
      "texi"
    ],
    "x-trash": [
      "~",
      "%",
      "bak",
      "old",
      "sik"
    ],
    "x-ustar": "ustar",
    "x-wais-source": "src",
    "x-wingz": "wz",
    "x-x509-ca-cert": [
      "crt",
      "der",
      "cer"
    ],
    "x-xcf": "xcf",
    "x-xfig": "fig",
    "x-xpinstall": "xpi",
    applixware: "aw",
    "atomsvc+xml": "atomsvc",
    "ccxml+xml": "ccxml",
    "cdmi-capability": "cdmia",
    "cdmi-container": "cdmic",
    "cdmi-domain": "cdmid",
    "cdmi-object": "cdmio",
    "cdmi-queue": "cdmiq",
    "docbook+xml": "dbk",
    "dssc+der": "dssc",
    "dssc+xml": "xdssc",
    "emma+xml": "emma",
    "epub+zip": "epub",
    exi: "exi",
    "font-tdpfr": "pfr",
    "gml+xml": "gml",
    "gpx+xml": "gpx",
    gxf: "gxf",
    hyperstudio: "stk",
    "inkml+xml": [
      "ink",
      "inkml"
    ],
    ipfix: "ipfix",
    "jsonml+json": "jsonml",
    "lost+xml": "lostxml",
    "mads+xml": "mads",
    marc: "mrc",
    "marcxml+xml": "mrcx",
    "mathml+xml": [
      "mathml",
      "mml"
    ],
    mbox: "mbox",
    "mediaservercontrol+xml": "mscml",
    "metalink+xml": "metalink",
    "metalink4+xml": "meta4",
    "mets+xml": "mets",
    "mods+xml": "mods",
    mp21: [
      "m21",
      "mp21"
    ],
    mp4: "mp4s",
    "oebps-package+xml": "opf",
    "omdoc+xml": "omdoc",
    onenote: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ],
    oxps: "oxps",
    "patch-ops-error+xml": "xer",
    "pgp-encrypted": "pgp",
    pkcs10: "p10",
    "pkcs7-mime": [
      "p7m",
      "p7c"
    ],
    "pkcs7-signature": "p7s",
    pkcs8: "p8",
    "pkix-attr-cert": "ac",
    "pkix-crl": "crl",
    "pkix-pkipath": "pkipath",
    pkixcmp: "pki",
    "pls+xml": "pls",
    "prs.cww": "cww",
    "pskc+xml": "pskcxml",
    "reginfo+xml": "rif",
    "relax-ng-compact-syntax": "rnc",
    "resource-lists+xml": "rl",
    "resource-lists-diff+xml": "rld",
    "rls-services+xml": "rs",
    "rpki-ghostbusters": "gbr",
    "rpki-manifest": "mft",
    "rpki-roa": "roa",
    "rsd+xml": "rsd",
    "sbml+xml": "sbml",
    "scvp-cv-request": "scq",
    "scvp-cv-response": "scs",
    "scvp-vp-request": "spq",
    "scvp-vp-response": "spp",
    sdp: "sdp",
    "set-payment-initiation": "setpay",
    "set-registration-initiation": "setreg",
    "shf+xml": "shf",
    "sparql-query": "rq",
    "sparql-results+xml": "srx",
    srgs: "gram",
    "srgs+xml": "grxml",
    "sru+xml": "sru",
    "ssdl+xml": "ssdl",
    "ssml+xml": "ssml",
    "tei+xml": [
      "tei",
      "teicorpus"
    ],
    "thraud+xml": "tfi",
    "timestamped-data": "tsd",
    "vnd.3gpp.pic-bw-large": "plb",
    "vnd.3gpp.pic-bw-small": "psb",
    "vnd.3gpp.pic-bw-var": "pvb",
    "vnd.3gpp2.tcap": "tcap",
    "vnd.3m.post-it-notes": "pwn",
    "vnd.accpac.simply.aso": "aso",
    "vnd.accpac.simply.imp": "imp",
    "vnd.acucobol": "acu",
    "vnd.acucorp": [
      "atc",
      "acutc"
    ],
    "vnd.adobe.air-application-installer-package+zip": "air",
    "vnd.adobe.formscentral.fcdt": "fcdt",
    "vnd.adobe.fxp": [
      "fxp",
      "fxpl"
    ],
    "vnd.adobe.xdp+xml": "xdp",
    "vnd.adobe.xfdf": "xfdf",
    "vnd.ahead.space": "ahead",
    "vnd.airzip.filesecure.azf": "azf",
    "vnd.airzip.filesecure.azs": "azs",
    "vnd.amazon.ebook": "azw",
    "vnd.americandynamics.acc": "acc",
    "vnd.amiga.ami": "ami",
    "vnd.anser-web-certificate-issue-initiation": "cii",
    "vnd.anser-web-funds-transfer-initiation": "fti",
    "vnd.antix.game-component": "atx",
    "vnd.apple.installer+xml": "mpkg",
    "vnd.apple.mpegurl": "m3u8",
    "vnd.aristanetworks.swi": "swi",
    "vnd.astraea-software.iota": "iota",
    "vnd.audiograph": "aep",
    "vnd.blueice.multipass": "mpm",
    "vnd.bmi": "bmi",
    "vnd.businessobjects": "rep",
    "vnd.chemdraw+xml": "cdxml",
    "vnd.chipnuts.karaoke-mmd": "mmd",
    "vnd.claymore": "cla",
    "vnd.cloanto.rp9": "rp9",
    "vnd.clonk.c4group": [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ],
    "vnd.cluetrust.cartomobile-config": "c11amc",
    "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
    "vnd.commonspace": "csp",
    "vnd.contact.cmsg": "cdbcmsg",
    "vnd.cosmocaller": "cmc",
    "vnd.crick.clicker": "clkx",
    "vnd.crick.clicker.keyboard": "clkk",
    "vnd.crick.clicker.palette": "clkp",
    "vnd.crick.clicker.template": "clkt",
    "vnd.crick.clicker.wordbank": "clkw",
    "vnd.criticaltools.wbs+xml": "wbs",
    "vnd.ctc-posml": "pml",
    "vnd.cups-ppd": "ppd",
    "vnd.curl.car": "car",
    "vnd.curl.pcurl": "pcurl",
    "vnd.dart": "dart",
    "vnd.data-vision.rdz": "rdz",
    "vnd.dece.data": [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ],
    "vnd.dece.ttml+xml": [
      "uvt",
      "uvvt"
    ],
    "vnd.dece.unspecified": [
      "uvx",
      "uvvx"
    ],
    "vnd.dece.zip": [
      "uvz",
      "uvvz"
    ],
    "vnd.denovo.fcselayout-link": "fe_launch",
    "vnd.dna": "dna",
    "vnd.dolby.mlp": "mlp",
    "vnd.dpgraph": "dpg",
    "vnd.dreamfactory": "dfac",
    "vnd.ds-keypoint": "kpxx",
    "vnd.dvb.ait": "ait",
    "vnd.dvb.service": "svc",
    "vnd.dynageo": "geo",
    "vnd.ecowin.chart": "mag",
    "vnd.enliven": "nml",
    "vnd.epson.esf": "esf",
    "vnd.epson.msf": "msf",
    "vnd.epson.quickanime": "qam",
    "vnd.epson.salt": "slt",
    "vnd.epson.ssf": "ssf",
    "vnd.eszigno3+xml": [
      "es3",
      "et3"
    ],
    "vnd.ezpix-album": "ez2",
    "vnd.ezpix-package": "ez3",
    "vnd.fdf": "fdf",
    "vnd.fdsn.mseed": "mseed",
    "vnd.fdsn.seed": [
      "seed",
      "dataless"
    ],
    "vnd.flographit": "gph",
    "vnd.fluxtime.clip": "ftc",
    "vnd.framemaker": [
      "fm",
      "frame",
      "maker",
      "book"
    ],
    "vnd.frogans.fnc": "fnc",
    "vnd.frogans.ltf": "ltf",
    "vnd.fsc.weblaunch": "fsc",
    "vnd.fujitsu.oasys": "oas",
    "vnd.fujitsu.oasys2": "oa2",
    "vnd.fujitsu.oasys3": "oa3",
    "vnd.fujitsu.oasysgp": "fg5",
    "vnd.fujitsu.oasysprs": "bh2",
    "vnd.fujixerox.ddd": "ddd",
    "vnd.fujixerox.docuworks": "xdw",
    "vnd.fujixerox.docuworks.binder": "xbd",
    "vnd.fuzzysheet": "fzs",
    "vnd.genomatix.tuxedo": "txd",
    "vnd.geogebra.file": "ggb",
    "vnd.geogebra.tool": "ggt",
    "vnd.geometry-explorer": [
      "gex",
      "gre"
    ],
    "vnd.geonext": "gxt",
    "vnd.geoplan": "g2w",
    "vnd.geospace": "g3w",
    "vnd.gmx": "gmx",
    "vnd.grafeq": [
      "gqf",
      "gqs"
    ],
    "vnd.groove-account": "gac",
    "vnd.groove-help": "ghf",
    "vnd.groove-identity-message": "gim",
    "vnd.groove-injector": "grv",
    "vnd.groove-tool-message": "gtm",
    "vnd.groove-tool-template": "tpl",
    "vnd.groove-vcard": "vcg",
    "vnd.hal+xml": "hal",
    "vnd.handheld-entertainment+xml": "zmm",
    "vnd.hbci": "hbci",
    "vnd.hhe.lesson-player": "les",
    "vnd.hp-hpgl": "hpgl",
    "vnd.hp-hpid": "hpid",
    "vnd.hp-hps": "hps",
    "vnd.hp-jlyt": "jlt",
    "vnd.hp-pcl": "pcl",
    "vnd.hp-pclxl": "pclxl",
    "vnd.hydrostatix.sof-data": "sfd-hdstx",
    "vnd.ibm.minipay": "mpy",
    "vnd.ibm.modcap": [
      "afp",
      "listafp",
      "list3820"
    ],
    "vnd.ibm.rights-management": "irm",
    "vnd.ibm.secure-container": "sc",
    "vnd.iccprofile": [
      "icc",
      "icm"
    ],
    "vnd.igloader": "igl",
    "vnd.immervision-ivp": "ivp",
    "vnd.immervision-ivu": "ivu",
    "vnd.insors.igm": "igm",
    "vnd.intercon.formnet": [
      "xpw",
      "xpx"
    ],
    "vnd.intergeo": "i2g",
    "vnd.intu.qbo": "qbo",
    "vnd.intu.qfx": "qfx",
    "vnd.ipunplugged.rcprofile": "rcprofile",
    "vnd.irepository.package+xml": "irp",
    "vnd.is-xpr": "xpr",
    "vnd.isac.fcs": "fcs",
    "vnd.jam": "jam",
    "vnd.jcp.javame.midlet-rms": "rms",
    "vnd.jisp": "jisp",
    "vnd.joost.joda-archive": "joda",
    "vnd.kahootz": [
      "ktz",
      "ktr"
    ],
    "vnd.kde.karbon": "karbon",
    "vnd.kde.kchart": "chrt",
    "vnd.kde.kformula": "kfo",
    "vnd.kde.kivio": "flw",
    "vnd.kde.kontour": "kon",
    "vnd.kde.kpresenter": [
      "kpr",
      "kpt"
    ],
    "vnd.kde.kspread": "ksp",
    "vnd.kde.kword": [
      "kwd",
      "kwt"
    ],
    "vnd.kenameaapp": "htke",
    "vnd.kidspiration": "kia",
    "vnd.kinar": [
      "kne",
      "knp"
    ],
    "vnd.koan": [
      "skp",
      "skd",
      "skt",
      "skm"
    ],
    "vnd.kodak-descriptor": "sse",
    "vnd.las.las+xml": "lasxml",
    "vnd.llamagraphics.life-balance.desktop": "lbd",
    "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
    "vnd.lotus-1-2-3": "123",
    "vnd.lotus-approach": "apr",
    "vnd.lotus-freelance": "pre",
    "vnd.lotus-notes": "nsf",
    "vnd.lotus-organizer": "org",
    "vnd.lotus-screencam": "scm",
    "vnd.lotus-wordpro": "lwp",
    "vnd.macports.portpkg": "portpkg",
    "vnd.mcd": "mcd",
    "vnd.medcalcdata": "mc1",
    "vnd.mediastation.cdkey": "cdkey",
    "vnd.mfer": "mwf",
    "vnd.mfmp": "mfm",
    "vnd.micrografx.flo": "flo",
    "vnd.micrografx.igx": "igx",
    "vnd.mif": "mif",
    "vnd.mobius.daf": "daf",
    "vnd.mobius.dis": "dis",
    "vnd.mobius.mbk": "mbk",
    "vnd.mobius.mqy": "mqy",
    "vnd.mobius.msl": "msl",
    "vnd.mobius.plc": "plc",
    "vnd.mobius.txf": "txf",
    "vnd.mophun.application": "mpn",
    "vnd.mophun.certificate": "mpc",
    "vnd.ms-artgalry": "cil",
    "vnd.ms-cab-compressed": "cab",
    "vnd.ms-excel.addin.macroenabled.12": "xlam",
    "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
    "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
    "vnd.ms-excel.template.macroenabled.12": "xltm",
    "vnd.ms-fontobject": "eot",
    "vnd.ms-htmlhelp": "chm",
    "vnd.ms-ims": "ims",
    "vnd.ms-lrm": "lrm",
    "vnd.ms-officetheme": "thmx",
    "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
    "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
    "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
    "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
    "vnd.ms-powerpoint.template.macroenabled.12": "potm",
    "vnd.ms-project": [
      "mpp",
      "mpt"
    ],
    "vnd.ms-word.document.macroenabled.12": "docm",
    "vnd.ms-word.template.macroenabled.12": "dotm",
    "vnd.ms-works": [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ],
    "vnd.ms-wpl": "wpl",
    "vnd.ms-xpsdocument": "xps",
    "vnd.mseq": "mseq",
    "vnd.musician": "mus",
    "vnd.muvee.style": "msty",
    "vnd.mynfc": "taglet",
    "vnd.neurolanguage.nlu": "nlu",
    "vnd.nitf": [
      "ntf",
      "nitf"
    ],
    "vnd.noblenet-directory": "nnd",
    "vnd.noblenet-sealer": "nns",
    "vnd.noblenet-web": "nnw",
    "vnd.nokia.n-gage.data": "ngdat",
    "vnd.nokia.n-gage.symbian.install": "n-gage",
    "vnd.nokia.radio-preset": "rpst",
    "vnd.nokia.radio-presets": "rpss",
    "vnd.novadigm.edm": "edm",
    "vnd.novadigm.edx": "edx",
    "vnd.novadigm.ext": "ext",
    "vnd.oasis.opendocument.chart-template": "otc",
    "vnd.oasis.opendocument.formula-template": "odft",
    "vnd.oasis.opendocument.image-template": "oti",
    "vnd.olpc-sugar": "xo",
    "vnd.oma.dd2+xml": "dd2",
    "vnd.openofficeorg.extension": "oxt",
    "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
    "vnd.osgeo.mapguide.package": "mgp",
    "vnd.osgi.dp": "dp",
    "vnd.osgi.subsystem": "esa",
    "vnd.palm": [
      "pdb",
      "pqa",
      "oprc"
    ],
    "vnd.pawaafile": "paw",
    "vnd.pg.format": "str",
    "vnd.pg.osasli": "ei6",
    "vnd.picsel": "efif",
    "vnd.pmi.widget": "wg",
    "vnd.pocketlearn": "plf",
    "vnd.powerbuilder6": "pbd",
    "vnd.previewsystems.box": "box",
    "vnd.proteus.magazine": "mgz",
    "vnd.publishare-delta-tree": "qps",
    "vnd.pvi.ptid1": "ptid",
    "vnd.quark.quarkxpress": [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ],
    "vnd.realvnc.bed": "bed",
    "vnd.recordare.musicxml": "mxl",
    "vnd.recordare.musicxml+xml": "musicxml",
    "vnd.rig.cryptonote": "cryptonote",
    "vnd.rn-realmedia": "rm",
    "vnd.rn-realmedia-vbr": "rmvb",
    "vnd.route66.link66+xml": "link66",
    "vnd.sailingtracker.track": "st",
    "vnd.seemail": "see",
    "vnd.sema": "sema",
    "vnd.semd": "semd",
    "vnd.semf": "semf",
    "vnd.shana.informed.formdata": "ifm",
    "vnd.shana.informed.formtemplate": "itp",
    "vnd.shana.informed.interchange": "iif",
    "vnd.shana.informed.package": "ipk",
    "vnd.simtech-mindmapper": [
      "twd",
      "twds"
    ],
    "vnd.smart.teacher": "teacher",
    "vnd.solent.sdkm+xml": [
      "sdkm",
      "sdkd"
    ],
    "vnd.spotfire.dxp": "dxp",
    "vnd.spotfire.sfs": "sfs",
    "vnd.stepmania.package": "smzip",
    "vnd.stepmania.stepchart": "sm",
    "vnd.sus-calendar": [
      "sus",
      "susp"
    ],
    "vnd.svd": "svd",
    "vnd.syncml+xml": "xsm",
    "vnd.syncml.dm+wbxml": "bdm",
    "vnd.syncml.dm+xml": "xdm",
    "vnd.tao.intent-module-archive": "tao",
    "vnd.tcpdump.pcap": [
      "pcap",
      "cap",
      "dmp"
    ],
    "vnd.tmobile-livetv": "tmo",
    "vnd.trid.tpt": "tpt",
    "vnd.triscape.mxs": "mxs",
    "vnd.trueapp": "tra",
    "vnd.ufdl": [
      "ufd",
      "ufdl"
    ],
    "vnd.uiq.theme": "utz",
    "vnd.umajin": "umj",
    "vnd.unity": "unityweb",
    "vnd.uoml+xml": "uoml",
    "vnd.vcx": "vcx",
    "vnd.visionary": "vis",
    "vnd.vsf": "vsf",
    "vnd.webturbo": "wtb",
    "vnd.wolfram.player": "nbp",
    "vnd.wqd": "wqd",
    "vnd.wt.stf": "stf",
    "vnd.xara": "xar",
    "vnd.xfdl": "xfdl",
    "vnd.yamaha.hv-dic": "hvd",
    "vnd.yamaha.hv-script": "hvs",
    "vnd.yamaha.hv-voice": "hvp",
    "vnd.yamaha.openscoreformat": "osf",
    "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
    "vnd.yamaha.smaf-audio": "saf",
    "vnd.yamaha.smaf-phrase": "spf",
    "vnd.yellowriver-custom-menu": "cmp",
    "vnd.zul": [
      "zir",
      "zirz"
    ],
    "vnd.zzazz.deck+xml": "zaz",
    "voicexml+xml": "vxml",
    widget: "wgt",
    winhlp: "hlp",
    "wsdl+xml": "wsdl",
    "wspolicy+xml": "wspolicy",
    "x-ace-compressed": "ace",
    "x-authorware-bin": [
      "aab",
      "x32",
      "u32",
      "vox"
    ],
    "x-authorware-map": "aam",
    "x-authorware-seg": "aas",
    "x-blorb": [
      "blb",
      "blorb"
    ],
    "x-bzip": "bz",
    "x-bzip2": [
      "bz2",
      "boz"
    ],
    "x-cfs-compressed": "cfs",
    "x-chat": "chat",
    "x-conference": "nsc",
    "x-dgc-compressed": "dgc",
    "x-dtbncx+xml": "ncx",
    "x-dtbook+xml": "dtb",
    "x-dtbresource+xml": "res",
    "x-eva": "eva",
    "x-font-bdf": "bdf",
    "x-font-ghostscript": "gsf",
    "x-font-linux-psf": "psf",
    "x-font-pcf": "pcf",
    "x-font-snf": "snf",
    "x-font-ttf": [
      "ttf",
      "ttc"
    ],
    "x-font-type1": [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ],
    "x-freearc": "arc",
    "x-gca-compressed": "gca",
    "x-glulx": "ulx",
    "x-gramps-xml": "gramps",
    "x-install-instructions": "install",
    "x-lzh-compressed": [
      "lzh",
      "lha"
    ],
    "x-mie": "mie",
    "x-mobipocket-ebook": [
      "prc",
      "mobi"
    ],
    "x-ms-application": "application",
    "x-ms-shortcut": "lnk",
    "x-ms-xbap": "xbap",
    "x-msbinder": "obd",
    "x-mscardfile": "crd",
    "x-msclip": "clp",
    "application/x-ms-installer": "msi",
    "x-msmediaview": [
      "mvb",
      "m13",
      "m14"
    ],
    "x-msmetafile": [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ],
    "x-msmoney": "mny",
    "x-mspublisher": "pub",
    "x-msschedule": "scd",
    "x-msterminal": "trm",
    "x-mswrite": "wri",
    "x-nzb": "nzb",
    "x-pkcs12": [
      "p12",
      "pfx"
    ],
    "x-pkcs7-certificates": [
      "p7b",
      "spc"
    ],
    "x-research-info-systems": "ris",
    "x-silverlight-app": "xap",
    "x-sql": "sql",
    "x-stuffitx": "sitx",
    "x-subrip": "srt",
    "x-t3vm-image": "t3",
    "x-tex-tfm": "tfm",
    "x-tgif": "obj",
    "x-xliff+xml": "xlf",
    "x-xz": "xz",
    "x-zmachine": [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ],
    "xaml+xml": "xaml",
    "xcap-diff+xml": "xdf",
    "xenc+xml": "xenc",
    "xml-dtd": "dtd",
    "xop+xml": "xop",
    "xproc+xml": "xpl",
    "xslt+xml": "xslt",
    "xv+xml": [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ],
    yang: "yang",
    "yin+xml": "yin",
    envoy: "evy",
    fractals: "fif",
    "internet-property-stream": "acx",
    olescript: "axs",
    "vnd.ms-outlook": "msg",
    "vnd.ms-pkicertstore": "sst",
    "x-compress": "z",
    "x-perfmon": [
      "pma",
      "pmc",
      "pmr",
      "pmw"
    ],
    "ynd.ms-pkipko": "pko",
    gzip: [
      "gz",
      "tgz"
    ],
    "smil+xml": [
      "smi",
      "smil"
    ],
    "vnd.debian.binary-package": [
      "deb",
      "udeb"
    ],
    "vnd.hzn-3d-crossword": "x3d",
    "vnd.sqlite3": [
      "db",
      "sqlite",
      "sqlite3",
      "db-wal",
      "sqlite-wal",
      "db-shm",
      "sqlite-shm"
    ],
    "vnd.wap.sic": "sic",
    "vnd.wap.slc": "slc",
    "x-krita": [
      "kra",
      "krz"
    ],
    "x-perl": [
      "pm",
      "pl"
    ],
    yaml: [
      "yaml",
      "yml"
    ]
  },
  audio: {
    amr: "amr",
    "amr-wb": "awb",
    annodex: "axa",
    basic: [
      "au",
      "snd"
    ],
    flac: "flac",
    midi: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ],
    mpeg: [
      "mpga",
      "mpega",
      "mp3",
      "m4a",
      "mp2a",
      "m2a",
      "m3a"
    ],
    mpegurl: "m3u",
    ogg: [
      "oga",
      "ogg",
      "spx"
    ],
    "prs.sid": "sid",
    "x-aiff": "aifc",
    "x-gsm": "gsm",
    "x-ms-wma": "wma",
    "x-ms-wax": "wax",
    "x-pn-realaudio": "ram",
    "x-realaudio": "ra",
    "x-sd2": "sd2",
    adpcm: "adp",
    mp4: "mp4a",
    s3m: "s3m",
    silk: "sil",
    "vnd.dece.audio": [
      "uva",
      "uvva"
    ],
    "vnd.digital-winds": "eol",
    "vnd.dra": "dra",
    "vnd.dts": "dts",
    "vnd.dts.hd": "dtshd",
    "vnd.lucent.voice": "lvp",
    "vnd.ms-playready.media.pya": "pya",
    "vnd.nuera.ecelp4800": "ecelp4800",
    "vnd.nuera.ecelp7470": "ecelp7470",
    "vnd.nuera.ecelp9600": "ecelp9600",
    "vnd.rip": "rip",
    webm: "weba",
    "x-caf": "caf",
    "x-matroska": "mka",
    "x-pn-realaudio-plugin": "rmp",
    xm: "xm",
    aac: "aac",
    aiff: [
      "aiff",
      "aif",
      "aff"
    ],
    opus: "opus",
    wav: "wav"
  },
  chemical: {
    "x-alchemy": "alc",
    "x-cache": [
      "cac",
      "cache"
    ],
    "x-cache-csf": "csf",
    "x-cactvs-binary": [
      "cbin",
      "cascii",
      "ctab"
    ],
    "x-cdx": "cdx",
    "x-chem3d": "c3d",
    "x-cif": "cif",
    "x-cmdf": "cmdf",
    "x-cml": "cml",
    "x-compass": "cpa",
    "x-crossfire": "bsd",
    "x-csml": [
      "csml",
      "csm"
    ],
    "x-ctx": "ctx",
    "x-cxf": [
      "cxf",
      "cef"
    ],
    "x-embl-dl-nucleotide": [
      "emb",
      "embl"
    ],
    "x-gamess-input": [
      "inp",
      "gam",
      "gamin"
    ],
    "x-gaussian-checkpoint": [
      "fch",
      "fchk"
    ],
    "x-gaussian-cube": "cub",
    "x-gaussian-input": [
      "gau",
      "gjc",
      "gjf"
    ],
    "x-gaussian-log": "gal",
    "x-gcg8-sequence": "gcg",
    "x-genbank": "gen",
    "x-hin": "hin",
    "x-isostar": [
      "istr",
      "ist"
    ],
    "x-jcamp-dx": [
      "jdx",
      "dx"
    ],
    "x-kinemage": "kin",
    "x-macmolecule": "mcm",
    "x-macromodel-input": "mmod",
    "x-mdl-molfile": "mol",
    "x-mdl-rdfile": "rd",
    "x-mdl-rxnfile": "rxn",
    "x-mdl-sdfile": "sd",
    "x-mdl-tgf": "tgf",
    "x-mmcif": "mcif",
    "x-mol2": "mol2",
    "x-molconn-Z": "b",
    "x-mopac-graph": "gpt",
    "x-mopac-input": [
      "mop",
      "mopcrt",
      "zmt"
    ],
    "x-mopac-out": "moo",
    "x-ncbi-asn1": "asn",
    "x-ncbi-asn1-ascii": [
      "prt",
      "ent"
    ],
    "x-ncbi-asn1-binary": "val",
    "x-rosdal": "ros",
    "x-swissprot": "sw",
    "x-vamas-iso14976": "vms",
    "x-vmd": "vmd",
    "x-xtel": "xtel",
    "x-xyz": "xyz"
  },
  font: {
    otf: "otf",
    woff: "woff",
    woff2: "woff2"
  },
  image: {
    gif: "gif",
    ief: "ief",
    jpeg: [
      "jpeg",
      "jpg",
      "jpe",
      "jfif",
      "jfif-tbnl",
      "jif"
    ],
    pcx: "pcx",
    png: "png",
    "svg+xml": [
      "svg",
      "svgz"
    ],
    tiff: [
      "tiff",
      "tif"
    ],
    "vnd.djvu": [
      "djvu",
      "djv"
    ],
    "vnd.wap.wbmp": "wbmp",
    "x-canon-cr2": "cr2",
    "x-canon-crw": "crw",
    "x-cmu-raster": "ras",
    "x-coreldraw": "cdr",
    "x-coreldrawpattern": "pat",
    "x-coreldrawtemplate": "cdt",
    "x-corelphotopaint": "cpt",
    "x-epson-erf": "erf",
    "x-icon": "ico",
    "x-jg": "art",
    "x-jng": "jng",
    "x-nikon-nef": "nef",
    "x-olympus-orf": "orf",
    "x-portable-anymap": "pnm",
    "x-portable-bitmap": "pbm",
    "x-portable-graymap": "pgm",
    "x-portable-pixmap": "ppm",
    "x-rgb": "rgb",
    "x-xbitmap": "xbm",
    "x-xpixmap": "xpm",
    "x-xwindowdump": "xwd",
    bmp: "bmp",
    cgm: "cgm",
    g3fax: "g3",
    ktx: "ktx",
    "prs.btif": "btif",
    sgi: "sgi",
    "vnd.dece.graphic": [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ],
    "vnd.dwg": "dwg",
    "vnd.dxf": "dxf",
    "vnd.fastbidsheet": "fbs",
    "vnd.fpx": "fpx",
    "vnd.fst": "fst",
    "vnd.fujixerox.edmics-mmr": "mmr",
    "vnd.fujixerox.edmics-rlc": "rlc",
    "vnd.ms-modi": "mdi",
    "vnd.ms-photo": "wdp",
    "vnd.net-fpx": "npx",
    "vnd.xiff": "xif",
    webp: "webp",
    "x-3ds": "3ds",
    "x-cmx": "cmx",
    "x-freehand": [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ],
    "x-pict": [
      "pic",
      "pct"
    ],
    "x-tga": "tga",
    "cis-cod": "cod",
    avif: "avifs",
    heic: [
      "heif",
      "heic"
    ],
    pjpeg: [
      "pjpg"
    ],
    "vnd.adobe.photoshop": "psd",
    "x-adobe-dng": "dng",
    "x-fuji-raf": "raf",
    "x-icns": "icns",
    "x-kodak-dcr": "dcr",
    "x-kodak-k25": "k25",
    "x-kodak-kdc": "kdc",
    "x-minolta-mrw": "mrw",
    "x-panasonic-raw": [
      "raw",
      "rw2",
      "rwl"
    ],
    "x-pentax-pef": [
      "pef",
      "ptx"
    ],
    "x-sigma-x3f": "x3f",
    "x-sony-arw": "arw",
    "x-sony-sr2": "sr2",
    "x-sony-srf": "srf"
  },
  message: {
    rfc822: [
      "eml",
      "mime",
      "mht",
      "mhtml",
      "nws"
    ]
  },
  model: {
    iges: [
      "igs",
      "iges"
    ],
    mesh: [
      "msh",
      "mesh",
      "silo"
    ],
    vrml: [
      "wrl",
      "vrml"
    ],
    "x3d+vrml": [
      "x3dv",
      "x3dvz"
    ],
    "x3d+xml": "x3dz",
    "x3d+binary": [
      "x3db",
      "x3dbz"
    ],
    "vnd.collada+xml": "dae",
    "vnd.dwf": "dwf",
    "vnd.gdl": "gdl",
    "vnd.gtw": "gtw",
    "vnd.mts": "mts",
    "vnd.usdz+zip": "usdz",
    "vnd.vtu": "vtu"
  },
  text: {
    "cache-manifest": [
      "manifest",
      "appcache"
    ],
    calendar: [
      "ics",
      "icz",
      "ifb"
    ],
    css: "css",
    csv: "csv",
    h323: "323",
    html: [
      "html",
      "htm",
      "shtml",
      "stm"
    ],
    iuls: "uls",
    plain: [
      "txt",
      "text",
      "brf",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "bas",
      "diff",
      "ksh"
    ],
    richtext: "rtx",
    scriptlet: [
      "sct",
      "wsc"
    ],
    texmacs: "tm",
    "tab-separated-values": "tsv",
    "vnd.sun.j2me.app-descriptor": "jad",
    "vnd.wap.wml": "wml",
    "vnd.wap.wmlscript": "wmls",
    "x-bibtex": "bib",
    "x-boo": "boo",
    "x-c++hdr": [
      "h++",
      "hpp",
      "hxx",
      "hh"
    ],
    "x-c++src": [
      "c++",
      "cpp",
      "cxx",
      "cc"
    ],
    "x-component": "htc",
    "x-dsrc": "d",
    "x-diff": "patch",
    "x-haskell": "hs",
    "x-java": "java",
    "x-literate-haskell": "lhs",
    "x-moc": "moc",
    "x-pascal": [
      "p",
      "pas",
      "pp",
      "inc"
    ],
    "x-pcs-gcd": "gcd",
    "x-python": "py",
    "x-scala": "scala",
    "x-setext": "etx",
    "x-tcl": [
      "tcl",
      "tk"
    ],
    "x-tex": [
      "tex",
      "ltx",
      "sty",
      "cls"
    ],
    "x-vcalendar": "vcs",
    "x-vcard": "vcf",
    n3: "n3",
    "prs.lines.tag": "dsc",
    sgml: [
      "sgml",
      "sgm"
    ],
    troff: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ],
    turtle: "ttl",
    "uri-list": [
      "uri",
      "uris",
      "urls"
    ],
    vcard: "vcard",
    "vnd.curl": "curl",
    "vnd.curl.dcurl": "dcurl",
    "vnd.curl.scurl": "scurl",
    "vnd.curl.mcurl": "mcurl",
    "vnd.dvb.subtitle": "sub",
    "vnd.fly": "fly",
    "vnd.fmi.flexstor": "flx",
    "vnd.graphviz": "gv",
    "vnd.in3d.3dml": "3dml",
    "vnd.in3d.spot": "spot",
    "x-asm": [
      "s",
      "asm"
    ],
    "x-c": [
      "c",
      "h",
      "dic"
    ],
    "x-fortran": [
      "f",
      "for",
      "f77",
      "f90"
    ],
    "x-opml": "opml",
    "x-nfo": "nfo",
    "x-sfv": "sfv",
    "x-uuencode": "uu",
    webviewhtml: "htt",
    javascript: "js",
    json: "json",
    markdown: [
      "md",
      "markdown",
      "mdown",
      "markdn"
    ],
    "vnd.wap.si": "si",
    "vnd.wap.sl": "sl"
  },
  video: {
    avif: "avif",
    "3gpp": "3gp",
    annodex: "axv",
    dl: "dl",
    dv: [
      "dif",
      "dv"
    ],
    fli: "fli",
    gl: "gl",
    mpeg: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v",
      "mp2",
      "mpa",
      "mpv2"
    ],
    mp4: [
      "mp4",
      "mp4v",
      "mpg4"
    ],
    quicktime: [
      "qt",
      "mov"
    ],
    ogg: "ogv",
    "vnd.mpegurl": [
      "mxu",
      "m4u"
    ],
    "x-flv": "flv",
    "x-la-asf": [
      "lsf",
      "lsx"
    ],
    "x-mng": "mng",
    "x-ms-asf": [
      "asf",
      "asx",
      "asr"
    ],
    "x-ms-wm": "wm",
    "x-ms-wmv": "wmv",
    "x-ms-wmx": "wmx",
    "x-ms-wvx": "wvx",
    "x-msvideo": "avi",
    "x-sgi-movie": "movie",
    "x-matroska": [
      "mpv",
      "mkv",
      "mk3d",
      "mks"
    ],
    "3gpp2": "3g2",
    h261: "h261",
    h263: "h263",
    h264: "h264",
    jpeg: "jpgv",
    jpm: [
      "jpm",
      "jpgm"
    ],
    mj2: [
      "mj2",
      "mjp2"
    ],
    "vnd.dece.hd": [
      "uvh",
      "uvvh"
    ],
    "vnd.dece.mobile": [
      "uvm",
      "uvvm"
    ],
    "vnd.dece.pd": [
      "uvp",
      "uvvp"
    ],
    "vnd.dece.sd": [
      "uvs",
      "uvvs"
    ],
    "vnd.dece.video": [
      "uvv",
      "uvvv"
    ],
    "vnd.dvb.file": "dvb",
    "vnd.fvt": "fvt",
    "vnd.ms-playready.media.pyv": "pyv",
    "vnd.uvvu.mp4": [
      "uvu",
      "uvvu"
    ],
    "vnd.vivo": "viv",
    webm: "webm",
    "x-f4v": "f4v",
    "x-m4v": "m4v",
    "x-ms-vob": "vob",
    "x-smv": "smv",
    mp2t: "ts"
  },
  "x-conference": {
    "x-cooltalk": "ice"
  },
  "x-world": {
    "x-vrml": [
      "vrm",
      "flr",
      "wrz",
      "xaf",
      "xof"
    ]
  }
};
(() => {
  const e = {};
  for (const t of Object.keys(va))
    for (const r of Object.keys(va[t])) {
      const i = va[t][r];
      if (typeof i == "string")
        e[i] = t + "/" + r;
      else
        for (let a = 0; a < i.length; a++)
          e[i[a]] = t + "/" + r;
    }
  return e;
})();
const nu = [];
for (let e = 0; e < 256; e++) {
  let t = e;
  for (let r = 0; r < 8; r++)
    t & 1 ? t = t >>> 1 ^ 3988292384 : t = t >>> 1;
  nu[e] = t;
}
class Qs {
  constructor(t) {
    this.crc = t || -1;
  }
  append(t) {
    let r = this.crc | 0;
    for (let i = 0, a = t.length | 0; i < a; i++)
      r = r >>> 8 ^ nu[(r ^ t[i]) & 255];
    this.crc = r;
  }
  get() {
    return ~this.crc;
  }
}
class su extends TransformStream {
  constructor() {
    let t;
    const r = new Qs();
    super({
      transform(i, a) {
        r.append(i), a.enqueue(i);
      },
      flush() {
        const i = new Uint8Array(4);
        new DataView(i.buffer).setUint32(0, r.get()), t.value = i;
      }
    }), t = this;
  }
}
function qg(e) {
  if (typeof TextEncoder == xr) {
    e = unescape(encodeURIComponent(e));
    const t = new Uint8Array(e.length);
    for (let r = 0; r < t.length; r++)
      t[r] = e.charCodeAt(r);
    return t;
  } else
    return new TextEncoder().encode(e);
}
const ot = {
  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat(e, t) {
    if (e.length === 0 || t.length === 0)
      return e.concat(t);
    const r = e[e.length - 1], i = ot.getPartial(r);
    return i === 32 ? e.concat(t) : ot._shiftRight(t, i, r | 0, e.slice(0, e.length - 1));
  },
  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength(e) {
    const t = e.length;
    if (t === 0)
      return 0;
    const r = e[t - 1];
    return (t - 1) * 32 + ot.getPartial(r);
  },
  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp(e, t) {
    if (e.length * 32 < t)
      return e;
    e = e.slice(0, Math.ceil(t / 32));
    const r = e.length;
    return t = t & 31, r > 0 && t && (e[r - 1] = ot.partial(t, e[r - 1] & 2147483648 >> t - 1, 1)), e;
  },
  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial(e, t, r) {
    return e === 32 ? t : (r ? t | 0 : t << 32 - e) + e * 1099511627776;
  },
  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial(e) {
    return Math.round(e / 1099511627776) || 32;
  },
  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight(e, t, r, i) {
    for (i === void 0 && (i = []); t >= 32; t -= 32)
      i.push(r), r = 0;
    if (t === 0)
      return i.concat(e);
    for (let n = 0; n < e.length; n++)
      i.push(r | e[n] >>> t), r = e[n] << 32 - t;
    const a = e.length ? e[e.length - 1] : 0, s = ot.getPartial(a);
    return i.push(ot.partial(t + s & 31, t + s > 32 ? r : i.pop(), 1)), i;
  }
}, ei = {
  bytes: {
    /** Convert from a bitArray to an array of bytes. */
    fromBits(e) {
      const r = ot.bitLength(e) / 8, i = new Uint8Array(r);
      let a;
      for (let s = 0; s < r; s++)
        s & 3 || (a = e[s / 4]), i[s] = a >>> 24, a <<= 8;
      return i;
    },
    /** Convert from an array of bytes to a bitArray. */
    toBits(e) {
      const t = [];
      let r, i = 0;
      for (r = 0; r < e.length; r++)
        i = i << 8 | e[r], (r & 3) === 3 && (t.push(i), i = 0);
      return r & 3 && t.push(ot.partial(8 * (r & 3), i)), t;
    }
  }
}, iu = {};
iu.sha1 = class {
  constructor(e) {
    const t = this;
    t.blockSize = 512, t._init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], t._key = [1518500249, 1859775393, 2400959708, 3395469782], e ? (t._h = e._h.slice(0), t._buffer = e._buffer.slice(0), t._length = e._length) : t.reset();
  }
  /**
   * Reset the hash state.
   * @return this
   */
  reset() {
    const e = this;
    return e._h = e._init.slice(0), e._buffer = [], e._length = 0, e;
  }
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update(e) {
    const t = this;
    typeof e == "string" && (e = ei.utf8String.toBits(e));
    const r = t._buffer = ot.concat(t._buffer, e), i = t._length, a = t._length = i + ot.bitLength(e);
    if (a > 9007199254740991)
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    const s = new Uint32Array(r);
    let n = 0;
    for (let o = t.blockSize + i - (t.blockSize + i & t.blockSize - 1); o <= a; o += t.blockSize)
      t._block(s.subarray(16 * n, 16 * (n + 1))), n += 1;
    return r.splice(0, 16 * n), t;
  }
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
   */
  finalize() {
    const e = this;
    let t = e._buffer;
    const r = e._h;
    t = ot.concat(t, [ot.partial(1, 1)]);
    for (let i = t.length + 2; i & 15; i++)
      t.push(0);
    for (t.push(Math.floor(e._length / 4294967296)), t.push(e._length | 0); t.length; )
      e._block(t.splice(0, 16));
    return e.reset(), r;
  }
  /**
   * The SHA-1 logical functions f(0), f(1), ..., f(79).
   * @private
   */
  _f(e, t, r, i) {
    if (e <= 19)
      return t & r | ~t & i;
    if (e <= 39)
      return t ^ r ^ i;
    if (e <= 59)
      return t & r | t & i | r & i;
    if (e <= 79)
      return t ^ r ^ i;
  }
  /**
   * Circular left-shift operator.
   * @private
   */
  _S(e, t) {
    return t << e | t >>> 32 - e;
  }
  /**
   * Perform one cycle of SHA-1.
   * @param {Uint32Array|bitArray} words one block of words.
   * @private
   */
  _block(e) {
    const t = this, r = t._h, i = Array(80);
    for (let p = 0; p < 16; p++)
      i[p] = e[p];
    let a = r[0], s = r[1], n = r[2], o = r[3], l = r[4];
    for (let p = 0; p <= 79; p++) {
      p >= 16 && (i[p] = t._S(1, i[p - 3] ^ i[p - 8] ^ i[p - 14] ^ i[p - 16]));
      const c = t._S(5, a) + t._f(p, s, n, o) + l + i[p] + t._key[Math.floor(p / 20)] | 0;
      l = o, o = n, n = t._S(30, s), s = a, a = c;
    }
    r[0] = r[0] + a | 0, r[1] = r[1] + s | 0, r[2] = r[2] + n | 0, r[3] = r[3] + o | 0, r[4] = r[4] + l | 0;
  }
};
const au = {};
au.aes = class {
  constructor(e) {
    const t = this;
    t._tables = [[[], [], [], [], []], [[], [], [], [], []]], t._tables[0][0][0] || t._precompute();
    const r = t._tables[0][4], i = t._tables[1], a = e.length;
    let s, n, o, l = 1;
    if (a !== 4 && a !== 6 && a !== 8)
      throw new Error("invalid aes key size");
    for (t._key = [n = e.slice(0), o = []], s = a; s < 4 * a + 28; s++) {
      let p = n[s - 1];
      (s % a === 0 || a === 8 && s % a === 4) && (p = r[p >>> 24] << 24 ^ r[p >> 16 & 255] << 16 ^ r[p >> 8 & 255] << 8 ^ r[p & 255], s % a === 0 && (p = p << 8 ^ p >>> 24 ^ l << 24, l = l << 1 ^ (l >> 7) * 283)), n[s] = n[s - a] ^ p;
    }
    for (let p = 0; s; p++, s--) {
      const c = n[p & 3 ? s : s - 4];
      s <= 4 || p < 4 ? o[p] = c : o[p] = i[0][r[c >>> 24]] ^ i[1][r[c >> 16 & 255]] ^ i[2][r[c >> 8 & 255]] ^ i[3][r[c & 255]];
    }
  }
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt(e) {
    return this._crypt(e, 0);
  }
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt(e) {
    return this._crypt(e, 1);
  }
  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute() {
    const e = this._tables[0], t = this._tables[1], r = e[4], i = t[4], a = [], s = [];
    let n, o, l, p;
    for (let c = 0; c < 256; c++)
      s[(a[c] = c << 1 ^ (c >> 7) * 283) ^ c] = c;
    for (let c = n = 0; !r[c]; c ^= o || 1, n = s[n] || 1) {
      let m = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4;
      m = m >> 8 ^ m & 255 ^ 99, r[c] = m, i[m] = c, p = a[l = a[o = a[c]]];
      let h = p * 16843009 ^ l * 65537 ^ o * 257 ^ c * 16843008, g = a[m] * 257 ^ m * 16843008;
      for (let R = 0; R < 4; R++)
        e[R][c] = g = g << 24 ^ g >>> 8, t[R][m] = h = h << 24 ^ h >>> 8;
    }
    for (let c = 0; c < 5; c++)
      e[c] = e[c].slice(0), t[c] = t[c].slice(0);
  }
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt(e, t) {
    if (e.length !== 4)
      throw new Error("invalid aes block size");
    const r = this._key[t], i = r.length / 4 - 2, a = [0, 0, 0, 0], s = this._tables[t], n = s[0], o = s[1], l = s[2], p = s[3], c = s[4];
    let m = e[0] ^ r[0], h = e[t ? 3 : 1] ^ r[1], g = e[2] ^ r[2], R = e[t ? 1 : 3] ^ r[3], y = 4, _, w, C;
    for (let E = 0; E < i; E++)
      _ = n[m >>> 24] ^ o[h >> 16 & 255] ^ l[g >> 8 & 255] ^ p[R & 255] ^ r[y], w = n[h >>> 24] ^ o[g >> 16 & 255] ^ l[R >> 8 & 255] ^ p[m & 255] ^ r[y + 1], C = n[g >>> 24] ^ o[R >> 16 & 255] ^ l[m >> 8 & 255] ^ p[h & 255] ^ r[y + 2], R = n[R >>> 24] ^ o[m >> 16 & 255] ^ l[h >> 8 & 255] ^ p[g & 255] ^ r[y + 3], y += 4, m = _, h = w, g = C;
    for (let E = 0; E < 4; E++)
      a[t ? 3 & -E : E] = c[m >>> 24] << 24 ^ c[h >> 16 & 255] << 16 ^ c[g >> 8 & 255] << 8 ^ c[R & 255] ^ r[y++], _ = m, m = h, h = g, g = R, R = _;
    return a;
  }
};
const Kg = {
  /** 
   * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
   * @param {TypedArray} typedArray The array to fill.
   * @return {TypedArray} The random values.
   */
  getRandomValues(e) {
    const t = new Uint32Array(e.buffer), r = (i) => {
      let a = 987654321;
      const s = 4294967295;
      return function() {
        return a = 36969 * (a & 65535) + (a >> 16) & s, i = 18e3 * (i & 65535) + (i >> 16) & s, (((a << 16) + i & s) / 4294967296 + 0.5) * (Math.random() > 0.5 ? 1 : -1);
      };
    };
    for (let i = 0, a; i < e.length; i += 4) {
      const s = r((a || Math.random()) * 4294967296);
      a = s() * 987654071, t[i / 4] = s() * 4294967296 | 0;
    }
    return e;
  }
}, ou = {};
ou.ctrGladman = class {
  constructor(e, t) {
    this._prf = e, this._initIv = t, this._iv = t;
  }
  reset() {
    this._iv = this._initIv;
  }
  /** Input some data to calculate.
   * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
   */
  update(e) {
    return this.calculate(this._prf, e, this._iv);
  }
  incWord(e) {
    if ((e >> 24 & 255) === 255) {
      let t = e >> 16 & 255, r = e >> 8 & 255, i = e & 255;
      t === 255 ? (t = 0, r === 255 ? (r = 0, i === 255 ? i = 0 : ++i) : ++r) : ++t, e = 0, e += t << 16, e += r << 8, e += i;
    } else
      e += 1 << 24;
    return e;
  }
  incCounter(e) {
    (e[0] = this.incWord(e[0])) === 0 && (e[1] = this.incWord(e[1]));
  }
  calculate(e, t, r) {
    let i;
    if (!(i = t.length))
      return [];
    const a = ot.bitLength(t);
    for (let s = 0; s < i; s += 4) {
      this.incCounter(r);
      const n = e.encrypt(r);
      t[s] ^= n[0], t[s + 1] ^= n[1], t[s + 2] ^= n[2], t[s + 3] ^= n[3];
    }
    return ot.clamp(t, a);
  }
};
const jr = {
  importKey(e) {
    return new jr.hmacSha1(ei.bytes.toBits(e));
  },
  pbkdf2(e, t, r, i) {
    if (r = r || 1e4, i < 0 || r < 0)
      throw new Error("invalid params to pbkdf2");
    const a = (i >> 5) + 1 << 2;
    let s, n, o, l, p;
    const c = new ArrayBuffer(a), m = new DataView(c);
    let h = 0;
    const g = ot;
    for (t = ei.bytes.toBits(t), p = 1; h < (a || 1); p++) {
      for (s = n = e.encrypt(g.concat(t, [p])), o = 1; o < r; o++)
        for (n = e.encrypt(n), l = 0; l < n.length; l++)
          s[l] ^= n[l];
      for (o = 0; h < (a || 1) && o < s.length; o++)
        m.setInt32(h, s[o]), h += 4;
    }
    return c.slice(0, i / 8);
  }
};
jr.hmacSha1 = class {
  constructor(e) {
    const t = this, r = t._hash = iu.sha1, i = [[], []];
    t._baseHash = [new r(), new r()];
    const a = t._baseHash[0].blockSize / 32;
    e.length > a && (e = new r().update(e).finalize());
    for (let s = 0; s < a; s++)
      i[0][s] = e[s] ^ 909522486, i[1][s] = e[s] ^ 1549556828;
    t._baseHash[0].update(i[0]), t._baseHash[1].update(i[1]), t._resultHash = new r(t._baseHash[0]);
  }
  reset() {
    const e = this;
    e._resultHash = new e._hash(e._baseHash[0]), e._updated = !1;
  }
  update(e) {
    const t = this;
    t._updated = !0, t._resultHash.update(e);
  }
  digest() {
    const e = this, t = e._resultHash.finalize(), r = new e._hash(e._baseHash[1]).update(t).finalize();
    return e.reset(), r;
  }
  encrypt(e) {
    if (this._updated)
      throw new Error("encrypt on already updated hmac called!");
    return this.update(e), this.digest(e);
  }
};
const zg = typeof crypto != xr && typeof crypto.getRandomValues == ss, lu = "Invalid password", fu = "Invalid signature", ko = "zipjs-abort-check-password";
function pu(e) {
  return zg ? crypto.getRandomValues(e) : Kg.getRandomValues(e);
}
const tn = 16, Gg = "raw", cu = { name: "PBKDF2" }, Vg = { name: "HMAC" }, Zg = "SHA-1", Yg = Object.assign({ hash: Vg }, cu), Za = Object.assign({ iterations: 1e3, hash: { name: Zg } }, cu), Xg = ["deriveBits"], qn = [8, 12, 16], Sn = [16, 24, 32], hr = 10, Jg = [0, 0, 0, 0], _i = typeof crypto != xr, is = _i && crypto.subtle, uu = _i && typeof is != xr, Zt = ei.bytes, Qg = au.aes, e1 = ou.ctrGladman, t1 = jr.hmacSha1;
let zf = _i && uu && typeof is.importKey == ss, Gf = _i && uu && typeof is.deriveBits == ss;
class r1 extends TransformStream {
  constructor({ password: t, rawPassword: r, signed: i, encryptionStrength: a, checkPasswordOnly: s }) {
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((n) => this.resolveReady = n),
          password: mu(t, r),
          signed: i,
          strength: a - 1,
          pending: new Uint8Array()
        });
      },
      async transform(n, o) {
        const l = this, {
          password: p,
          strength: c,
          resolveReady: m,
          ready: h
        } = l;
        p ? (await s1(l, c, p, Pt(n, 0, qn[c] + 2)), n = Pt(n, qn[c] + 2), s ? o.error(new Error(ko)) : m()) : await h;
        const g = new Uint8Array(n.length - hr - (n.length - hr) % tn);
        o.enqueue(du(l, n, g, 0, hr, !0));
      },
      async flush(n) {
        const {
          signed: o,
          ctr: l,
          hmac: p,
          pending: c,
          ready: m
        } = this;
        if (p && l) {
          await m;
          const h = Pt(c, 0, c.length - hr), g = Pt(c, c.length - hr);
          let R = new Uint8Array();
          if (h.length) {
            const y = zn(Zt, h);
            p.update(y);
            const _ = l.update(y);
            R = Kn(Zt, _);
          }
          if (o) {
            const y = Pt(Kn(Zt, p.digest()), 0, hr);
            for (let _ = 0; _ < hr; _++)
              if (y[_] != g[_])
                throw new Error(fu);
          }
          n.enqueue(R);
        }
      }
    });
  }
}
class n1 extends TransformStream {
  constructor({ password: t, rawPassword: r, encryptionStrength: i }) {
    let a;
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((s) => this.resolveReady = s),
          password: mu(t, r),
          strength: i - 1,
          pending: new Uint8Array()
        });
      },
      async transform(s, n) {
        const o = this, {
          password: l,
          strength: p,
          resolveReady: c,
          ready: m
        } = o;
        let h = new Uint8Array();
        l ? (h = await i1(o, p, l), c()) : await m;
        const g = new Uint8Array(h.length + s.length - s.length % tn);
        g.set(h, 0), n.enqueue(du(o, s, g, h.length, 0));
      },
      async flush(s) {
        const {
          ctr: n,
          hmac: o,
          pending: l,
          ready: p
        } = this;
        if (o && n) {
          await p;
          let c = new Uint8Array();
          if (l.length) {
            const m = n.update(zn(Zt, l));
            o.update(m), c = Kn(Zt, m);
          }
          a.signature = Kn(Zt, o.digest()).slice(0, hr), s.enqueue(Po(c, a.signature));
        }
      }
    }), a = this;
  }
}
function du(e, t, r, i, a, s) {
  const {
    ctr: n,
    hmac: o,
    pending: l
  } = e, p = t.length - a;
  l.length && (t = Po(l, t), r = l1(r, p - p % tn));
  let c;
  for (c = 0; c <= p - tn; c += tn) {
    const m = zn(Zt, Pt(t, c, c + tn));
    s && o.update(m);
    const h = n.update(m);
    s || o.update(h), r.set(Kn(Zt, h), c + i);
  }
  return e.pending = Pt(t, c), r;
}
async function s1(e, t, r, i) {
  const a = await hu(e, t, r, Pt(i, 0, qn[t])), s = Pt(i, qn[t]);
  if (a[0] != s[0] || a[1] != s[1])
    throw new Error(lu);
}
async function i1(e, t, r) {
  const i = pu(new Uint8Array(qn[t])), a = await hu(e, t, r, i);
  return Po(i, a);
}
async function hu(e, t, r, i) {
  e.password = null;
  const a = await a1(Gg, r, Yg, !1, Xg), s = await o1(Object.assign({ salt: i }, Za), a, 8 * (Sn[t] * 2 + 2)), n = new Uint8Array(s), o = zn(Zt, Pt(n, 0, Sn[t])), l = zn(Zt, Pt(n, Sn[t], Sn[t] * 2)), p = Pt(n, Sn[t] * 2);
  return Object.assign(e, {
    keys: {
      key: o,
      authentication: l,
      passwordVerification: p
    },
    ctr: new e1(new Qg(o), Array.from(Jg)),
    hmac: new t1(l)
  }), p;
}
async function a1(e, t, r, i, a) {
  if (zf)
    try {
      return await is.importKey(e, t, r, i, a);
    } catch {
      return zf = !1, jr.importKey(t);
    }
  else
    return jr.importKey(t);
}
async function o1(e, t, r) {
  if (Gf)
    try {
      return await is.deriveBits(e, t, r);
    } catch {
      return Gf = !1, jr.pbkdf2(t, e.salt, Za.iterations, r);
    }
  else
    return jr.pbkdf2(t, e.salt, Za.iterations, r);
}
function mu(e, t) {
  return t === lt ? qg(e) : t;
}
function Po(e, t) {
  let r = e;
  return e.length + t.length && (r = new Uint8Array(e.length + t.length), r.set(e, 0), r.set(t, e.length)), r;
}
function l1(e, t) {
  if (t && t > e.length) {
    const r = e;
    e = new Uint8Array(t), e.set(r, 0);
  }
  return e;
}
function Pt(e, t, r) {
  return e.subarray(t, r);
}
function Kn(e, t) {
  return e.fromBits(t);
}
function zn(e, t) {
  return e.toBits(t);
}
const on = 12;
class f1 extends TransformStream {
  constructor({ password: t, passwordVerification: r, checkPasswordOnly: i }) {
    super({
      start() {
        Object.assign(this, {
          password: t,
          passwordVerification: r
        }), yu(this, t);
      },
      transform(a, s) {
        const n = this;
        if (n.password) {
          const o = Vf(n, a.subarray(0, on));
          if (n.password = null, o[on - 1] != n.passwordVerification)
            throw new Error(lu);
          a = a.subarray(on);
        }
        i ? s.error(new Error(ko)) : s.enqueue(Vf(n, a));
      }
    });
  }
}
class p1 extends TransformStream {
  constructor({ password: t, passwordVerification: r }) {
    super({
      start() {
        Object.assign(this, {
          password: t,
          passwordVerification: r
        }), yu(this, t);
      },
      transform(i, a) {
        const s = this;
        let n, o;
        if (s.password) {
          s.password = null;
          const l = pu(new Uint8Array(on));
          l[on - 1] = s.passwordVerification, n = new Uint8Array(i.length + l.length), n.set(Zf(s, l), 0), o = on;
        } else
          n = new Uint8Array(i.length), o = 0;
        n.set(Zf(s, i), o), a.enqueue(n);
      }
    });
  }
}
function Vf(e, t) {
  const r = new Uint8Array(t.length);
  for (let i = 0; i < t.length; i++)
    r[i] = _u(e) ^ t[i], Ao(e, r[i]);
  return r;
}
function Zf(e, t) {
  const r = new Uint8Array(t.length);
  for (let i = 0; i < t.length; i++)
    r[i] = _u(e) ^ t[i], Ao(e, t[i]);
  return r;
}
function yu(e, t) {
  const r = [305419896, 591751049, 878082192];
  Object.assign(e, {
    keys: r,
    crcKey0: new Qs(r[0]),
    crcKey2: new Qs(r[2])
  });
  for (let i = 0; i < t.length; i++)
    Ao(e, t.charCodeAt(i));
}
function Ao(e, t) {
  let [r, i, a] = e.keys;
  e.crcKey0.append([t]), r = ~e.crcKey0.get(), i = Yf(Math.imul(Yf(i + gu(r)), 134775813) + 1), e.crcKey2.append([i >>> 24]), a = ~e.crcKey2.get(), e.keys = [r, i, a];
}
function _u(e) {
  const t = e.keys[2] | 2;
  return gu(Math.imul(t, t ^ 1) >>> 8);
}
function gu(e) {
  return e & 255;
}
function Yf(e) {
  return e & 4294967295;
}
const Xf = "deflate-raw";
class c1 extends TransformStream {
  constructor(t, { chunkSize: r, CompressionStream: i, CompressionStreamNative: a }) {
    super({});
    const { compressed: s, encrypted: n, useCompressionStream: o, zipCrypto: l, signed: p, level: c } = t, m = this;
    let h, g, R = wu(super.readable);
    (!n || l) && p && (h = new su(), R = Yt(R, h)), s && (R = vu(R, o, { level: c, chunkSize: r }, a, i)), n && (l ? R = Yt(R, new p1(t)) : (g = new n1(t), R = Yt(R, g))), bu(m, R, () => {
      let y;
      n && !l && (y = g.signature), (!n || l) && p && (y = new DataView(h.value.buffer).getUint32(0)), m.signature = y;
    });
  }
}
class u1 extends TransformStream {
  constructor(t, { chunkSize: r, DecompressionStream: i, DecompressionStreamNative: a }) {
    super({});
    const { zipCrypto: s, encrypted: n, signed: o, signature: l, compressed: p, useCompressionStream: c } = t;
    let m, h, g = wu(super.readable);
    n && (s ? g = Yt(g, new f1(t)) : (h = new r1(t), g = Yt(g, h))), p && (g = vu(g, c, { chunkSize: r }, a, i)), (!n || s) && o && (m = new su(), g = Yt(g, m)), bu(this, g, () => {
      if ((!n || s) && o) {
        const R = new DataView(m.value.buffer);
        if (l != R.getUint32(0, !1))
          throw new Error(fu);
      }
    });
  }
}
function wu(e) {
  return Yt(e, new TransformStream({
    transform(t, r) {
      t && t.length && r.enqueue(t);
    }
  }));
}
function bu(e, t, r) {
  t = Yt(t, new TransformStream({ flush: r })), Object.defineProperty(e, "readable", {
    get() {
      return t;
    }
  });
}
function vu(e, t, r, i, a) {
  try {
    const s = t && i ? i : a;
    e = Yt(e, new s(Xf, r));
  } catch {
    if (t)
      try {
        e = Yt(e, new a(Xf, r));
      } catch {
        return e;
      }
    else
      return e;
  }
  return e;
}
function Yt(e, t) {
  return e.pipeThrough(t);
}
const d1 = "message", h1 = "start", m1 = "pull", Jf = "data", y1 = "ack", Qf = "close", _1 = "deflate", xu = "inflate";
class g1 extends TransformStream {
  constructor(t, r) {
    super({});
    const i = this, { codecType: a } = t;
    let s;
    a.startsWith(_1) ? s = c1 : a.startsWith(xu) && (s = u1);
    let n = 0, o = 0;
    const l = new s(t, r), p = super.readable, c = new TransformStream({
      transform(h, g) {
        h && h.length && (o += h.length, g.enqueue(h));
      },
      flush() {
        Object.assign(i, {
          inputSize: o
        });
      }
    }), m = new TransformStream({
      transform(h, g) {
        h && h.length && (n += h.length, g.enqueue(h));
      },
      flush() {
        const { signature: h } = l;
        Object.assign(i, {
          signature: h,
          outputSize: n,
          inputSize: o
        });
      }
    });
    Object.defineProperty(i, "readable", {
      get() {
        return p.pipeThrough(c).pipeThrough(l).pipeThrough(m);
      }
    });
  }
}
class w1 extends TransformStream {
  constructor(t) {
    let r;
    super({
      transform: i,
      flush(a) {
        r && r.length && a.enqueue(r);
      }
    });
    function i(a, s) {
      if (r) {
        const n = new Uint8Array(r.length + a.length);
        n.set(r), n.set(a, r.length), a = n, r = null;
      }
      a.length > t ? (s.enqueue(a.slice(0, t)), i(a.slice(t), s)) : r = a;
    }
  }
}
let Su = typeof Worker != xr;
class xa {
  constructor(t, { readable: r, writable: i }, { options: a, config: s, streamOptions: n, useWebWorkers: o, transferStreams: l, scripts: p }, c) {
    const { signal: m } = n;
    return Object.assign(t, {
      busy: !0,
      readable: r.pipeThrough(new w1(s.chunkSize)).pipeThrough(new b1(r, n), { signal: m }),
      writable: i,
      options: Object.assign({}, a),
      scripts: p,
      transferStreams: l,
      terminate() {
        return new Promise((h) => {
          const { worker: g, busy: R } = t;
          g ? (R ? t.resolveTerminated = h : (g.terminate(), h()), t.interface = null) : h();
        });
      },
      onTaskFinished() {
        const { resolveTerminated: h } = t;
        h && (t.resolveTerminated = null, t.terminated = !0, t.worker.terminate(), h()), t.busy = !1, c(t);
      }
    }), (o && Su ? v1 : Eu)(t, s);
  }
}
class b1 extends TransformStream {
  constructor(t, { onstart: r, onprogress: i, size: a, onend: s }) {
    let n = 0;
    super({
      async start() {
        r && await Sa(r, a);
      },
      async transform(o, l) {
        n += o.length, i && await Sa(i, n, a), l.enqueue(o);
      },
      async flush() {
        t.size = n, s && await Sa(s, n);
      }
    });
  }
}
async function Sa(e, ...t) {
  try {
    await e(...t);
  } catch {
  }
}
function Eu(e, t) {
  return {
    run: () => x1(e, t)
  };
}
function v1(e, t) {
  const { baseURL: r, chunkSize: i } = t;
  if (!e.interface) {
    let a;
    try {
      a = k1(e.scripts[0], r, e);
    } catch {
      return Su = !1, Eu(e, t);
    }
    Object.assign(e, {
      worker: a,
      interface: {
        run: () => S1(e, { chunkSize: i })
      }
    });
  }
  return e.interface;
}
async function x1({ options: e, readable: t, writable: r, onTaskFinished: i }, a) {
  try {
    const s = new g1(e, a);
    await t.pipeThrough(s).pipeTo(r, { preventClose: !0, preventAbort: !0 });
    const {
      signature: n,
      inputSize: o,
      outputSize: l
    } = s;
    return {
      signature: n,
      inputSize: o,
      outputSize: l
    };
  } finally {
    i();
  }
}
async function S1(e, t) {
  let r, i;
  const a = new Promise((h, g) => {
    r = h, i = g;
  });
  Object.assign(e, {
    reader: null,
    writer: null,
    resolveResult: r,
    rejectResult: i,
    result: a
  });
  const { readable: s, options: n, scripts: o } = e, { writable: l, closed: p } = E1(e.writable), c = Hs({
    type: h1,
    scripts: o.slice(1),
    options: n,
    config: t,
    readable: s,
    writable: l
  }, e);
  c || Object.assign(e, {
    reader: s.getReader(),
    writer: l.getWriter()
  });
  const m = await a;
  return c || await l.getWriter().close(), await p, m;
}
function E1(e) {
  let t;
  const r = new Promise((a) => t = a);
  return { writable: new WritableStream({
    async write(a) {
      const s = e.getWriter();
      await s.ready, await s.write(a), s.releaseLock();
    },
    close() {
      t();
    },
    abort(a) {
      return e.getWriter().abort(a);
    }
  }), closed: r };
}
let ep = !0, tp = !0;
function k1(e, t, r) {
  const i = { type: "module" };
  let a, s;
  typeof e == ss && (e = e());
  try {
    a = new URL(e, t);
  } catch {
    a = e;
  }
  if (ep)
    try {
      s = new Worker(a);
    } catch {
      ep = !1, s = new Worker(a, i);
    }
  else
    s = new Worker(a, i);
  return s.addEventListener(d1, (n) => P1(n, r)), s;
}
function Hs(e, { worker: t, writer: r, onTaskFinished: i, transferStreams: a }) {
  try {
    const { value: s, readable: n, writable: o } = e, l = [];
    if (s && (s.byteLength < s.buffer.byteLength ? e.value = s.buffer.slice(0, s.byteLength) : e.value = s.buffer, l.push(e.value)), a && tp ? (n && l.push(n), o && l.push(o)) : e.readable = e.writable = null, l.length)
      try {
        return t.postMessage(e, l), !0;
      } catch {
        tp = !1, e.readable = e.writable = null, t.postMessage(e);
      }
    else
      t.postMessage(e);
  } catch (s) {
    throw r && r.releaseLock(), i(), s;
  }
}
async function P1({ data: e }, t) {
  const { type: r, value: i, messageId: a, result: s, error: n } = e, { reader: o, writer: l, resolveResult: p, rejectResult: c, onTaskFinished: m } = t;
  try {
    if (n) {
      const { message: g, stack: R, code: y, name: _ } = n, w = new Error(g);
      Object.assign(w, { stack: R, code: y, name: _ }), h(w);
    } else {
      if (r == m1) {
        const { value: g, done: R } = await o.read();
        Hs({ type: Jf, value: g, done: R, messageId: a }, t);
      }
      r == Jf && (await l.ready, await l.write(new Uint8Array(i)), Hs({ type: y1, messageId: a }, t)), r == Qf && h(null, s);
    }
  } catch (g) {
    Hs({ type: Qf, messageId: a }, t), h(g);
  }
  function h(g, R) {
    g ? c(g) : p(R), l && l.releaseLock(), m();
  }
}
let Ar = [];
const Ea = [];
let rp = 0;
async function A1(e, t) {
  const { options: r, config: i } = t, { transferStreams: a, useWebWorkers: s, useCompressionStream: n, codecType: o, compressed: l, signed: p, encrypted: c } = r, { workerScripts: m, maxWorkers: h } = i;
  t.transferStreams = a || a === lt;
  const g = !l && !p && !c && !t.transferStreams;
  return t.useWebWorkers = !g && (s || s === lt && i.useWebWorkers), t.scripts = t.useWebWorkers && m ? m[o] : [], r.useCompressionStream = n || n === lt && i.useCompressionStream, (await R()).run();
  async function R() {
    const _ = Ar.find((w) => !w.busy);
    if (_)
      return np(_), new xa(_, e, t, y);
    if (Ar.length < h) {
      const w = { indexWorker: rp };
      return rp++, Ar.push(w), new xa(w, e, t, y);
    } else
      return new Promise((w) => Ea.push({ resolve: w, stream: e, workerOptions: t }));
  }
  function y(_) {
    if (Ea.length) {
      const [{ resolve: w, stream: C, workerOptions: E }] = Ea.splice(0, 1);
      w(new xa(_, C, E, y));
    } else _.worker ? (np(_), T1(_, t)) : Ar = Ar.filter((w) => w != _);
  }
}
function T1(e, t) {
  const { config: r } = t, { terminateWorkerTimeout: i } = r;
  Number.isFinite(i) && i >= 0 && (e.terminated ? e.terminated = !1 : e.terminateTimeout = setTimeout(async () => {
    Ar = Ar.filter((a) => a != e);
    try {
      await e.terminate();
    } catch {
    }
  }, i));
}
function np(e) {
  const { terminateTimeout: t } = e;
  t && (clearTimeout(t), e.terminateTimeout = null);
}
function O1(e, t = {}) {
  const r = `const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self,k=void 0,v="undefined",S="function";class z{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const C=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;C[e]=t}class x{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^C[255&(t^e[n])];this.t=t}get(){return~this.t}}class A extends p{constructor(){let e;const t=new x;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const _={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=_.i(n);return 32===r?e.concat(t):_.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+_.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=_.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=_.i(s);return r.push(_.h(t+i&31,t+i>32?n:r.pop(),1)),r}},I={bytes:{p(e){const t=_.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)3&s||(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},m(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3&~n||(t.push(r),r=0);return 3&n&&t.push(_.h(8*(3&n),r)),t}}},P=class{constructor(e){const t=this;t.blockSize=512,t.k=[1732584193,4023233417,2562383102,271733878,3285377520],t.v=[1518500249,1859775393,2400959708,3395469782],e?(t.S=e.S.slice(0),t.C=e.C.slice(0),t.A=e.A):t.reset()}reset(){const e=this;return e.S=e.k.slice(0),e.C=[],e.A=0,e}update(e){const t=this;"string"==typeof e&&(e=I._.m(e));const n=t.C=_.concat(t.C,e),r=t.A,i=t.A=r+_.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.I(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}P(){const e=this;let t=e.C;const n=e.S;t=_.concat(t,[_.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e.A/4294967296)),t.push(0|e.A);t.length;)e.I(t.splice(0,16));return e.reset(),n}D(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}V(e,t){return t<<e|t>>>32-e}I(t){const n=this,s=n.S,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.V(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.V(5,o)+n.D(e,c,f,a)+l+i[e]+n.v[r.floor(e/20)]|0;l=a,a=f,f=n.V(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},D={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},V={importKey:e=>new V.R(I.bytes.m(e)),B(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=_;for(t=I.bytes.m(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},R:class{constructor(e){const t=this,n=t.M=P,r=[[],[]];t.U=[new n,new n];const s=t.U[0].blockSize/32;e.length>s&&(e=(new n).update(e).P());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.U[0].update(r[0]),t.U[1].update(r[1]),t.K=new n(t.U[0])}reset(){const e=this;e.K=new e.M(e.U[0]),e.N=!1}update(e){this.N=!0,this.K.update(e)}digest(){const e=this,t=e.K.P(),n=new e.M(e.U[1]).update(t).P();return e.reset(),n}encrypt(e){if(this.N)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},R=typeof h!=v&&typeof h.getRandomValues==S,B="Invalid password",E="Invalid signature",M="zipjs-abort-check-password";function U(e){return R?h.getRandomValues(e):D.getRandomValues(e)}const K=16,N={name:"PBKDF2"},O=t.assign({hash:{name:"HMAC"}},N),T=t.assign({iterations:1e3,hash:{name:"SHA-1"}},N),W=["deriveBits"],j=[8,12,16],H=[16,24,32],L=10,F=[0,0,0,0],q=typeof h!=v,G=q&&h.subtle,J=q&&typeof G!=v,Q=I.bytes,X=class{constructor(e){const t=this;t.O=[[[],[],[],[],[]],[[],[],[],[],[]]],t.O[0][0][0]||t.T();const n=t.O[0][4],r=t.O[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.v=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.W(e,0)}decrypt(e){return this.W(e,1)}T(){const e=this.O[0],t=this.O[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}W(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.v[t],r=n.length/4-2,i=[0,0,0,0],o=this.O[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},Y=class{constructor(e,t){this.j=e,this.H=t,this.L=t}reset(){this.L=this.H}update(e){return this.F(this.j,e,this.L)}q(e){if(255&~(e>>24))e+=1<<24;else{let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}return e}G(e){0===(e[0]=this.q(e[0]))&&(e[1]=this.q(e[1]))}F(e,t,n){let r;if(!(r=t.length))return[];const s=_.l(t);for(let s=0;r>s;s+=4){this.G(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return _.u(t,s)}},Z=V.R;let $=q&&J&&typeof G.importKey==S,ee=q&&J&&typeof G.deriveBits==S;class te extends p{constructor({password:e,rawPassword:n,signed:r,encryptionStrength:o,checkPasswordOnly:c}){super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),signed:r,X:o-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:o,J:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await se(e,t,n,ce(r,0,j[t])),o=ce(r,j[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(B)})(n,o,r,ce(e,0,j[o]+2)),e=ce(e,j[o]+2),c?t.error(new s(M)):f()):await a;const l=new i(e.length-L-(e.length-L)%K);t.enqueue(re(n,e,l,0,L,!0))},async flush(e){const{signed:t,Y:n,Z:r,pending:o,ready:c}=this;if(r&&n){await c;const f=ce(o,0,o.length-L),a=ce(o,o.length-L);let l=new i;if(f.length){const e=ae(Q,f);r.update(e);const t=n.update(e);l=fe(Q,t)}if(t){const e=ce(fe(Q,r.digest()),0,L);for(let t=0;L>t;t++)if(e[t]!=a[t])throw new s(E)}e.enqueue(l)}}})}}class ne extends p{constructor({password:e,rawPassword:n,encryptionStrength:r}){let s;super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),X:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:s,J:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=U(new i(j[t]));return oe(r,await se(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%K);a.set(f,0),t.enqueue(re(n,e,a,f.length,0))},async flush(e){const{Y:t,Z:n,pending:r,ready:o}=this;if(n&&t){await o;let c=new i;if(r.length){const e=t.update(ae(Q,r));n.update(e),c=fe(Q,e)}s.signature=fe(Q,n.digest()).slice(0,L),e.enqueue(oe(c,s.signature))}}}),s=this}}function re(e,t,n,r,s,o){const{Y:c,Z:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=oe(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%K)),u=0;l-K>=u;u+=K){const e=ae(Q,ce(t,u,u+K));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(fe(Q,s),u+r)}return e.pending=ce(t,u),n}async function se(n,r,s,o){n.password=null;const c=await(async(e,t,n,r,s)=>{if(!$)return V.importKey(t);try{return await G.importKey("raw",t,n,!1,s)}catch(e){return $=!1,V.importKey(t)}})(0,s,O,0,W),f=await(async(e,t,n)=>{if(!ee)return V.B(t,e.salt,T.iterations,n);try{return await G.deriveBits(e,t,n)}catch(r){return ee=!1,V.B(t,e.salt,T.iterations,n)}})(t.assign({salt:o},T),c,8*(2*H[r]+2)),a=new i(f),l=ae(Q,ce(a,0,H[r])),u=ae(Q,ce(a,H[r],2*H[r])),w=ce(a,2*H[r]);return t.assign(n,{keys:{key:l,$:u,passwordVerification:w},Y:new Y(new X(l),e.from(F)),Z:new Z(u)}),w}function ie(e,t){return t===k?(e=>{if(typeof w==v){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(e):t}function oe(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ce(e,t,n){return e.subarray(t,n)}function fe(e,t){return e.p(t)}function ae(e,t){return e.m(t)}class le extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;if(n.password){const t=we(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(B);e=e.subarray(12)}r?t.error(new s(M)):t.enqueue(we(n,e))}})}}class ue extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=U(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(he(n,t),0),s=12}else r=new i(e.length),s=0;r.set(he(n,e),s),t.enqueue(r)}})}}function we(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,n[r]);return n}function he(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,t[r]);return n}function de(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,ee:new x(r[0]),te:new x(r[2])});for(let t=0;t<n.length;t++)pe(e,n.charCodeAt(t))}function pe(e,t){let[n,s,i]=e.keys;e.ee.append([t]),n=~e.ee.get(),s=be(r.imul(be(s+me(n)),134775813)+1),e.te.append([s>>>24]),i=~e.te.get(),e.keys=[n,s,i]}function ye(e){const t=2|e.keys[2];return me(r.imul(t,1^t)>>>8)}function me(e){return 255&e}function be(e){return 4294967295&e}const ge="deflate-raw";class ke extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=Se(super.readable);i&&!c||!f||(w=new A,d=xe(d,w)),s&&(d=Ce(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=xe(d,new ue(e)):(h=new ne(e),d=xe(d,h))),ze(u,d,(()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ve extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=Se(super.readable);o&&(i?d=xe(d,new le(e)):(h=new te(e),d=xe(d,h))),a&&(d=Ce(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new A,d=xe(d,w)),ze(this,d,(()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(E)}}))}}function Se(e){return xe(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ze(e,n,r){n=xe(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Ce(e,t,n,r,s){try{e=xe(e,new(t&&r?r:s)(ge,n))}catch(r){if(!t)return e;try{e=xe(e,new s(ge,n))}catch(t){return e}}return e}function xe(e,t){return e.pipeThrough(t)}const Ae="data",_e="close";class Ie extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=ke:s.startsWith("inflate")&&(i=ve);let o=0,c=0;const f=new i(e,n),a=super.readable,l=new p({transform(e,t){e&&e.length&&(c+=e.length,t.enqueue(e))},flush(){t.assign(r,{inputSize:c})}}),u=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=f;t.assign(r,{signature:e,outputSize:o,inputSize:c})}});t.defineProperty(r,"readable",{get:()=>a.pipeThrough(l).pipeThrough(f).pipeThrough(u)})}}class Pe extends p{constructor(e){let t;super({transform:function n(r,s){if(t){const e=new i(t.length+r.length);e.set(t),e.set(r,t.length),r=e,t=null}r.length>e?(s.enqueue(r.slice(0,e)),n(r.slice(e),s)):t=r},flush(e){t&&t.length&&e.enqueue(t)}})}}const De=new a,Ve=new a;let Re,Be=0,Ee=!0;async function Me(e){try{const{options:t,scripts:r,config:s}=e;if(r&&r.length)try{Ee?importScripts.apply(k,r):await Ue(r)}catch(e){Ee=!1,await Ue(r)}self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new z(self.Deflate)),self.Inflate&&(s.DecompressionStream=new z(self.Inflate));const i={highWaterMark:1},o=e.readable||new y({async pull(e){const t=new u((e=>De.set(Be,e)));Ke({type:"pull",messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ve.set(Be,t),Ke({type:Ae,value:e,messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new Ie(t,s);Re=new AbortController;const{signal:a}=Re;await o.pipeThrough(f).pipeThrough(new Pe(s.chunkSize)).pipeTo(c,{signal:a,preventClose:!0,preventAbort:!0}),await c.getWriter().close();const{signature:l,inputSize:w,outputSize:h}=f;Ke({type:_e,result:{signature:l,inputSize:w,outputSize:h}})}catch(e){Ne(e)}}async function Ue(e){for(const t of e)await import(t)}function Ke(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Ne(e=new s("Unknown error")){const{message:t,stack:n,code:r,name:i}=e;d({error:{message:t,stack:n,code:r,name:i}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&Me(e),t==Ae){const e=De.get(n);De.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ve.get(n);Ve.delete(n),e()}t==_e&&Re.abort()}catch(e){Ne(e)}}));const Oe=-2;function Te(t){return We(t.map((([t,n])=>new e(t).fill(n,0,t))))}function We(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?We(n):n)),[])}const je=[0,1,2,3].concat(...Te([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function He(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.ne=n=>{const s=e.re,i=e.ie.se,o=e.ie.oe;let c,f,a,l=-1;for(n.ce=0,n.fe=573,c=0;o>c;c++)0!==s[2*c]?(n.ae[++n.ce]=l=c,n.le[c]=0):s[2*c+1]=0;for(;2>n.ce;)a=n.ae[++n.ce]=2>l?++l:0,s[2*a]=1,n.le[a]=0,n.ue--,i&&(n.we-=i[2*a+1]);for(e.he=l,c=r.floor(n.ce/2);c>=1;c--)n.de(s,c);a=o;do{c=n.ae[1],n.ae[1]=n.ae[n.ce--],n.de(s,1),f=n.ae[1],n.ae[--n.fe]=c,n.ae[--n.fe]=f,s[2*a]=s[2*c]+s[2*f],n.le[a]=r.max(n.le[c],n.le[f])+1,s[2*c+1]=s[2*f+1]=a,n.ae[1]=a++,n.de(s,1)}while(n.ce>=2);n.ae[--n.fe]=n.ae[1],(t=>{const n=e.re,r=e.ie.se,s=e.ie.pe,i=e.ie.ye,o=e.ie.me;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.be[l]=0;for(n[2*t.ae[t.fe]+1]=0,c=t.fe+1;573>c;c++)f=t.ae[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.he||(t.be[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.ue+=w*(l+u),r&&(t.we+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.be[l];)l--;t.be[l]--,t.be[l+1]+=2,t.be[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.be[l];0!==f;)a=t.ae[--c],a>e.he||(n[2*a+1]!=l&&(t.ue+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.he,n.be)}}function Le(e,t,n,r,s){const i=this;i.se=e,i.pe=t,i.ye=n,i.oe=r,i.me=s}He.ge=[0,1,2,3,4,5,6,7].concat(...Te([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),He.ke=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],He.ve=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],He.Se=e=>256>e?je[e]:je[256+(e>>>7)],He.ze=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],He.Ce=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],He.xe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],He.Ae=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Fe=Te([[144,8],[112,9],[24,7],[8,8]]);Le._e=We([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Fe[t]])));const qe=Te([[30,5]]);function Ge(e,t,n,r,s){const i=this;i.Ie=e,i.Pe=t,i.De=n,i.Ve=r,i.Re=s}Le.Be=We([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,qe[t]]))),Le.Ee=new Le(Le._e,He.ze,257,286,15),Le.Me=new Le(Le.Be,He.Ce,0,30,15),Le.Ue=new Le(null,He.xe,0,19,7);const Je=[new Ge(0,0,0,0,0),new Ge(4,4,8,4,1),new Ge(4,5,16,8,1),new Ge(4,6,32,32,1),new Ge(4,4,16,16,2),new Ge(8,16,32,32,2),new Ge(8,16,128,128,2),new Ge(8,32,128,256,2),new Ge(32,128,258,1024,2),new Ge(32,258,258,4096,2)],Qe=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],Xe=113,Ye=666,Ze=262;function $e(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function et(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,A,_,I,P,D,V,R,B,E,M,U;const K=new He,N=new He,O=new He;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)U[2*t]=0;E[512]=1,e.ue=e.we=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?U[2*n]+=i:0!==n?(n!=r&&U[2*n]++,U[32]++):i>10?U[36]++:U[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ke[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,U)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,U),o--),Y(16,U),X(o-3,2)):o>10?(Y(18,U),X(o-11,7)):(Y(17,U),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Ne[W]=t,e.Oe[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(He.ge[n]+256+1)]++,M[2*He.Se(t)]++),!(8191&W)&&D>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+He.Ce[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Ne[c],s=e.Oe[c],c++,0===r?Y(s,t):(i=He.ge[s],Y(i+256+1,t),o=He.ze[i],0!==o&&(s-=He.ke[i],X(s,o)),r--,i=He.Se(r),Y(i,n),o=He.Ce[i],0!==o&&(r-=He.ve[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ke.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;D>0?(K.ne(e),N.ne(e),o=(()=>{let t;for(G(E,K.he),G(M,N.he),O.ne(e),t=18;t>=3&&0===U[2*He.Ae[t]+1];t--);return e.ue+=14+3*(t+1),t})(),s=e.ue+3+7>>>3,i=e.we+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Le._e,Le.Be)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(U[2*He.Ae[r]+1],3);Z(E,e-1),Z(M,t-1)})(K.he+1,N.he+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.Te()}function ie(){let e,n,r,s;do{if(s=w-A-C,0===s&&0===C&&0===A)s=f;else if(-1==s)s--;else if(C>=f+f-Ze){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.We)return;e=t.je(u,C+A,s),A+=e,3>A||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Ze>A&&0!==t.We)}function oe(e){let t,n,r=I,s=C,i=_;const o=C>f-Ze?C-(f-Ze):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>_||(r>>=2),c>A&&(c=A);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>A?A:i}e.le=[],e.be=[],e.ae=[],E=[],M=[],U=[],e.de=(t,n)=>{const r=e.ae,s=r[n];let i=n<<1;for(;i<=e.ce&&(i<e.ce&&$e(t,r[i+1],r[i],e.le)&&i++,!$e(t,s,r[i],e.le));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.He=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Le=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Oe:(t.Fe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ke=new i(4*T),s=4*T,e.Ne=new o(T),e.Oe=new i(T),D=S,V=G,(t=>(t.qe=t.Ge=0,t.Le=null,e.pending=0,e.Je=0,n=Xe,c=0,K.re=E,K.ie=Le.Ee,N.re=M,N.ie=Le.Me,O.re=U,O.ie=Le.Ue,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve,C=0,k=0,A=0,v=_=2,z=0,p=0})(),0))(t))),e.Qe=()=>42!=n&&n!=Xe&&n!=Ye?Oe:(e.Oe=null,e.Ne=null,e.Ke=null,d=null,h=null,u=null,e.Fe=null,n==Xe?-3:0),e.Xe=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Oe:(Je[D].Re!=Je[t].Re&&0!==e.qe&&(r=e.Ye(1)),D!=t&&(D=t,P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve),V=n,r)},e.Ze=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Oe;if(3>i)return 0;for(i>f-Ze&&(i=f-Ze,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ye=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Oe;if(!r.$e||!r.et&&0!==r.We||n==Ye&&4!=i)return r.Le=Qe[4],Oe;if(0===r.tt)return r.Le=Qe[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(D-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=Xe,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.Te(),0===t.tt)return c=-1,0}else if(0===t.We&&I>=i&&4!=i)return t.Le=Qe[7],-5;if(n==Ye&&0!==t.We)return r.Le=Qe[7],-5;if(0!==t.We||0!==A||0!=i&&n!=Ye){switch(R=-1,Je[D].Re){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=A){if(ie(),0===A&&0==e)return 0;if(0===A)break}if(C+=A,A=0,n=k+r,(0===C||C>=n)&&(A=C-n,C=n,se(!1),0===t.tt))return 0;if(C-k>=f-Ze&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Ze||2!=V&&(v=oe(r)),3>v)n=ee(0,255&u[C]),A--,C++;else if(n=ee(C-x,v-3),A-=v,v>P||3>A)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),_=v,S=x,v=2,0!==s&&P>_&&f-Ze>=(C-s&65535)&&(2!=V&&(v=oe(s)),5>=v&&(1==V||3==v&&C-x>4096)&&(v=2)),3>_||v>_)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,A--,0===t.tt)return 0}else z=1,C++,A--;else{r=C+A-3,n=ee(C-1-S,_-3),A-=_-1,_-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--_);if(z=0,v=2,C++,n&&(se(!1),0===t.tt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Ye),0==R||2==R)return 0===t.tt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Le._e),$(),9>1+H+10-F&&(X(2,3),Y(256,Le._e),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.Te(),0===t.tt)return c=-1,0}}return 4!=i?0:1}}function tt(){const e=this;e.nt=0,e.rt=0,e.We=0,e.qe=0,e.tt=0,e.Ge=0}function nt(e){const t=new tt,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.He(f),t.$e=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,o=t.Ye(0),0!=o)throw new s("deflating: "+t.Le);t.rt&&(t.rt==n?w.push(new i(c)):w.push(c.subarray(0,t.rt))),u+=t.rt,r&&t.nt>0&&t.nt!=a&&(r(t.nt),a=t.nt)}while(t.We>0||0===t.tt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.rt=0,t.tt=n,e=t.Ye(4),1!=e&&0!=e)throw new s("deflating: "+t.Le);n-t.tt>0&&a.push(c.slice(0,t.rt)),f+=t.rt}while(t.We>0||0===t.tt);return t.Qe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}tt.prototype={He(e,t){const n=this;return n.Fe=new et,t||(t=15),n.Fe.He(n,e,t)},Ye(e){const t=this;return t.Fe?t.Fe.Ye(t,e):Oe},Qe(){const e=this;if(!e.Fe)return Oe;const t=e.Fe.Qe();return e.Fe=null,t},Xe(e,t){const n=this;return n.Fe?n.Fe.Xe(n,e,t):Oe},Ze(e,t){const n=this;return n.Fe?n.Fe.Ze(n,e,t):Oe},je(e,t,n){const r=this;let s=r.We;return s>n&&(s=n),0===s?0:(r.We-=s,e.set(r.et.subarray(r.nt,r.nt+s),t),r.nt+=s,r.qe+=s,s)},Te(){const e=this;let t=e.Fe.pending;t>e.tt&&(t=e.tt),0!==t&&(e.$e.set(e.Fe.Ke.subarray(e.Fe.Je,e.Fe.Je+t),e.rt),e.rt+=t,e.Fe.Je+=t,e.Ge+=t,e.tt-=t,e.Fe.pending-=t,0===e.Fe.pending&&(e.Fe.Je=0))}};const rt=-2,st=-3,it=-5,ot=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],ct=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],ft=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],at=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],lt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],ut=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],wt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ht(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,A,_,I,P;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return st;if(0>(I-=n[g]))return st;for(n[g]+=I,i[1]=k=0,C=1,_=2;0!=--g;)i[_]=k+=n[C],_++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,A=-S,s[0]=0,x=0,P=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>A+S;){if(b++,A+=S,P=m-A,P=P>S?S:P,(y=1<<(k=v-A))>p+1&&(y-=p+1,_=v,P>k))for(;++k<P&&(y<<=1)>n[++_];)y-=n[_];if(P=1<<k,h[0]+P>1440)return st;s[b]=x=h[0],h[0]+=P,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>A-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-A,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-A,k=g>>>A;P>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;g&k;k>>>=1)g^=k;for(g^=k,z=(1<<A)-1;(g&z)!=i[b];)b--,A-=S,z=(1<<A)-1}return 0!==I&&1!=m?it:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.st=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==st?f.Le="oversubscribed dynamic bit lengths tree":a!=it&&0!==r[0]||(f.Le="incomplete dynamic bit lengths tree",a=st),a},this.it=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,at,lt,a,i,u,e,t),0!=h||0===i[0]?(h==st?w.Le="oversubscribed literal/length tree":-4!=h&&(w.Le="incomplete literal/length tree",h=st),h):(c(288),h=o(s,n,r,0,ut,wt,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==st?w.Le="oversubscribed distance tree":h==it?(w.Le="incomplete distance tree",h=st):-4!=h&&(w.Le="empty distance tree with lengths",h=st),h):0)}}function dt(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.nt,p=c.We,w=o.ot,h=o.ct,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=ot[e],g=ot[t];do{for(;20>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15,k=a[z+2]+(w&ot[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15;u>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(v=a[z+2]+(w&ot[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--u);else o.lt.set(o.lt.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.lt[y++]=o.lt[S++],o.lt[y++]=o.lt[S++],k-=2):(o.lt.set(o.lt.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--k);else o.lt.set(o.lt.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(64&u)return c.Le="invalid distance code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st;f+=a[z+2],f+=w&ot[u],z=3*(l+f),u=a[z]}break}if(64&u)return 32&u?(k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,1):(c.Le="invalid literal/length code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st);if(f+=a[z+2],f+=w&ot[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.ut=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,A=0,_=0;for(_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,m=p(u,w,r,h,s,d,e,y),_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>>=n[g+1],A-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(16&k){a=15&k,i=n[g+2],t=2;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}if(32&k){t=7;break}return t=9,y.Le="invalid literal/length code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 2:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}i+=x&ot[b],x>>=b,A-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>=n[g+1],A-=n[g+1],k=n[g],16&k){a=15&k,l=n[g+2],t=4;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Le="invalid distance code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 4:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}l+=x&ot[b],x>>=b,A-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);e.lt[S++]=e.lt[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,e.lt[S++]=f,z--,t=0;break;case 7:if(A>7&&(A-=8,v++,_--),e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);t=8;case 8:return m=1,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 9:return m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);default:return m=rt,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m)}},e.ht=()=>{}}ht.dt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=ct,r[0]=ft,0);const pt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function yt(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new dt;let h=0,d=new f(4320);const p=new ht;n.ct=0,n.ot=0,n.lt=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.ht(e),s=0,n.ct=0,n.ot=0,n.read=n.write=0},n.reset(e,null),n.wt=(e,t)=>{let r,s,i;return s=e.rt,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r),e.rt=s,n.read=i,t},n.ut=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,A,_,I,P;switch(s){case 0:for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ht.dt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Le="invalid block type",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Le="invalid stored block lengths",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.lt.set(e.je(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Le="too many length or distance symbols",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}r[pt[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[pt[a++]]=0;if(l[0]=7,i=p.st(r,l,u,d,e),0!=i)return(t=i)==st&&(r=null,s=9),n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&ot[i]))+1],w=d[3*(u[0]+(f&ot[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&ot[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Le="invalid bit length repeat",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,A=[],_=[],I=[],P=[],A[0]=9,_[0]=6,i=c,i=p.it(257+(31&i),1+(i>>5&31),r,A,_,I,P,d,e),0!=i)return i==st&&(r=null,s=9),t=i,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w.init(A[0],_[0],d,I[0],d,P[0]),s=6;case 6:if(n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,1!=(t=w.ut(n,e,t)))return n.wt(e,t);if(t=0,w.ht(e),m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);s=8;case 8:return t=1,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);case 9:return t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);default:return t=rt,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}}},n.ht=e=>{n.reset(e,null),n.lt=null,d=null},n.yt=(e,t,r)=>{n.lt.set(e.subarray(t,t+r),0),n.read=n.write=r},n.bt=()=>1==s?1:0}const mt=13,bt=[0,0,255,255];function gt(){const e=this;function t(e){return e&&e.gt?(e.qe=e.Ge=0,e.Le=null,e.gt.mode=7,e.gt.kt.reset(e,null),0):rt}e.mode=0,e.method=0,e.vt=[0],e.St=0,e.marker=0,e.zt=0,e.Ct=t=>(e.kt&&e.kt.ht(t),e.kt=null,0),e.xt=(n,r)=>(n.Le=null,e.kt=null,8>r||r>15?(e.Ct(n),rt):(e.zt=r,n.gt.kt=new yt(n,1<<r),t(n),0)),e.At=(e,t)=>{let n,r;if(!e||!e.gt||!e.et)return rt;const s=e.gt;for(t=4==t?it:0,n=it;;)switch(s.mode){case 0:if(0===e.We)return n;if(n=t,e.We--,e.qe++,8!=(15&(s.method=e.ft(e.nt++)))){s.mode=mt,e.Le="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.zt){s.mode=mt,e.Le="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.We)return n;if(n=t,e.We--,e.qe++,r=255&e.ft(e.nt++),((s.method<<8)+r)%31!=0){s.mode=mt,e.Le="incorrect header check",s.marker=5;break}if(!(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St=(255&e.ft(e.nt++))<<24&4278190080,s.mode=3;case 3:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<16&16711680,s.mode=4;case 4:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<8&65280,s.mode=5;case 5:return 0===e.We?n:(n=t,e.We--,e.qe++,s.St+=255&e.ft(e.nt++),s.mode=6,2);case 6:return s.mode=mt,e.Le="need dictionary",s.marker=0,rt;case 7:if(n=s.kt.ut(e,n),n==st){s.mode=mt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.kt.reset(e,s.vt),s.mode=12;case 12:return e.We=0,1;case mt:return st;default:return rt}},e._t=(e,t,n)=>{let r=0,s=n;if(!e||!e.gt||6!=e.gt.mode)return rt;const i=e.gt;return s<1<<i.zt||(s=(1<<i.zt)-1,r=n-s),i.kt.yt(t,r,s),i.mode=7,0},e.It=e=>{let n,r,s,i,o;if(!e||!e.gt)return rt;const c=e.gt;if(c.mode!=mt&&(c.mode=mt,c.marker=0),0===(n=e.We))return it;for(r=e.nt,s=c.marker;0!==n&&4>s;)e.ft(r)==bt[s]?s++:s=0!==e.ft(r)?0:4-s,r++,n--;return e.qe+=r-e.nt,e.nt=r,e.We=n,c.marker=s,4!=s?st:(i=e.qe,o=e.Ge,t(e),e.qe=i,e.Ge=o,c.mode=7,0)},e.Pt=e=>e&&e.gt&&e.gt.kt?e.gt.kt.bt():rt}function kt(){}function vt(e){const t=new kt,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.xt(),t.$e=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,0!==t.We||c||(t.nt=0,c=!0),a=t.At(0),c&&a===it){if(0!==t.We)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Le);if((c||1===a)&&t.We===e.length)throw new s("inflating: bad input");t.rt&&(t.rt===n?f.push(new i(o)):f.push(o.subarray(0,t.rt))),h+=t.rt,r&&t.nt>0&&t.nt!=u&&(r(t.nt),u=t.nt)}while(t.We>0||0===t.tt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.Ct()}}kt.prototype={xt(e){const t=this;return t.gt=new gt,e||(e=15),t.gt.xt(t,e)},At(e){const t=this;return t.gt?t.gt.At(t,e):rt},Ct(){const e=this;if(!e.gt)return rt;const t=e.gt.Ct(e);return e.gt=null,t},It(){const e=this;return e.gt?e.gt.It(e):rt},_t(e,t){const n=this;return n.gt?n.gt._t(n,e,t):rt},ft(e){return this.et[e]},je(e,t){return this.et.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=nt,self.Inflate=vt};
`, i = () => t.useDataURI ? "data:text/javascript," + encodeURIComponent(r) : URL.createObjectURL(new Blob([r], { type: "text/javascript" }));
  e({ workerScripts: { inflate: [i], deflate: [i] } });
}
const C1 = "Writer iterator completed too soon", L1 = "Content-Type", R1 = 64 * 1024, ku = "writable";
class To {
  constructor() {
    this.size = 0;
  }
  init() {
    this.initialized = !0;
  }
}
class Pu extends To {
  get readable() {
    const t = this, { chunkSize: r = R1 } = t, i = new ReadableStream({
      start() {
        this.chunkOffset = 0;
      },
      async pull(a) {
        const { offset: s = 0, size: n, diskNumberStart: o } = i, { chunkOffset: l } = this;
        a.enqueue(await et(t, s + l, Math.min(r, n - l), o)), l + r > n ? a.close() : this.chunkOffset += r;
      }
    });
    return i;
  }
}
class Ya extends Pu {
  constructor(t) {
    super(), Object.assign(this, {
      blob: t,
      size: t.size
    });
  }
  async readUint8Array(t, r) {
    const i = this, a = t + r;
    let n = await (t || a < i.size ? i.blob.slice(t, a) : i.blob).arrayBuffer();
    return n.byteLength > r && (n = n.slice(t, a)), new Uint8Array(n);
  }
}
class $1 extends To {
  constructor(t) {
    super();
    const r = this, i = new TransformStream(), a = [];
    t && a.push([L1, t]), Object.defineProperty(r, ku, {
      get() {
        return i.writable;
      }
    }), r.blob = new Response(i.readable, { headers: a }).blob();
  }
  getData() {
    return this.blob;
  }
}
class I1 extends Pu {
  constructor(t) {
    super(), this.readers = t;
  }
  async init() {
    const t = this, { readers: r } = t;
    t.lastDiskNumber = 0, t.lastDiskOffset = 0, await Promise.all(r.map(async (i, a) => {
      await i.init(), a != r.length - 1 && (t.lastDiskOffset += i.size), t.size += i.size;
    })), super.init();
  }
  async readUint8Array(t, r, i = 0) {
    const a = this, { readers: s } = this;
    let n, o = i;
    o == -1 && (o = s.length - 1);
    let l = t;
    for (; l >= s[o].size; )
      l -= s[o].size, o++;
    const p = s[o], c = p.size;
    if (l + r <= c)
      n = await et(p, l, r);
    else {
      const m = c - l;
      n = new Uint8Array(r), n.set(await et(p, l, m)), n.set(await a.readUint8Array(t + m, r - m, i), m);
    }
    return a.lastDiskNumber = Math.max(o, a.lastDiskNumber), n;
  }
}
class sp extends To {
  constructor(t, r = 4294967295) {
    super();
    const i = this;
    Object.assign(i, {
      diskNumber: 0,
      diskOffset: 0,
      size: 0,
      maxSize: r,
      availableSize: r
    });
    let a, s, n;
    const o = new WritableStream({
      async write(c) {
        const { availableSize: m } = i;
        if (n)
          c.length >= m ? (await l(c.slice(0, m)), await p(), i.diskOffset += a.size, i.diskNumber++, n = null, await this.write(c.slice(m))) : await l(c);
        else {
          const { value: h, done: g } = await t.next();
          if (g && !h)
            throw new Error(C1);
          a = h, a.size = 0, a.maxSize && (i.maxSize = a.maxSize), i.availableSize = i.maxSize, await ti(a), s = h.writable, n = s.getWriter(), await this.write(c);
        }
      },
      async close() {
        await n.ready, await p();
      }
    });
    Object.defineProperty(i, ku, {
      get() {
        return o;
      }
    });
    async function l(c) {
      const m = c.length;
      m && (await n.ready, await n.write(c), a.size += m, i.size += m, i.availableSize -= m);
    }
    async function p() {
      s.size = a.size, await n.close();
    }
  }
}
async function ti(e, t) {
  if (e.init && !e.initialized)
    await e.init(t);
  else
    return Promise.resolve();
}
function D1(e) {
  return Array.isArray(e) && (e = new I1(e)), e instanceof ReadableStream && (e = {
    readable: e
  }), e;
}
function H1(e) {
  e.writable === lt && typeof e.next == ss && (e = new sp(e)), e instanceof WritableStream && (e = {
    writable: e
  });
  const { writable: t } = e;
  return t.size === lt && (t.size = 0), e instanceof sp || Object.assign(e, {
    diskNumber: 0,
    diskOffset: 0,
    availableSize: 1 / 0,
    maxSize: 1 / 0
  }), e;
}
function et(e, t, r, i) {
  return e.readUint8Array(t, r, i);
}
const Au = "\0â˜ºâ˜»â™¥â™¦â™£â™ â€¢â—˜â—‹â—™â™‚â™€â™ªâ™«â˜¼â–ºâ—„â†•â€¼Â¶Â§â–¬â†¨â†‘â†“â†’â†âˆŸâ†”â–²â–¼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~âŒ‚Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â–  ".split(""), F1 = Au.length == 256;
function B1(e) {
  if (F1) {
    let t = "";
    for (let r = 0; r < e.length; r++)
      t += Au[e[r]];
    return t;
  } else
    return new TextDecoder().decode(e);
}
function Fs(e, t) {
  return t && t.trim().toLowerCase() == "cp437" ? B1(e) : new TextDecoder(t).decode(e);
}
const Tu = "filename", Ou = "rawFilename", Cu = "comment", Lu = "rawComment", Ru = "uncompressedSize", $u = "compressedSize", Iu = "offset", Xa = "diskNumberStart", Ja = "lastModDate", Qa = "rawLastModDate", Du = "lastAccessDate", N1 = "rawLastAccessDate", Hu = "creationDate", j1 = "rawCreationDate", U1 = "internalFileAttribute", W1 = "internalFileAttributes", M1 = "externalFileAttribute", q1 = "externalFileAttributes", K1 = "msDosCompatible", z1 = "zip64", G1 = "encrypted", V1 = "version", Z1 = "versionMadeBy", Y1 = "zipCrypto", X1 = "directory", J1 = "executable", Q1 = [
  Tu,
  Ou,
  $u,
  Ru,
  Ja,
  Qa,
  Cu,
  Lu,
  Du,
  Hu,
  Iu,
  Xa,
  Xa,
  U1,
  W1,
  M1,
  q1,
  K1,
  z1,
  G1,
  V1,
  Z1,
  Y1,
  X1,
  J1,
  "bitFlag",
  "signature",
  "filenameUTF8",
  "commentUTF8",
  "compressionMethod",
  "extraField",
  "rawExtraField",
  "extraFieldZip64",
  "extraFieldUnicodePath",
  "extraFieldUnicodeComment",
  "extraFieldAES",
  "extraFieldNTFS",
  "extraFieldExtendedTimestamp"
];
class ip {
  constructor(t) {
    Q1.forEach((r) => this[r] = t[r]);
  }
}
const ka = "File format is not recognized", ew = "End of central directory not found", tw = "End of Zip64 central directory locator not found", rw = "Central directory header not found", nw = "Local file header not found", sw = "Zip64 extra field not found", iw = "File contains encrypted entry", aw = "Encryption method not supported", ap = "Compression method not supported", op = "Split zip file", lp = "utf-8", fp = "cp437", ow = [
  [Ru, Rr],
  [$u, Rr],
  [Iu, Rr],
  [Xa, mr]
], lw = {
  [mr]: {
    getValue: je,
    bytes: 4
  },
  [Rr]: {
    getValue: Bs,
    bytes: 8
  }
};
class pp {
  constructor(t, r = {}) {
    Object.assign(this, {
      reader: D1(t),
      options: r,
      config: Wg()
    });
  }
  async *getEntriesGenerator(t = {}) {
    const r = this;
    let { reader: i } = r;
    const { config: a } = r;
    if (await ti(i), (i.size === lt || !i.readUint8Array) && (i = new Ya(await new Response(i.readable).blob()), await ti(i)), i.size < Yr)
      throw new Error(ka);
    i.chunkSize = Mg(a);
    const s = await hw(i, Og, i.size, Yr, mr * 16);
    if (!s) {
      const S = await et(i, 0, 4), P = Ze(S);
      throw je(P) == Tg ? new Error(op) : new Error(ew);
    }
    const n = Ze(s);
    let o = je(n, 12), l = je(n, 16);
    const p = s.offset, c = Ve(n, 20), m = p + Yr + c;
    let h = Ve(n, 4);
    const g = i.lastDiskNumber || 0;
    let R = Ve(n, 6), y = Ve(n, 8), _ = 0, w = 0;
    if (l == Rr || o == Rr || y == mr || R == mr) {
      const S = await et(i, s.offset - wa, wa), P = Ze(S);
      if (je(P, 0) == Cg) {
        l = Bs(P, 8);
        let I = await et(i, l, ba, -1), $ = Ze(I);
        const N = s.offset - wa - ba;
        if (je($, 0) != Ff && l != N) {
          const U = l;
          l = N, _ = l - U, I = await et(i, l, ba, -1), $ = Ze(I);
        }
        if (je($, 0) != Ff)
          throw new Error(tw);
        h == mr && (h = je($, 16)), R == mr && (R = je($, 20)), y == mr && (y = Bs($, 32)), o == Rr && (o = Bs($, 40)), l -= o;
      }
    }
    if (l >= i.size && (_ = i.size - l - o - Yr, l = i.size - o - Yr), g != h)
      throw new Error(op);
    if (l < 0)
      throw new Error(ka);
    let C = 0, E = await et(i, l, o, R), D = Ze(E);
    if (o) {
      const S = s.offset - o;
      if (je(D, C) != Hf && l != S) {
        const P = l;
        l = S, _ += l - P, E = await et(i, l, o, R), D = Ze(E);
      }
    }
    const T = s.offset - l - (i.lastDiskOffset || 0);
    if (o != T && T >= 0 && (o = T, E = await et(i, l, o, R), D = Ze(E)), l < 0 || l >= i.size)
      throw new Error(ka);
    const H = it(r, t, "filenameEncoding"), k = it(r, t, "commentEncoding");
    for (let S = 0; S < y; S++) {
      const P = new fw(i, a, r.options);
      if (je(D, C) != Hf)
        throw new Error(rw);
      Fu(P, D, C + 6);
      const I = !!P.bitFlag.languageEncodingFlag, $ = C + 46, N = $ + P.filenameLength, U = N + P.extraFieldLength, M = Ve(D, C + 4), Z = M >> 8 == 0, z = M >> 8 == 3, se = E.subarray($, N), G = Ve(D, C + 32), Q = U + G, ee = E.subarray(U, Q), V = I, fe = I, ie = je(D, C + 38), ae = Z && (ln(D, C + 38) & Uf) == Uf || z && (ie >> 16 & Wf) == Wf || se.length && se[se.length - 1] == qf.charCodeAt(0), Pe = z && (ie >> 16 & Mf) == Mf, Oe = je(D, C + 42) + _;
      Object.assign(P, {
        versionMadeBy: M,
        msDosCompatible: Z,
        compressedSize: 0,
        uncompressedSize: 0,
        commentLength: G,
        directory: ae,
        offset: Oe,
        diskNumberStart: Ve(D, C + 34),
        internalFileAttributes: Ve(D, C + 36),
        externalFileAttributes: ie,
        rawFilename: se,
        filenameUTF8: V,
        commentUTF8: fe,
        rawExtraField: E.subarray(N, U),
        executable: Pe
      }), P.internalFileAttribute = P.internalFileAttributes, P.externalFileAttribute = P.externalFileAttributes;
      const Xe = it(r, t, "decodeText") || Fs, tt = V ? lp : H || fp, St = fe ? lp : k || fp;
      let Ie = Xe(se, tt);
      Ie === lt && (Ie = Fs(se, tt));
      let De = Xe(ee, St);
      De === lt && (De = Fs(ee, St)), Object.assign(P, {
        rawComment: ee,
        filename: Ie,
        comment: De,
        directory: ae || Ie.endsWith(qf)
      }), w = Math.max(Oe, w), Bu(P, P, D, C + 6), P.zipCrypto = P.encrypted && !P.extraFieldAES;
      const ft = new ip(P);
      ft.getData = (v, u) => P.getData(v, ft, u), C = Q;
      const { onprogress: Le } = t;
      if (Le)
        try {
          await Le(S + 1, y, new ip(P));
        } catch {
        }
      yield ft;
    }
    const A = it(r, t, "extractPrependedData"), L = it(r, t, "extractAppendedData");
    return A && (r.prependedData = w > 0 ? await et(i, 0, w) : new Uint8Array()), r.comment = c ? await et(i, p + Yr, c) : new Uint8Array(), L && (r.appendedData = m < i.size ? await et(i, m, i.size - m) : new Uint8Array()), !0;
  }
  async getEntries(t = {}) {
    const r = [];
    for await (const i of this.getEntriesGenerator(t))
      r.push(i);
    return r;
  }
  async close() {
  }
}
class fw {
  constructor(t, r, i) {
    Object.assign(this, {
      reader: t,
      config: r,
      options: i
    });
  }
  async getData(t, r, i = {}) {
    const a = this, {
      reader: s,
      offset: n,
      diskNumberStart: o,
      extraFieldAES: l,
      compressionMethod: p,
      config: c,
      bitFlag: m,
      signature: h,
      rawLastModDate: g,
      uncompressedSize: R,
      compressedSize: y
    } = a, _ = r.localDirectory = {}, w = await et(s, n, 30, o), C = Ze(w);
    let E = it(a, i, "password"), D = it(a, i, "rawPassword");
    const T = it(a, i, "passThrough");
    if (E = E && E.length && E, D = D && D.length && D, l && l.originalCompressionMethod != Pg)
      throw new Error(ap);
    if (p != kg && p != Eg && !T)
      throw new Error(ap);
    if (je(C, 0) != Ag)
      throw new Error(nw);
    Fu(_, C, 4), _.rawExtraField = _.extraFieldLength ? await et(s, n + 30 + _.filenameLength, _.extraFieldLength, o) : new Uint8Array(), Bu(a, _, C, 4, !0), Object.assign(r, {
      lastAccessDate: _.lastAccessDate,
      creationDate: _.creationDate
    });
    const H = a.encrypted && _.encrypted && !T, k = H && !l;
    if (T || (r.zipCrypto = k), H) {
      if (!k && l.strength === lt)
        throw new Error(aw);
      if (!E && !D)
        throw new Error(iw);
    }
    const A = n + 30 + _.filenameLength + _.extraFieldLength, L = y, S = s.readable;
    Object.assign(S, {
      diskNumberStart: o,
      offset: A,
      size: L
    });
    const P = it(a, i, "signal"), I = it(a, i, "checkPasswordOnly");
    I && (t = new WritableStream()), t = H1(t), await ti(t, T ? y : R);
    const { writable: $ } = t, { onstart: N, onprogress: U, onend: M } = i, Z = {
      options: {
        codecType: xu,
        password: E,
        rawPassword: D,
        zipCrypto: k,
        encryptionStrength: l && l.strength,
        signed: it(a, i, "checkSignature") && !T,
        passwordVerification: k && (m.dataDescriptor ? g >>> 8 & 255 : h >>> 24 & 255),
        signature: h,
        compressed: p != 0 && !T,
        encrypted: a.encrypted && !T,
        useWebWorkers: it(a, i, "useWebWorkers"),
        useCompressionStream: it(a, i, "useCompressionStream"),
        transferStreams: it(a, i, "transferStreams"),
        checkPasswordOnly: I
      },
      config: c,
      streamOptions: { signal: P, size: L, onstart: N, onprogress: U, onend: M }
    };
    let z = 0;
    try {
      ({ outputSize: z } = await A1({ readable: S, writable: $ }, Z));
    } catch (se) {
      if (!I || se.message != ko)
        throw se;
    } finally {
      const se = it(a, i, "preventClose");
      $.size += z, !se && !$.locked && await $.getWriter().close();
    }
    return I ? lt : t.getData ? t.getData() : $;
  }
}
function Fu(e, t, r) {
  const i = e.rawBitFlag = Ve(t, r + 2), a = (i & Bf) == Bf, s = je(t, r + 6);
  Object.assign(e, {
    encrypted: a,
    version: Ve(t, r),
    bitFlag: {
      level: (i & Ng) >> 1,
      dataDescriptor: (i & Nf) == Nf,
      languageEncodingFlag: (i & jf) == jf
    },
    rawLastModDate: s,
    lastModDate: mw(s),
    filenameLength: Ve(t, r + 22),
    extraFieldLength: Ve(t, r + 24)
  });
}
function Bu(e, t, r, i, a) {
  const { rawExtraField: s } = t, n = t.extraField = /* @__PURE__ */ new Map(), o = Ze(new Uint8Array(s));
  let l = 0;
  try {
    for (; l < s.length; ) {
      const w = Ve(o, l), C = Ve(o, l + 2);
      n.set(w, {
        type: w,
        data: s.slice(l + 4, l + 4 + C)
      }), l += 4 + C;
    }
  } catch {
  }
  const p = Ve(r, i + 4);
  Object.assign(t, {
    signature: je(r, i + 10),
    uncompressedSize: je(r, i + 18),
    compressedSize: je(r, i + 14)
  });
  const c = n.get(Lg);
  c && (pw(c, t), t.extraFieldZip64 = c);
  const m = n.get(Hg);
  m && (cp(m, Tu, Ou, t, e), t.extraFieldUnicodePath = m);
  const h = n.get(Fg);
  h && (cp(h, Cu, Lu, t, e), t.extraFieldUnicodeComment = h);
  const g = n.get(Rg);
  g ? (cw(g, t, p), t.extraFieldAES = g) : t.compressionMethod = p;
  const R = n.get($g);
  R && (uw(R, t), t.extraFieldNTFS = R);
  const y = n.get(Dg);
  y && (dw(y, t, a), t.extraFieldExtendedTimestamp = y);
  const _ = n.get(Bg);
  _ && (t.extraFieldUSDZ = _);
}
function pw(e, t) {
  t.zip64 = !0;
  const r = Ze(e.data), i = ow.filter(([a, s]) => t[a] == s);
  for (let a = 0, s = 0; a < i.length; a++) {
    const [n, o] = i[a];
    if (t[n] == o) {
      const l = lw[o];
      t[n] = e[n] = l.getValue(r, s), s += l.bytes;
    } else if (e[n])
      throw new Error(sw);
  }
}
function cp(e, t, r, i, a) {
  const s = Ze(e.data), n = new Qs();
  n.append(a[r]);
  const o = Ze(new Uint8Array(4));
  o.setUint32(0, n.get(), !0);
  const l = je(s, 1);
  Object.assign(e, {
    version: ln(s, 0),
    [t]: Fs(e.data.subarray(5)),
    valid: !a.bitFlag.languageEncodingFlag && l == je(o, 0)
  }), e.valid && (i[t] = e[t], i[t + "UTF8"] = !0);
}
function cw(e, t, r) {
  const i = Ze(e.data), a = ln(i, 4);
  Object.assign(e, {
    vendorVersion: ln(i, 0),
    vendorId: ln(i, 2),
    strength: a,
    originalCompressionMethod: r,
    compressionMethod: Ve(i, 5)
  }), t.compressionMethod = e.compressionMethod;
}
function uw(e, t) {
  const r = Ze(e.data);
  let i = 4, a;
  try {
    for (; i < e.data.length && !a; ) {
      const s = Ve(r, i), n = Ve(r, i + 2);
      s == Ig && (a = e.data.slice(i + 4, i + 4 + n)), i += 4 + n;
    }
  } catch {
  }
  try {
    if (a && a.length == 24) {
      const s = Ze(a), n = s.getBigUint64(0, !0), o = s.getBigUint64(8, !0), l = s.getBigUint64(16, !0);
      Object.assign(e, {
        rawLastModDate: n,
        rawLastAccessDate: o,
        rawCreationDate: l
      });
      const p = Pa(n), c = Pa(o), m = Pa(l), h = { lastModDate: p, lastAccessDate: c, creationDate: m };
      Object.assign(e, h), Object.assign(t, h);
    }
  } catch {
  }
}
function dw(e, t, r) {
  const i = Ze(e.data), a = ln(i, 0), s = [], n = [];
  r ? ((a & 1) == 1 && (s.push(Ja), n.push(Qa)), (a & 2) == 2 && (s.push(Du), n.push(N1)), (a & 4) == 4 && (s.push(Hu), n.push(j1))) : e.data.length >= 5 && (s.push(Ja), n.push(Qa));
  let o = 1;
  s.forEach((l, p) => {
    if (e.data.length >= o + 4) {
      const c = je(i, o);
      t[l] = e[l] = new Date(c * 1e3);
      const m = n[p];
      e[m] = c;
    }
    o += 4;
  });
}
async function hw(e, t, r, i, a) {
  const s = new Uint8Array(4), n = Ze(s);
  yw(n, 0, t);
  const o = i + a;
  return await l(i) || await l(Math.min(o, r));
  async function l(p) {
    const c = r - p, m = await et(e, c, p);
    for (let h = m.length - i; h >= 0; h--)
      if (m[h] == s[0] && m[h + 1] == s[1] && m[h + 2] == s[2] && m[h + 3] == s[3])
        return {
          offset: c + h,
          buffer: m.slice(h, h + i).buffer
        };
  }
}
function it(e, t, r) {
  return t[r] === lt ? e.options[r] : t[r];
}
function mw(e) {
  const t = (e & 4294901760) >> 16, r = e & 65535;
  try {
    return new Date(1980 + ((t & 65024) >> 9), ((t & 480) >> 5) - 1, t & 31, (r & 63488) >> 11, (r & 2016) >> 5, (r & 31) * 2, 0);
  } catch {
  }
}
function Pa(e) {
  return new Date(Number(e / BigInt(1e4) - BigInt(116444736e5)));
}
function ln(e, t) {
  return e.getUint8(t);
}
function Ve(e, t) {
  return e.getUint16(t, !0);
}
function je(e, t) {
  return e.getUint32(t, !0);
}
function Bs(e, t) {
  return Number(e.getBigUint64(t, !0));
}
function yw(e, t, r) {
  e.setUint32(t, r, !0);
}
function Ze(e) {
  return new DataView(e.buffer);
}
let Nu;
try {
  Nu = import.meta.url;
} catch {
}
Eo({ baseURL: Nu });
O1(Eo);
Eo({ Deflate: rg, Inflate: Sg });
class _w {
  constructor(t) {
    this.fileTree = t;
  }
  async read(t) {
    let r = this.getEntryAtPath(t);
    if (typeof r == "string")
      r = new TextEncoder().encode(r);
    else if (!(r instanceof Uint8Array))
      throw new Error(`Unsupported content type: ${typeof r}`);
    const i = new ReadableStream({
      start(a) {
        a.enqueue(r), a.close();
      }
    });
    return new Ir(i, t, {
      filesize: r.byteLength
    });
  }
  getEntryAtPath(t) {
    let r = t.replace(/^\//, ""), i = this.fileTree;
    for (; r; ) {
      if (i[r])
        return i[r];
      const a = r.split("/"), s = a.shift();
      if (!s || !i[s])
        break;
      i = i[s], r = a.join("/");
    }
    throw new Error(`File not found at ${t}`);
  }
}
class ri {
  constructor(t) {
    this.entries = /* @__PURE__ */ new Map(), this.zipReader = t;
  }
  static fromStream(t) {
    const r = new pp(
      new Ya(new Ir(t, "archive.zip"))
    );
    return new ri(r);
  }
  static fromArrayBuffer(t) {
    const r = new pp(
      new Ya(new Blob([t]))
    );
    return new ri(r);
  }
  async read(t) {
    const r = await this.getEntry(t), i = await r.getData(new $1());
    return new Ir(i.stream(), t, {
      filesize: r.uncompressedSize
    });
  }
  async getEntry(t) {
    const i = (await this.getEntries()).get(t.replace(/^\//, ""));
    if (!i)
      throw new Error(`File ${t} not found in the zip.`);
    return i;
  }
  async getEntries() {
    if (this.entries.size === 0) {
      const t = await this.zipReader.getEntries();
      for (const r of t)
        this.entries.set(r.filename, r);
    }
    return this.entries;
  }
}
class gw {
  /**
   * Creates a new OverlayFilesystem.
   *
   * @param filesystems An array of Filesystem instances to cascade through.
   *                    The order determines the priority - earlier filesystems
   *                    are checked first.
   */
  constructor(t) {
    if (!t.length)
      throw new Error(
        "OverlayFilesystem requires at least one filesystem"
      );
    this.filesystems = t;
  }
  /**
   * Reads a file by trying each filesystem in order until one succeeds.
   *
   * @param path The path to the file to read.
   * @returns A Promise that resolves to a StreamedFile from the first
   *          filesystem that successfully resolves the path.
   * @throws Error if all filesystems fail to resolve the path.
   */
  async read(t) {
    const r = [];
    for (const a of this.filesystems)
      try {
        return await a.read(t);
      } catch (s) {
        r.push(
          s instanceof Error ? s : new Error(String(s))
        );
      }
    const i = r.map((a) => a.message).join("; ");
    throw new Error(
      `Failed to read ${t} from any filesystem: ${i}`,
      { cause: r }
    );
  }
}
class ww {
  constructor(t) {
    if (this.baseUrl = "", this.options = t, this.isDataUrl = t.baseUrl.startsWith("data:"), this.isDataUrl)
      return;
    const r = new URL("./", t.baseUrl);
    if (r.protocol !== "http:" && r.protocol !== "https:")
      throw new Error(
        "Unsupported protocol: " + r.protocol + ". Only HTTP and HTTPS are supported."
      );
    this.baseUrl = r.origin + r.pathname;
  }
  async read(t) {
    if (this.isDataUrl)
      throw new Error(
        "FetchFilesystem cannot fetch files from data URLs"
      );
    t = ii(t);
    const r = t.replace(/^\//, ""), i = new URL(r, this.baseUrl).toString();
    if (!i.startsWith(this.baseUrl))
      throw new Error(
        `Refused to read a file outside of the base URL: ${i}`
      );
    const a = this.options.corsProxy ? `${this.options.corsProxy}${encodeURIComponent(i)}` : i, s = await fetch(a);
    if (!s.ok)
      throw new Error(
        `Failed to fetch file at ${t}: ${s.statusText}`
      );
    const n = s.headers.get("content-length") ? parseInt(s.headers.get("content-length"), 10) : void 0;
    return new Ir(s.body, t, { filesize: n });
  }
}
function gi(e) {
  const t = e.split(".").shift().replace(/-/g, " ");
  return t.charAt(0).toUpperCase() + t.slice(1).toLowerCase();
}
function or(e) {
  return Object.fromEntries(Object.entries(e).map(([t, r]) => [r, t]));
}
const bw = {
  server_name: 0,
  max_fragment_length: 1,
  client_certificate_url: 2,
  trusted_ca_keys: 3,
  truncated_hmac: 4,
  status_request: 5,
  user_mapping: 6,
  client_authz: 7,
  server_authz: 8,
  cert_type: 9,
  supported_groups: 10,
  ec_point_formats: 11,
  srp: 12,
  signature_algorithms: 13,
  use_srtp: 14,
  heartbeat: 15,
  application_layer_protocol_negotiation: 16,
  status_request_v2: 17,
  signed_certificate_timestamp: 18,
  client_certificate_type: 19,
  server_certificate_type: 20,
  padding: 21,
  encrypt_then_mac: 22,
  extended_master_secret: 23,
  token_binding: 24,
  cached_info: 25,
  tls_its: 26,
  compress_certificate: 27,
  record_size_limit: 28,
  pwd_protect: 29,
  pwo_clear: 30,
  password_salt: 31,
  ticket_pinning: 32,
  tls_cert_with_extern_psk: 33,
  delegated_credential: 34,
  session_ticket: 35,
  TLMSP: 36,
  TLMSP_proxying: 37,
  TLMSP_delegate: 38,
  supported_ekt_ciphers: 39,
  pre_shared_key: 41,
  early_data: 42,
  supported_versions: 43,
  cookie: 44,
  psk_key_exchange_modes: 45,
  reserved: 46,
  certificate_authorities: 47,
  oid_filters: 48,
  post_handshake_auth: 49,
  signature_algorithms_cert: 50,
  key_share: 51,
  transparency_info: 52,
  connection_id: 54
};
or(bw);
const vw = {
  host_name: 0
};
or(vw);
const xw = {
  TLS1_CK_PSK_WITH_RC4_128_SHA: 138,
  TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA: 139,
  TLS1_CK_PSK_WITH_AES_128_CBC_SHA: 140,
  TLS1_CK_PSK_WITH_AES_256_CBC_SHA: 141,
  TLS1_CK_DHE_PSK_WITH_RC4_128_SHA: 142,
  TLS1_CK_DHE_PSK_WITH_3DES_EDE_CBC_SHA: 143,
  TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA: 144,
  TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA: 145,
  TLS1_CK_RSA_PSK_WITH_RC4_128_SHA: 146,
  TLS1_CK_RSA_PSK_WITH_3DES_EDE_CBC_SHA: 147,
  TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA: 148,
  TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA: 149,
  TLS1_CK_PSK_WITH_AES_128_GCM_SHA256: 168,
  TLS1_CK_PSK_WITH_AES_256_GCM_SHA384: 169,
  TLS1_CK_DHE_PSK_WITH_AES_128_GCM_SHA256: 170,
  TLS1_CK_DHE_PSK_WITH_AES_256_GCM_SHA384: 171,
  TLS1_CK_RSA_PSK_WITH_AES_128_GCM_SHA256: 172,
  TLS1_CK_RSA_PSK_WITH_AES_256_GCM_SHA384: 173,
  TLS1_CK_PSK_WITH_AES_128_CBC_SHA256: 174,
  TLS1_CK_PSK_WITH_AES_256_CBC_SHA384: 175,
  TLS1_CK_PSK_WITH_NULL_SHA256: 176,
  TLS1_CK_PSK_WITH_NULL_SHA384: 177,
  TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA256: 178,
  TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA384: 179,
  TLS1_CK_DHE_PSK_WITH_NULL_SHA256: 180,
  TLS1_CK_DHE_PSK_WITH_NULL_SHA384: 181,
  TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA256: 182,
  TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA384: 183,
  TLS1_CK_RSA_PSK_WITH_NULL_SHA256: 184,
  TLS1_CK_RSA_PSK_WITH_NULL_SHA384: 185,
  TLS1_CK_PSK_WITH_NULL_SHA: 44,
  TLS1_CK_DHE_PSK_WITH_NULL_SHA: 45,
  TLS1_CK_RSA_PSK_WITH_NULL_SHA: 46,
  TLS1_CK_RSA_WITH_AES_128_SHA: 47,
  TLS1_CK_DH_DSS_WITH_AES_128_SHA: 48,
  TLS1_CK_DH_RSA_WITH_AES_128_SHA: 49,
  TLS1_CK_DHE_DSS_WITH_AES_128_SHA: 50,
  TLS1_CK_DHE_RSA_WITH_AES_128_SHA: 51,
  TLS1_CK_ADH_WITH_AES_128_SHA: 52,
  TLS1_CK_RSA_WITH_AES_256_SHA: 53,
  TLS1_CK_DH_DSS_WITH_AES_256_SHA: 54,
  TLS1_CK_DH_RSA_WITH_AES_256_SHA: 55,
  TLS1_CK_DHE_DSS_WITH_AES_256_SHA: 56,
  TLS1_CK_DHE_RSA_WITH_AES_256_SHA: 57,
  TLS1_CK_ADH_WITH_AES_256_SHA: 58,
  TLS1_CK_RSA_WITH_NULL_SHA256: 59,
  TLS1_CK_RSA_WITH_AES_128_SHA256: 60,
  TLS1_CK_RSA_WITH_AES_256_SHA256: 61,
  TLS1_CK_DH_DSS_WITH_AES_128_SHA256: 62,
  TLS1_CK_DH_RSA_WITH_AES_128_SHA256: 63,
  TLS1_CK_DHE_DSS_WITH_AES_128_SHA256: 64,
  TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA: 65,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: 66,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: 67,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: 68,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: 69,
  TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA: 70,
  TLS1_CK_DHE_RSA_WITH_AES_128_SHA256: 103,
  TLS1_CK_DH_DSS_WITH_AES_256_SHA256: 104,
  TLS1_CK_DH_RSA_WITH_AES_256_SHA256: 105,
  TLS1_CK_DHE_DSS_WITH_AES_256_SHA256: 106,
  TLS1_CK_DHE_RSA_WITH_AES_256_SHA256: 107,
  TLS1_CK_ADH_WITH_AES_128_SHA256: 108,
  TLS1_CK_ADH_WITH_AES_256_SHA256: 109,
  TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA: 132,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: 133,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: 134,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: 135,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: 136,
  TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA: 137,
  TLS1_CK_RSA_WITH_SEED_SHA: 150,
  TLS1_CK_DH_DSS_WITH_SEED_SHA: 151,
  TLS1_CK_DH_RSA_WITH_SEED_SHA: 152,
  TLS1_CK_DHE_DSS_WITH_SEED_SHA: 153,
  TLS1_CK_DHE_RSA_WITH_SEED_SHA: 154,
  TLS1_CK_ADH_WITH_SEED_SHA: 155,
  TLS1_CK_RSA_WITH_AES_128_GCM_SHA256: 156,
  TLS1_CK_RSA_WITH_AES_256_GCM_SHA384: 157,
  TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256: 158,
  TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384: 159,
  TLS1_CK_DH_RSA_WITH_AES_128_GCM_SHA256: 160,
  TLS1_CK_DH_RSA_WITH_AES_256_GCM_SHA384: 161,
  TLS1_CK_DHE_DSS_WITH_AES_128_GCM_SHA256: 162,
  TLS1_CK_DHE_DSS_WITH_AES_256_GCM_SHA384: 163,
  TLS1_CK_DH_DSS_WITH_AES_128_GCM_SHA256: 164,
  TLS1_CK_DH_DSS_WITH_AES_256_GCM_SHA384: 165,
  TLS1_CK_ADH_WITH_AES_128_GCM_SHA256: 166,
  TLS1_CK_ADH_WITH_AES_256_GCM_SHA384: 167,
  TLS1_CK_RSA_WITH_AES_128_CCM: 49308,
  TLS1_CK_RSA_WITH_AES_256_CCM: 49309,
  TLS1_CK_DHE_RSA_WITH_AES_128_CCM: 49310,
  TLS1_CK_DHE_RSA_WITH_AES_256_CCM: 49311,
  TLS1_CK_RSA_WITH_AES_128_CCM_8: 49312,
  TLS1_CK_RSA_WITH_AES_256_CCM_8: 49313,
  TLS1_CK_DHE_RSA_WITH_AES_128_CCM_8: 49314,
  TLS1_CK_DHE_RSA_WITH_AES_256_CCM_8: 49315,
  TLS1_CK_PSK_WITH_AES_128_CCM: 49316,
  TLS1_CK_PSK_WITH_AES_256_CCM: 49317,
  TLS1_CK_DHE_PSK_WITH_AES_128_CCM: 49318,
  TLS1_CK_DHE_PSK_WITH_AES_256_CCM: 49319,
  TLS1_CK_PSK_WITH_AES_128_CCM_8: 49320,
  TLS1_CK_PSK_WITH_AES_256_CCM_8: 49321,
  TLS1_CK_DHE_PSK_WITH_AES_128_CCM_8: 49322,
  TLS1_CK_DHE_PSK_WITH_AES_256_CCM_8: 49323,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM: 49324,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM: 49325,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM_8: 49326,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM_8: 49327,
  TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA256: 186,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256: 187,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256: 188,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: 189,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: 190,
  TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA256: 191,
  TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA256: 192,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256: 193,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256: 194,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: 195,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: 196,
  TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA256: 197,
  TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA: 49153,
  TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA: 49154,
  TLS1_CK_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: 49155,
  TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA: 49156,
  TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA: 49157,
  TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA: 49158,
  TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA: 49159,
  TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: 49160,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: 49161,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: 49162,
  TLS1_CK_ECDH_RSA_WITH_NULL_SHA: 49163,
  TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA: 49164,
  TLS1_CK_ECDH_RSA_WITH_DES_192_CBC3_SHA: 49165,
  TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA: 49166,
  TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA: 49167,
  TLS1_CK_ECDHE_RSA_WITH_NULL_SHA: 49168,
  TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA: 49169,
  TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA: 49170,
  TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA: 49171,
  TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA: 49172,
  TLS1_CK_ECDH_anon_WITH_NULL_SHA: 49173,
  TLS1_CK_ECDH_anon_WITH_RC4_128_SHA: 49174,
  TLS1_CK_ECDH_anon_WITH_DES_192_CBC3_SHA: 49175,
  TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA: 49176,
  TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA: 49177,
  TLS1_CK_SRP_SHA_WITH_3DES_EDE_CBC_SHA: 49178,
  TLS1_CK_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: 49179,
  TLS1_CK_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: 49180,
  TLS1_CK_SRP_SHA_WITH_AES_128_CBC_SHA: 49181,
  TLS1_CK_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: 49182,
  TLS1_CK_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: 49183,
  TLS1_CK_SRP_SHA_WITH_AES_256_CBC_SHA: 49184,
  TLS1_CK_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: 49185,
  TLS1_CK_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: 49186,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256: 49187,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384: 49188,
  TLS1_CK_ECDH_ECDSA_WITH_AES_128_SHA256: 49189,
  TLS1_CK_ECDH_ECDSA_WITH_AES_256_SHA384: 49190,
  TLS1_CK_ECDHE_RSA_WITH_AES_128_SHA256: 49191,
  TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384: 49192,
  TLS1_CK_ECDH_RSA_WITH_AES_128_SHA256: 49193,
  TLS1_CK_ECDH_RSA_WITH_AES_256_SHA384: 49194,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: 49195,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: 49196,
  TLS1_CK_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: 49197,
  TLS1_CK_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: 49198,
  TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256: 49199,
  TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384: 49200,
  TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256: 49201,
  TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384: 49202,
  TLS1_CK_ECDHE_PSK_WITH_RC4_128_SHA: 49203,
  TLS1_CK_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: 49204,
  TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA: 49205,
  TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA: 49206,
  TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA256: 49207,
  TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA384: 49208,
  TLS1_CK_ECDHE_PSK_WITH_NULL_SHA: 49209,
  TLS1_CK_ECDHE_PSK_WITH_NULL_SHA256: 49210,
  TLS1_CK_ECDHE_PSK_WITH_NULL_SHA384: 49211,
  TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: 49266,
  TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: 49267,
  TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: 49268,
  TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: 49269,
  TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: 49270,
  TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: 49271,
  TLS1_CK_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: 49272,
  TLS1_CK_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: 49273,
  TLS1_CK_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49300,
  TLS1_CK_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49301,
  TLS1_CK_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49302,
  TLS1_CK_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49303,
  TLS1_CK_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49304,
  TLS1_CK_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49305,
  TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49306,
  TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49307,
  TLS1_CK_ECDHE_RSA_WITH_CHACHA20_POLY1305: 52392,
  TLS1_CK_ECDHE_ECDSA_WITH_CHACHA20_POLY1305: 52393,
  TLS1_CK_DHE_RSA_WITH_CHACHA20_POLY1305: 52394,
  TLS1_CK_PSK_WITH_CHACHA20_POLY1305: 52395,
  TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305: 52396,
  TLS1_CK_DHE_PSK_WITH_CHACHA20_POLY1305: 52397,
  TLS1_CK_RSA_PSK_WITH_CHACHA20_POLY1305: 52398
};
or(xw);
const Sw = {
  secp256r1: 23,
  secp384r1: 24,
  secp521r1: 25,
  x25519: 29,
  x448: 30
};
or(Sw);
const Ew = {
  uncompressed: 0,
  ansiX962_compressed_prime: 1,
  ansiX962_compressed_char2: 2
};
or(Ew);
const kw = {
  anonymous: 0,
  rsa: 1,
  dsa: 2,
  ecdsa: 3
};
or(kw);
const Pw = {
  none: 0,
  md5: 1,
  sha1: 2,
  sha224: 3,
  sha256: 4,
  sha384: 5,
  sha512: 6
};
or(Pw);
const Aw = {
  Warning: 1,
  Fatal: 2
};
or(Aw);
const Tw = {
  CloseNotify: 0,
  UnexpectedMessage: 10,
  BadRecordMac: 20,
  DecryptionFailed: 21,
  RecordOverflow: 22,
  DecompressionFailure: 30,
  HandshakeFailure: 40,
  NoCertificate: 41,
  BadCertificate: 42,
  UnsupportedCertificate: 43,
  CertificateRevoked: 44,
  CertificateExpired: 45,
  CertificateUnknown: 46,
  IllegalParameter: 47,
  UnknownCa: 48,
  AccessDenied: 49,
  DecodeError: 50,
  DecryptError: 51,
  ExportRestriction: 60,
  ProtocolVersion: 70,
  InsufficientSecurity: 71,
  InternalError: 80,
  UserCanceled: 90,
  NoRenegotiation: 100,
  UnsupportedExtension: 110
};
or(Tw);
crypto.subtle.generateKey(
  {
    name: "ECDH",
    namedCurve: "P-256"
    // Use secp256r1 curve
  },
  !0,
  // Extractable
  ["deriveKey", "deriveBits"]
  // Key usage
);
async function ni(e, t) {
  let r;
  return ["GET", "HEAD"].includes(e.method) || "body" in t ? r = void 0 : !e.bodyUsed && e.body ? r = e.body : r = await e.blob(), new Request(t.url || e.url, {
    body: r,
    method: e.method,
    headers: e.headers,
    referrer: e.referrer,
    referrerPolicy: e.referrerPolicy,
    mode: e.mode === "navigate" ? "same-origin" : e.mode,
    credentials: e.credentials,
    cache: e.cache,
    redirect: e.redirect,
    integrity: e.integrity,
    ...r && { duplex: "half" },
    ...t
  });
}
async function Ow(e) {
  if (!e.body)
    return [e, e];
  const [t, r] = e.body.tee();
  return [
    await ni(e, { body: t, duplex: "half" }),
    await ni(e, { body: r, duplex: "half" })
  ];
}
async function Cw(e, t, r, i) {
  var p;
  let a = typeof e == "string" ? new Request(e, t) : e;
  const s = i ? new URL(i) : null;
  let n = s ? new URL(a.url, s) : new URL(a.url);
  if (n.protocol === "http:") {
    n.protocol = "https:";
    const c = n.toString();
    a = await ni(a, { url: c }), n = new URL(c);
  }
  if (!r)
    return await fetch(a);
  if (s && n.protocol === s.protocol && n.hostname === s.hostname && n.port === s.port && n.pathname.startsWith(s.pathname))
    return await fetch(a);
  const [o, l] = await Ow(a);
  try {
    return await fetch(o);
  } catch {
    const m = ((p = new Headers(l.headers).get("x-cors-proxy-allowed-request-headers")) == null ? void 0 : p.split(",")) || [], h = m.includes("authorization") || m.includes("cookie"), g = await ni(l, {
      url: `${r}${a.url}`,
      ...h && { credentials: "include" }
    });
    return await fetch(g, t);
  }
}
class fv extends TransformStream {
  constructor() {
    let t = new Uint8Array(0), r = "SCAN_CHUNK_SIZE", i = 0;
    super({
      transform(a, s) {
        for (t = vd([t, a]); t.length > 0; )
          if (r === "SCAN_CHUNK_SIZE") {
            if (t.length < 3)
              return;
            let n = 0;
            for (; n < t.length; ) {
              const p = t[n];
              if (!(p >= 48 && p <= 57 || // 0-9
              p >= 97 && p <= 102 || // a-f
              p >= 65 && p <= 70)) break;
              n++;
            }
            if (n === 0)
              throw new Error("Invalid chunk size format");
            if (t.length < n + 2)
              return;
            if (t[n] !== 13 || // \r
            t[n + 1] !== 10)
              throw new Error(
                "Invalid chunk size format. Expected CRLF after chunk size"
              );
            const o = new TextDecoder().decode(
              t.slice(0, n)
            ), l = parseInt(o, 16);
            if (t = t.slice(n + 2), l === 0) {
              r = "SCAN_FINAL_CHUNK", s.terminate();
              return;
            }
            i = l, r = "SCAN_CHUNK_DATA";
          } else if (r === "SCAN_CHUNK_DATA") {
            const n = Math.min(
              i,
              t.length
            ), o = t.slice(0, n);
            t = t.slice(n), i -= n, s.enqueue(o), i === 0 && (r = "SCAN_CHUNK_TRAILER");
          } else if (r === "SCAN_CHUNK_TRAILER") {
            if (t.length < 2)
              return;
            if (t[0] !== 13 || t[1] !== 10)
              throw new Error(
                "Invalid chunk trailer format. Expected CRLF after chunk data"
              );
            t = t.slice(2), r = "SCAN_CHUNK_SIZE";
          }
      }
    });
  }
}
const Lw = "8.3", ju = async (e, t, r, i = !0) => {
  const a = `/tmp/file-${Math.random()}.zip`;
  if (t instanceof File) {
    const n = t;
    t = a, await e.writeFile(
      t,
      new Uint8Array(await n.arrayBuffer())
    );
  }
  const s = ai({
    zipPath: t,
    extractToPath: r,
    overwriteFiles: i
  });
  await e.run({
    code: `<?php
        function unzip($zipPath, $extractTo, $overwriteFiles = true)
        {
            if (!is_dir($extractTo)) {
                mkdir($extractTo, 0777, true);
            }
            $zip = new ZipArchive;
            $res = $zip->open($zipPath);
            if ($res === TRUE) {
				for ($i = 0; $i < $zip->numFiles; $i++) {
					$filename = $zip->getNameIndex($i);
					$fileinfo = pathinfo($filename);
					$extractFilePath = rtrim($extractTo, '/') . '/' . $filename;
					// Check if file exists and $overwriteFiles is false
					if (!file_exists($extractFilePath) || $overwriteFiles) {
						// Extract file
						$zip->extractTo($extractTo, $filename);
					}
				}
				$zip->close();
				chmod($extractTo, 0777);
            } else {
                $fileSize = file_exists($zipPath) ? filesize($zipPath) : 'unknown';
                throw new Exception("Could not unzip file. Error code: " . $res . ". File size: " . $fileSize . " bytes.");
            }
        }
        unzip(${s.zipPath}, ${s.extractToPath}, ${s.overwriteFiles});
        `
  }), await e.fileExists(a) && await e.unlink(a);
};
new cn({ concurrency: 15 });
const Rw = `Blueprint resource of type "bundled" requires a filesystem.

This Blueprint refers to files that should be bundled with it (like images, plugins, or themes), but the filesystem needed to access these files is not available. This usually happens when:

1. You're trying to load a Blueprint as a standalone JSON file that was meant to be part of a bundle
2. The Blueprint was not packaged correctly as a blueprint.zip file

To fix this:
â€¢ If you're loading from a URL, make sure all referenced files are accessible relative to the Blueprint file
â€¢ If you're using a blueprint.zip file, ensure it contains all the files referenced in the Blueprint
â€¢ Check that the "resource": "bundled" references in your Blueprint match actual files in your bundle

Learn more about Blueprint resources: https://wordpress.github.io/wordpress-playground/blueprints/data-format#resources`;
class $w extends Error {
  constructor(t = Rw) {
    super(t), this.name = "BlueprintFilesystemRequiredError";
  }
}
const Iw = [
  "vfs",
  "literal",
  "wordpress.org/themes",
  "wordpress.org/plugins",
  "url",
  "git:directory",
  "bundled"
];
function Dw(e) {
  return e && typeof e == "object" && typeof e.resource == "string" && Iw.includes(e.resource);
}
class Jt {
  get progress() {
    return this._progress;
  }
  set progress(t) {
    this._progress = t;
  }
  setPlayground(t) {
    this.playground = t;
  }
  /** Whether this Resource is loaded asynchronously */
  get isAsync() {
    return !1;
  }
  /**
   * Creates a new Resource based on the given file reference
   *
   * @param ref The file reference to create the Resource for
   * @param options Additional options for the Resource
   * @returns A new Resource instance
   */
  static create(t, {
    semaphore: r,
    progress: i,
    corsProxy: a,
    streamBundledFile: s,
    gitAdditionalHeadersCallback: n
  }) {
    let o;
    switch (t.resource) {
      case "vfs":
        o = new Hw(t, i);
        break;
      case "literal":
        o = new Fw(t, i);
        break;
      case "wordpress.org/themes":
        o = new qw(t, i);
        break;
      case "wordpress.org/plugins":
        o = new Kw(t, i);
        break;
      case "url":
        o = new jw(t, i, { corsProxy: a });
        break;
      case "git:directory":
        o = new Uw(t, i, {
          corsProxy: a,
          additionalHeaders: n
        });
        break;
      case "literal:directory":
        o = new Mw(t, i);
        break;
      case "bundled":
        if (!s)
          throw new $w();
        o = new Vw(
          t,
          s,
          i
        );
        break;
      default:
        throw new Error(
          `Unknown resource type: ${t.resource}`
        );
    }
    return r && (o = new Gw(o, r)), new zw(o);
  }
}
class Uu extends Jt {
  constructor(t) {
    super(), this.resource = t;
  }
  /** @inheritDoc */
  get progress() {
    return this.resource.progress;
  }
  /** @inheritDoc */
  set progress(t) {
    this.resource.progress = t;
  }
  /** @inheritDoc */
  get name() {
    return this.resource.name;
  }
  /** @inheritDoc */
  get isAsync() {
    return this.resource.isAsync;
  }
  /** @inheritDoc */
  setPlayground(t) {
    this.resource.setPlayground(t);
  }
}
class Hw extends Jt {
  /**
   * Creates a new instance of `VFSResource`.
   * @param playground The playground client.
   * @param resource The VFS reference.
   * @param progress The progress tracker.
   */
  constructor(t, r) {
    super(), this.resource = t, this._progress = r;
  }
  /** @inheritDoc */
  async resolve() {
    var r;
    const t = await this.playground.readFileAsBuffer(
      this.resource.path
    );
    return (r = this.progress) == null || r.set(100), new File([t], this.name);
  }
  /** @inheritDoc */
  get name() {
    return this.resource.path.split("/").pop() || "";
  }
}
class Fw extends Jt {
  /**
   * Creates a new instance of `LiteralResource`.
   * @param resource The literal reference.
   * @param progress The progress tracker.
   */
  constructor(t, r) {
    super(), this.resource = t, this._progress = r;
  }
  /** @inheritDoc */
  async resolve() {
    var t;
    return (t = this.progress) == null || t.set(100), new File([this.resource.contents], this.resource.name);
  }
  /** @inheritDoc */
  get name() {
    return this.resource.name;
  }
}
class Oo extends Jt {
  /**
   * Creates a new instance of `FetchResource`.
   * @param progress The progress tracker.
   */
  constructor(t, r) {
    super(), this._progress = t, this.corsProxy = r;
  }
  /** @inheritDoc */
  async resolve() {
    var r, i, a;
    (r = this.progress) == null || r.setCaption(this.caption);
    const t = this.getURL();
    try {
      let s = await Cw(
        t,
        void 0,
        this.corsProxy,
        await ((i = this.playground) == null ? void 0 : i.absoluteUrl)
      );
      if (!s.ok)
        throw new Error(`Could not download "${t}"`);
      if (s = await hd(
        s,
        ((a = this.progress) == null ? void 0 : a.loadingListener) ?? Nw
      ), s.status !== 200)
        throw new Error(`Could not download "${t}"`);
      const n = this.name || Bw(
        s.headers.get("content-disposition") || ""
      ) || encodeURIComponent(t);
      return new File([await s.blob()], n);
    } catch (s) {
      throw new Error(
        `Could not download "${t}".

Confirm that the URL is correct, the server is reachable, and the file isactually served at that URL. Original error: 
 ${s}`
      );
    }
  }
  /**
   * Gets the caption for the progress tracker.
   * @returns The caption.
   */
  get caption() {
    return `Downloading ${this.name}`;
  }
  /** @inheritDoc */
  get name() {
    try {
      return new URL(this.getURL(), "http://example.com").pathname.split("/").pop();
    } catch {
      return this.getURL();
    }
  }
  /** @inheritDoc */
  get isAsync() {
    return !0;
  }
}
function Bw(e) {
  if (!e)
    return null;
  const t = e.match(/filename\*?=([^;]+)/i);
  if (!t)
    return null;
  let r = t[1].trim();
  if ((r.startsWith('"') && r.endsWith('"') || r.startsWith("'") && r.endsWith("'")) && (r = r.slice(1, -1)), t[0].includes("filename*")) {
    const i = r.match(/^[^']*'[^']*'(.+)$/);
    if (i)
      try {
        r = decodeURIComponent(i[1]);
      } catch {
      }
  }
  return r;
}
const Nw = () => {
};
class jw extends Oo {
  /**
   * Creates a new instance of `UrlResource`.
   * @param resource The URL reference.
   * @param progress The progress tracker.
   */
  constructor(t, r, i) {
    if (super(r, i == null ? void 0 : i.corsProxy), this.resource = t, this.options = i, this.resource.url.startsWith("https://github.com/")) {
      const a = this.resource.url.match(
        /^https:\/\/github\.com\/(?<owner>[^/]+)\/(?<repo>[^/]+)\/(?:blob|raw)\/(?<branch>[^/]+)\/(?<path>.+[^/])$/
      );
      a != null && a.groups && (this.resource = {
        ...this.resource,
        url: `https://raw.githubusercontent.com/${a.groups.owner}/${a.groups.repo}/${a.groups.branch}/${a.groups.path}`
      });
    }
  }
  /** @inheritDoc */
  getURL() {
    return this.resource.url;
  }
  /** @inheritDoc */
  get caption() {
    return this.resource.caption ?? super.caption;
  }
}
class Uw extends Jt {
  constructor(t, r, i) {
    super(), this.reference = t, this._progress = r, this.options = i;
  }
  async resolve() {
    var i, a, s;
    const t = ((a = (i = this.options) == null ? void 0 : i.additionalHeaders) == null ? void 0 : a.call(i, this.reference.url)) ?? {}, r = (s = this.options) != null && s.corsProxy ? `${this.options.corsProxy}${this.reference.url}` : this.reference.url;
    try {
      const n = await P_(
        r,
        {
          value: this.reference.ref,
          type: this.reference.refType ?? "infer"
        },
        t
      ), o = await k_(
        r,
        n,
        t
      ), l = (this.reference.path ?? "").replace(
        /^\/+/,
        ""
      ), p = N_(o, l), c = await S_(
        r,
        n,
        p,
        {
          withObjects: this.reference[".git"],
          additionalHeaders: t
        }
      );
      let m = c.files;
      return m = Ww(
        m,
        (h) => h.substring(l.length).replace(/^\/+/, "")
      ), this.reference[".git"] && (m = {
        ...await B_({
          repoUrl: this.reference.url,
          commitHash: n,
          ref: this.reference.ref,
          refType: this.reference.refType,
          objects: c.objects ?? [],
          fileOids: c.fileOids ?? {},
          pathPrefix: l
        }),
        ...m
      }), {
        name: this.filename,
        files: m
      };
    } catch (n) {
      throw n instanceof Un ? new Un(
        this.reference.url,
        n.status
      ) : n;
    }
  }
  /**
   * Generate a nice, non-empty filename â€“ the installPlugin step depends on it.
   */
  get filename() {
    return this.name.replaceAll(/[^a-zA-Z0-9-.]/g, "-").replaceAll(/-+/g, "-").replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, "") || js();
  }
  /** @inheritDoc */
  get name() {
    var t;
    return [
      this.reference.url,
      this.reference.ref ? `(${this.reference.ref})` : "",
      (t = this.reference.path) != null && t.replace(/^\/+/, "") ? `at ${this.reference.path}` : ""
    ].filter((r) => r.length > 0).join(" ");
  }
}
function Ww(e, t) {
  return Object.fromEntries(
    Object.entries(e).map(([r, i]) => [t(r), i])
  );
}
class Mw extends Jt {
  constructor(t, r) {
    super(), this.reference = t, this._progress = r;
  }
  async resolve() {
    return this.reference;
  }
  /** @inheritDoc */
  get name() {
    return this.reference.name;
  }
}
class qw extends Oo {
  constructor(t, r) {
    super(r), this.resource = t;
  }
  get name() {
    return gi(this.resource.slug);
  }
  getURL() {
    return `https://downloads.wordpress.org/theme/${Wu(this.resource.slug)}`;
  }
}
class Kw extends Oo {
  constructor(t, r) {
    super(r), this.resource = t;
  }
  /** @inheritDoc */
  get name() {
    return gi(this.resource.slug);
  }
  /** @inheritDoc */
  getURL() {
    return `https://downloads.wordpress.org/plugin/${Wu(this.resource.slug)}`;
  }
}
function Wu(e) {
  return !e || e.endsWith(".zip") ? e : e + ".latest-stable.zip";
}
class zw extends Uu {
  /** @inheritDoc */
  async resolve() {
    return this.promise || (this.promise = this.resource.resolve()), this.promise;
  }
}
class Gw extends Uu {
  constructor(t, r) {
    super(t), this.semaphore = r;
  }
  /** @inheritDoc */
  async resolve() {
    return this.isAsync ? this.semaphore.run(() => this.resource.resolve()) : this.resource.resolve();
  }
}
class Vw extends Jt {
  /**
   * Creates a new instance of `BlueprintResource`.
   * @param resource The blueprint reference.
   * @param filesystem The filesystem to read from.
   * @param progress The progress tracker.
   */
  constructor(t, r, i) {
    if (!r)
      throw new Error(
        `You are trying to run a Blueprint that refers to a bundled file ("blueprint" resource type), but you did not provide the rest of the bundle. This Blueprint won't work as a standalone JSON file. You'll need to load the entire bundle, e.g. a blueprint.zip file. Alternatively, you may try loading it directly from a URL or a local directory and Playground will try (with your permission) to source the missing files from paths relative to the blueprint file.`
      );
    super(), this.resource = t, this.streamBundledFile = r, this._progress = i;
  }
  /** @inheritDoc */
  async resolve() {
    var t, r, i;
    (t = this.progress) == null || t.set(0);
    try {
      const a = await this.streamBundledFile(this.resource.path), s = a.filesize;
      if (!s)
        return (r = this.progress) == null || r.set(100), a;
      const n = bp(
        a.stream(),
        s,
        (o) => {
          var l;
          (l = this.progress) == null || l.set(
            o.detail.loaded / o.detail.total * 100
          );
        }
      );
      return new Ir(n, this.name, {
        filesize: s
      });
    } catch (a) {
      throw (i = this.progress) == null || i.set(100), new Error(
        `Failed to read file from blueprint. This Blueprint refers to a resource of type "bundled" with path "${this.resource.path}" that was not available. Please ensure that the entire bundle, such as a blueprint.zip file, is loaded. If you are trying to load the Blueprint directly from a URL or a local directory, make sure that all the necessary files are accessible and located relative to the blueprint file. 

Error details: ${a instanceof Error ? a.message : String(a)}`,
        { cause: a }
      );
    }
  }
  /** @inheritDoc */
  get name() {
    return this.resource.path.split("/").pop() || "";
  }
  /** @inheritDoc */
  get isAsync() {
    return !0;
  }
}
const Mu = async (e, { pluginPath: t, pluginName: r }, i) => {
  i == null || i.tracker.setCaption(`Activating ${r || t}`);
  const a = await e.documentRoot, s = await e.run({
    code: `<?php
			define( 'WP_ADMIN', true );
			require_once( getenv('DOCROOT') . "/wp-load.php" );
			require_once( getenv('DOCROOT') . "/wp-admin/includes/plugin.php" );

			// Set current user to admin
			wp_set_current_user( get_users(array('role' => 'Administrator') )[0]->ID );

			$plugin_path = getenv('PLUGIN_PATH');
			$response = false;
			if ( ! is_dir( $plugin_path)) {
				$response = activate_plugin($plugin_path);
			}

			// Activate plugin by name if activation by path wasn't successful
			if ( null !== $response ) {
				foreach ( ( glob( $plugin_path . '/*.php' ) ?: array() ) as $file ) {
					$info = get_plugin_data( $file, false, false );
					if ( ! empty( $info['Name'] ) ) {
						$response = activate_plugin( $file );
						break;
					}
				}
			}

			if ( is_wp_error($response) ) {
				die( $response->get_error_message() );
			} else if ( false === $response ) {
				die( "The activatePlugin step wasn't able to find the plugin $plugin_path." );
			}
		`,
    env: {
      PLUGIN_PATH: t,
      DOCROOT: a
    }
  });
  s.text && Te.warn(
    `Plugin ${t} activation printed the following bytes: ${s.text}`
  );
  const o = ((await e.run({
    code: `<?php
			ob_start();
			require_once( getenv( 'DOCROOT' ) . "/wp-load.php" );

			$plugin_directory = rtrim( WP_PLUGIN_DIR, '/' ) . '/';
			$relative_plugin_path = getenv( 'PLUGIN_PATH' );
			if (strpos($relative_plugin_path, $plugin_directory) === 0) {
				$relative_plugin_path = substr($relative_plugin_path, strlen($plugin_directory));
			}

			if ( is_dir( $plugin_directory . $relative_plugin_path ) ) {
				$relative_plugin_path = rtrim( $relative_plugin_path, '/' ) . '/';
			}

			$active_plugins = get_option( 'active_plugins' );
			if ( ! is_array( $active_plugins ) ) {
				$active_plugins = array();
			}
			ob_end_clean();

			/**
			 * Use a shutdown function to ensure the activation-related output comes
			 * last in stdout.
			 */
			register_shutdown_function( function() use ( $relative_plugin_path, $active_plugins ) {
				foreach ( $active_plugins as $plugin ) {
					if ( substr( $plugin, 0, strlen( $relative_plugin_path ) ) === $relative_plugin_path ) {
						die('{"success": true}');
						break;
					}
				}
				die('{"success": false}');
			});
		`,
    env: {
      DOCROOT: a,
      PLUGIN_PATH: t
    }
  })).text ?? "").trim();
  if (!o.endsWith('{"success": true}'))
    throw o !== '{"success": false}' && Te.debug(o), new Error(
      `Plugin ${t} could not be activated - WordPress exited with exit code ${s.exitCode}. Inspect the "debug" logs in the console for more details. Output headers: ${JSON.stringify(
        s.headers,
        null,
        2
      )}`
    );
}, qu = async (e, { themeFolderName: t }, r) => {
  r == null || r.tracker.setCaption(`Activating ${t}`);
  const i = await e.documentRoot, a = `${i}/wp-content/themes/${t}`;
  if (!await e.fileExists(a))
    throw new Error(`
			Couldn't activate theme ${t}.
			Theme not found at the provided theme path: ${a}.
			Check the theme path to ensure it's correct.
			If the theme is not installed, you can install it using the installTheme step.
			More info can be found in the Blueprint documentation: https://wordpress.github.io/wordpress-playground/blueprints/steps/#ActivateThemeStep
		`);
  const s = await e.run({
    code: `<?php
			define( 'WP_ADMIN', true );
			require_once( getenv('docroot') . "/wp-load.php" );

			// Set current user to admin
			wp_set_current_user( get_users(array('role' => 'Administrator') )[0]->ID );

			switch_theme( getenv('themeFolderName') );

			if( wp_get_theme()->get_stylesheet() !== getenv('themeFolderName') ) {
				throw new Exception( 'Theme ' . getenv('themeFolderName') . ' could not be activated.' );				
			}
			die('Theme activated successfully');
		`,
    env: {
      docroot: i,
      themeFolderName: t
    }
  });
  if (s.text !== "Theme activated successfully")
    throw Te.debug(s), new Error(
      `Theme ${t} could not be activated - WordPress exited with exit code ${s.exitCode}. Inspect the "debug" logs in the console for more details. Output headers: ${JSON.stringify(
        s.headers,
        null,
        2
      )}`
    );
}, Zw = async (e, { code: t }) => {
  let r = typeof t == "string" ? t : t.content;
  return (r.includes('"wordpress/wp-load.php"') || r.includes("'wordpress/wp-load.php'")) && (Te.error(
    `
It looks like you're trying to load WordPress using a relative path 'wordpress/wp-load.php'.

Playground recently changed the working directory from '/' to '/wordpress' to better mimic
how real web servers work. This means relative paths that used to work may no longer
point to the correct location.

Playground automatically updated the path for you, but at one point path rewriting will be removed. Please
update your code to use an absolute path instead:

Instead of:  require_once 'wordpress/wp-load.php';
Use:         require_once '/wordpress/wp-load.php';

This will ensure your code works reliably regardless of the current working directory.
		`.trim()
  ), r = r.replace(
    "'wordpress/wp-load.php'",
    "'/wordpress/wp-load.php'"
  ), r = r.replace(
    '"wordpress/wp-load.php"',
    '"/wordpress/wp-load.php"'
  )), await e.run({ code: r });
}, Yw = async (e, { options: t }) => await e.run(t), eo = async (e, { path: t }) => {
  t.startsWith("/") || (Te.error(
    `
The rm() step in your Blueprint refers to a relative path.

Playground recently changed the working directory from '/' to '/wordpress' to better mimic 
how real web servers work. This means relative paths that used to work may no longer 
point to the correct location.

Playground automatically updated the path for you, but at one point path rewriting will be removed. Please
update your code to use an absolute path instead:

Instead of:  rm({ path: 'wordpress/wp-load.php' });
Use:         rm({ path: '/wordpress/wp-load.php' });

This will ensure your code works reliably regardless of the current working directory.
		`.trim()
  ), t = `/${t}`), await e.unlink(t);
}, Xw = `<?php

/**
 * Naively splits an SQL string into a sequence of queries. It
 * streams the data so you can process very large chunks of SQL
 * without running out of memory.
 * 
 * This class is **naive** because it doesn't understand what a
 * valid query is. The lexer does not provide a way to distinguish
 * between a syntax error and an incomplete input yet. Lacking this
 * information, we assume that no SQL query is larger than 2MB and,
 * failing to extract a query from a 2MB buffer, we fail. This heuristic
 * is often sufficient, but may fail in pathological cases.
 * 
 * Usage:
 * 
 *     $stream = new WP_MySQL_Naive_Query_Stream();
 *     $stream->append_sql( 'SELECT id FROM users; SELECT * FROM posts;' );
 *     while ( $stream->next_query() ) {
 *         $sql_string = $stream->get_query();
 *         // Process the query.
 *     }
 *     $stream->append_sql( 'CREATE TABLE users (id INT, name VARCHAR(255));' );
 *     while ( $stream->next_query() ) {
 *         $sql_string = $stream->get_query();
 *         // Process the query.
 *     }
 *     $stream->mark_input_complete();
 *     $stream->next_query(); // returns false
 */
class WP_MySQL_Naive_Query_Stream {

	private $sql_buffer = '';
	private $input_complete = false;
	private $state = true;
	private $last_query = false;

	const STATE_QUERY = 'valid';
	const STATE_SYNTAX_ERROR = 'syntax_error';
	const STATE_PAUSED_ON_INCOMPLETE_INPUT = 'paused_on_incomplete_input';
	const STATE_FINISHED = 'finished';

	/**
	 * The maximum size of the buffer to store the SQL input. We don't
	 * have enough information from the lexer to distinguish between
	 * an incomplete input and a syntax error so we use a heuristic â€“
	 * if we've accumulated more than this amount of SQL input, we assume
	 * it's a syntax error. That's why this class is called a "naive" query
	 * stream.
	 */
	const MAX_SQL_BUFFER_SIZE = 1024 * 1024 * 15;

	public function __construct() {}

	public function append_sql( string $sql ) {
		if($this->input_complete) {
			return false;
		}
		$this->sql_buffer .= $sql;
		$this->state = self::STATE_QUERY;
		return true;
	}

	public function is_paused_on_incomplete_input(): bool {
		return $this->state === self::STATE_PAUSED_ON_INCOMPLETE_INPUT;
	}

	public function mark_input_complete() {
		$this->input_complete = true;
	}

	public function next_query() {
		$this->last_query = false;
		if($this->state === self::STATE_PAUSED_ON_INCOMPLETE_INPUT) {
			return false;
		}

		$result = $this->do_next_query();
		if(!$result && strlen($this->sql_buffer) > self::MAX_SQL_BUFFER_SIZE) {
			$this->state = self::STATE_SYNTAX_ERROR;
			return false;
		}
		return $result;
	}

	private function do_next_query() {
		$query = [];
		$lexer = new WP_MySQL_Lexer( $this->sql_buffer );
		while ( $lexer->next_token() ) {
			$token = $lexer->get_token();
			$query[] = $token;
			if ( $token->id === WP_MySQL_Lexer::SEMICOLON_SYMBOL ) {
				// Got a complete query!
				break;
			}
		}

		// @TODO: expose this method from the lexer
		// if($lexer->get_state() === WP_MySQL_Lexer::STATE_SYNTAX_ERROR) {
		// 	return false;
		// }

		if(!count($query)) {
			if ( $this->input_complete ) {
				$this->state = self::STATE_FINISHED;
			} else {
				$this->state = self::STATE_PAUSED_ON_INCOMPLETE_INPUT;
			}
			return false;
		}

		// The last token either needs to end with a semicolon, or be the
		// last token in the input.
		$last_token = $query[count($query) - 1];
		if ( 
			$last_token->id !== WP_MySQL_Lexer::SEMICOLON_SYMBOL &&
			! $this->input_complete
		) {
			$this->state = self::STATE_PAUSED_ON_INCOMPLETE_INPUT;
			return false;
		}

		// See if the query has any meaningful tokens. We don't want to return
		// to give the caller a comment disguised as a query.
		$has_meaningful_tokens = false;
		foreach($query as $token) {
			if ( 
				$token->id !== WP_MySQL_Lexer::WHITESPACE && 
				$token->id !== WP_MySQL_Lexer::COMMENT &&
				$token->id !== WP_MySQL_Lexer::MYSQL_COMMENT_START &&
				$token->id !== WP_MySQL_Lexer::MYSQL_COMMENT_END &&
				$token->id !== WP_MySQL_Lexer::EOF
			) {
				$has_meaningful_tokens = true;
				break;
			}
		}
		if(!$has_meaningful_tokens) {
			if ( $this->input_complete ) {
				$this->state = self::STATE_FINISHED;
			} else {
				$this->state = self::STATE_PAUSED_ON_INCOMPLETE_INPUT;
			}
			return false;
		}

		// Remove the query from the input buffer and return it.
		$last_byte = $last_token->start + $last_token->length;
		$query = substr($this->sql_buffer, 0, $last_byte);
		$this->sql_buffer = substr($this->sql_buffer, $last_byte);
		$this->last_query = $query;
		$this->state = self::STATE_QUERY;
		return true;
	}

	public function get_query() {
		return $this->last_query;
	}

	public function get_state() {
		return $this->state;
	}

}`, Jw = async (e, { sql: t }, r) => {
  r == null || r.tracker.setCaption("Executing SQL Queries");
  const i = `/tmp/${js()}.sql`, a = `/tmp/${js()}.php`;
  await e.writeFile(
    i,
    new Uint8Array(await t.arrayBuffer())
  ), await e.writeFile(
    a,
    new TextEncoder().encode(Xw)
  );
  const s = await e.documentRoot, n = ai({ docroot: s, sqlFilename: i, streamClassFilename: a }), o = await e.run({
    code: `<?php
		define('WP_SQLITE_AST_DRIVER', true);
		require_once ${n.docroot} . '/wp-load.php';

		// Load WP_MySQL_Naive_Query_Stream from the bundled file
		require_once ${n.streamClassFilename};

		global $wpdb;

		do_action('run_sql_step');

		$stream = new WP_MySQL_Naive_Query_Stream();

		// Open the SQL file for streaming
		$handle = fopen(${n.sqlFilename}, 'r');
		if (!$handle) {
			throw new Exception('Failed to open SQL file');
		}

		// Read and process the file in 8KB chunks
		$chunk_size = 8192;
		while (!feof($handle)) {
			$chunk = fread($handle, $chunk_size);
			if ($chunk === false) {
				break;
			}

			$stream->append_sql($chunk);

			// Process any complete queries in the stream
			while ($stream->next_query()) {
				$query = $stream->get_query();
				$wpdb->query($query);
			}
		}

		fclose($handle);

		// Mark input as complete and process any remaining queries
		$stream->mark_input_complete();
		while ($stream->next_query()) {
			$query = $stream->get_query();
			$wpdb->query($query);
		}
	`
  });
  return await eo(e, { path: i }), await eo(e, { path: a }), o;
}, Qw = async (e, { request: t }) => {
  Te.warn(
    'Deprecated: The Blueprint step "request" is deprecated and will be removed in a future release.'
  );
  const r = await e.request(t);
  if (r.httpStatusCode > 399 || r.httpStatusCode < 200)
    throw Te.warn("WordPress response was", { response: r }), new Error(
      `Request failed with status ${r.httpStatusCode}`
    );
  return r;
}, eb = `<?php

/**
 * Rewrites the wp-config.php file to ensure specific constants are defined
 * with specific values.
 * 
 * Example:
 * 
 * \`\`\`php
 * <?php
 * define('WP_DEBUG', true);
 * // The third define() argument is also supported:
 * define('SAVEQUERIES', false, true);
 * 
 * // Expression
 * define(true ? 'WP_DEBUG_LOG' : 'WP_DEBUG_LOG', 123);
 * 
 * // Guarded expressions shouldn't be wrapped twice
 * if(!defined(1 ? 'A' : 'B')) {
 *     define(1 ? 'A' : 'B', 0);
 * }
 * 
 * // More advanced expression
 * define((function() use($x) {
 *     return [$x, 'a'];
 * })(), 123);
 * \`\`\`
 * 
 * Rewritten with
 * 
 *     $constants = [
 *        'WP_DEBUG' => false,
 *        'WP_DEBUG_LOG' => true,
 *        'SAVEQUERIES' => true,
 *        'NEW_CONSTANT' => "new constant",
 *     ];
 * 
 * \`\`\`php
 * <?php
 * define('WP_DEBUG_LOG',true);
 * define('NEW_CONSTANT','new constant');
 * ?><?php
 * define('WP_DEBUG',false);
 * // The third define() argument is also supported:
 * define('SAVEQUERIES',true, true);
 * 
 * // Expression
 * if(!defined($const ? 'WP_DEBUG_LOG' : 'WP_DEBUG_LOG')) {
 *      define($const ? 'WP_DEBUG_LOG' : 'WP_DEBUG_LOG', 123);
 * }
 * 
 * // Guarded expressions shouldn't be wrapped twice
 * if(!defined(1 ? 'A' : 'B')) {
 *     define(1 ? 'A' : 'B', 0);
 * }
 * 
 * // More advanced expression
 * if(!defined((function() use($x) {
 *    return [$x, 'a'];
 * })())) {
 *     define((function() use($x) {
 *         return [$x, 'a'];
 *     })(), 123);
 * }
 * \`\`\`
 *
 * @param mixed $content              A PHP file content.
 * @param array $constants            An array of constants to define.
 * @param bool  $when_already_defined Optional. What to do if the constant is already defined.
 *                                    Possible values are:
 *                                      'rewrite' - Rewrite the constant, using the new value.
 *                                      'skip'    - Skip the definition, keeping the existing value.
 *                                    Default: 'rewrite'
 * @return string
 */
function rewrite_wp_config_to_define_constants($content, $constants = [], $when_already_defined = 'rewrite')
{
    $tokens = array_reverse(token_get_all($content));
    $output = [];
    $defined_expressions = [];

    // Look through all the tokens and find the define calls
    do {
        $buffer = [];
        $name_buffer = [];
        $value_buffer = [];
        $third_arg_buffer = [];

        // Capture everything until the define call into output.
        // Capturing the define call into a buffer.
        // Example:
        //     <?php echo 'a'; define  (
        //     ^^^^^^^^^^^^^^^^^^^^^^
        //           output   |buffer
        while ($token = array_pop($tokens)) {
            if (is_array($token) && $token[0] === T_STRING && (strtolower($token[1]) === 'define' || strtolower($token[1]) === 'defined')) {
                $buffer[] = $token;
                break;
            }
            $output[] = $token;
        }

        // Maybe we didn't find a define call and reached the end of the file?
        if (!count($tokens)) {
            break;
        }

        // Keep track of the "defined" expressions that are already accounted for
        if($token[1] === 'defined') {
            $output[] = $token;
            $defined_expression = [];
            $open_parenthesis = 0;
            // Capture everything up to the opening parenthesis, including the parenthesis
            // e.g. defined  (
            //           ^^^^
            while ($token = array_pop($tokens)) {
                $output[] = $token;
                if ($token === "(") {
                    ++$open_parenthesis;
                    break;
                }
            }

            // Capture everything up to the closing parenthesis, including the parenthesis
            // e.g. defined  (
            //           ^^^^
            while ($token = array_pop($tokens)) {
                $output[] = $token;
                if ($token === ")") {
                    --$open_parenthesis;
                }
                if ($open_parenthesis === 0) {
                    break;
                }
                $defined_expression[] = $token;
            }

            $defined_expressions[] = stringify_tokens(skip_whitespace($defined_expression));
            continue;
        }

        // Capture everything up to the opening parenthesis, including the parenthesis
        // e.g. define  (
        //           ^^^^
        while ($token = array_pop($tokens)) {
            $buffer[] = $token;
            if ($token === "(") {
                break;
            }
        }

        // Capture the first argument â€“ it's the first expression after the opening
        // parenthesis and before the comma:
        // Examples:
        //     define("WP_DEBUG", true);
        //            ^^^^^^^^^^^
        //
        //     define(count([1,2]) > 2 ? 'WP_DEBUG' : 'FOO', true);
        //            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        $open_parenthesis = 0;
        while ($token = array_pop($tokens)) {
            $buffer[] = $token;
            if ($token === "(" || $token === "[" || $token === "{") {
                ++$open_parenthesis;
            } elseif ($token === ")" || $token === "]" || $token === "}") {
                --$open_parenthesis;
            } elseif ($token === "," && $open_parenthesis === 0) {
                break;
            }

            // Don't capture the comma as a part of the constant name
            $name_buffer[] = $token;
        }

        // Capture everything until the closing parenthesis
        //     define("WP_DEBUG", true);
        //                       ^^^^^^
        $open_parenthesis = 0;
        $is_second_argument = true;
        while ($token = array_pop($tokens)) {
            $buffer[] = $token;
            if ($token === ")" && $open_parenthesis === 0) {
                // Final parenthesis of the define call.
                break;
            } else if ($token === "(" || $token === "[" || $token === "{") {
                ++$open_parenthesis;
            } elseif ($token === ")" || $token === "]" || $token === "}") {
                --$open_parenthesis;
            } elseif ($token === "," && $open_parenthesis === 0) {
                // This define call has more than 2 arguments! The third one is the
                // boolean value indicating $is_case_insensitive. Let's continue capturing
                // to $third_arg_buffer.
                $is_second_argument = false;
            }
            if ($is_second_argument) {
                $value_buffer[] = $token;
            } else {
                $third_arg_buffer[] = $token;
            }
        }

        // Capture until the semicolon
        //     define("WP_DEBUG", true)  ;
        //                             ^^^
        while ($token = array_pop($tokens)) {
            $buffer[] = $token;
            if ($token === ";") {
                break;
            }
        }

        // Decide whether $name_buffer is a constant name or an expression
        $name_token = null;
        $name_token_index = $token;
        $name_is_literal = true;
        foreach ($name_buffer as $k => $token) {
            if (is_array($token)) {
                if ($token[0] === T_WHITESPACE || $token[0] === T_COMMENT || $token[0] === T_DOC_COMMENT) {
                    continue;
                } else if ($token[0] === T_STRING || $token[0] === T_CONSTANT_ENCAPSED_STRING) {
                    $name_token = $token;
                    $name_token_index = $k;
                } else {
                    $name_is_literal = false;
                    break;
                }
            } else if ($token !== "(" && $token !== ")") {
                $name_is_literal = false;
                break;
            }
        }

        // We can't handle expressions as constant names. Let's wrap that define
        // call in an if(!defined()) statement, just in case it collides with
        // a constant name.
        if (!$name_is_literal) {
            // Ensure the defined expression is not already accounted for
            foreach ($defined_expressions as $defined_expression) {
                if ($defined_expression === stringify_tokens(skip_whitespace($name_buffer))) {
                    $output = array_merge($output, $buffer);
                    continue 2;
                }
            }
            $output = array_merge(
                $output,
                ["if(!defined("],
                $name_buffer,
                [")) {\\n     "],
                ['define('],
                $name_buffer,
                [','],
                $value_buffer,
                $third_arg_buffer,
                [");"],
                ["\\n}\\n"]
            );
            continue;
        }

        // Yay, we have a literal constant name in the buffer now. Let's
        // get its value:
        $name = eval('return ' . $name_token[1] . ';');

        // If the constant name is not in the list of constants we're looking,
        // we can ignore it.
        if (!array_key_exists($name, $constants)) {
            $output = array_merge($output, $buffer);
            continue;
        }

        // If "$when_already_defined" is set to 'skip', ignore the definition, and
		// remove the constant from the list so it doesn't get added to the output.
        if ('skip' === $when_already_defined) {
            $output = array_merge($output, $buffer);
            unset($constants[$name]);
            continue;
        }

        // We now have a define() call that defines a constant we're looking for.
        // Let's rewrite its value to the one 
        $output = array_merge(
            $output,
            ['define('],
            $name_buffer,
            [','],
            [var_export($constants[$name], true)],
            $third_arg_buffer,
            [");"]
        );

        // Remove the constant from the list so we can process any remaining
        // constants later.
        unset($constants[$name]);
    } while (count($tokens));

    // Add any constants that weren't found in the file
    if (count($constants)) {
        $prepend = [
            "<?php \\n"
        ];
        foreach ($constants as $name => $value) {
            $prepend = array_merge(
                $prepend,
                [
                    "define(",
                    var_export($name, true),
                    ',',
                    var_export($value, true),
                    ");\\n"
                ]
            );
        }
        $prepend[] = "?>";
        $output = array_merge(
            $prepend,
            $output
        );
    }

    // Translate the output tokens back into a string
    return stringify_tokens($output);
}

function stringify_tokens($tokens) {
    $output = '';
    foreach ($tokens as $token) {
        if (is_array($token)) {
            $output .= $token[1];
        } else {
            $output .= $token;
        }
    }
    return $output;
}

function skip_whitespace($tokens) {
    $output = [];
    foreach ($tokens as $token) {
        if (is_array($token) && ($token[0] === T_WHITESPACE || $token[0] === T_COMMENT || $token[0] === T_DOC_COMMENT)) {
            continue;
        }
        $output[] = $token;
    }
    return $output;
}
`;
async function Ku(e, t, r, i = "rewrite") {
  const a = ai({ wpConfigPath: t, constants: r, whenAlreadyDefined: i });
  if ((await e.run({
    code: `<?php ob_start(); ?>
			${eb}
			$wp_config_path = ${a.wpConfigPath};
			$wp_config = file_get_contents($wp_config_path);
			$new_wp_config = rewrite_wp_config_to_define_constants($wp_config, ${a.constants}, ${a.whenAlreadyDefined});
			$return_value = file_put_contents($wp_config_path, $new_wp_config);
			ob_clean();
			echo false === $return_value ? '0' : '1';
			ob_end_flush();
		`
  })).text !== "1")
    throw new Error("Failed to rewrite constants in wp-config.php.");
}
async function tb(e, t) {
  const r = Ae(t, "wp-config.php"), i = {
    DB_NAME: "wordpress"
  };
  !e.fileExists(r) && e.fileExists(Ae(t, "wp-config-sample.php")) && await e.writeFile(
    r,
    await e.readFileAsBuffer(
      Ae(t, "wp-config-sample.php")
    )
  ), await Ku(e, r, i, "skip");
}
const Co = async (e, { consts: t, method: r = "define-before-run" }) => {
  switch (r) {
    case "define-before-run":
      await rb(e, t);
      break;
    case "rewrite-wp-config": {
      const i = await e.documentRoot, a = Ae(i, "/wp-config.php");
      await Ku(
        e,
        a,
        t,
        "rewrite"
      );
      break;
    }
    default:
      throw new Error(`Invalid method: ${r}`);
  }
};
async function rb(e, t) {
  for (const r in t)
    await e.defineConstant(r, t[r]);
}
const zu = async (e, { options: t }) => {
  const r = await e.documentRoot;
  await e.run({
    code: `<?php
		include ${xt(r)} . '/wp-load.php';
		$site_options = ${xt(t)};
		foreach($site_options as $name => $value) {
			update_option($name, $value);
		}
		echo "Success";
		`
  });
}, nb = async (e, { meta: t, userId: r }) => {
  const i = await e.documentRoot;
  await e.run({
    code: `<?php
		include ${xt(i)} . '/wp-load.php';
		$meta = ${xt(t)};
		foreach($meta as $name => $value) {
			update_user_meta(${xt(r)}, $name, $value);
		}
		`
  });
}, Lo = "/tmp/wp-cli.phar", sb = {
  resource: "url",
  /**
   * Use compression for downloading the wp-cli.phar file.
   * The official release, hosted at raw.githubusercontent.com, is ~7MB
   * and the transfer is uncompressed. playground.wordpress.net supports
   * transfer compression and only transmits ~1.4MB.
   *
   * @TODO: minify the wp-cli.phar file. It can be as small as 1MB when all the
   *        whitespaces and are removed, and even 500KB when libraries
   *        like the JavaScript parser or Composer are removed.
   */
  url: "https://playground.wordpress.net/wp-cli.phar"
}, Gu = async (e, t = Lo) => {
  if (!await e.fileExists(t))
    throw new Error(`wp-cli.phar not found at ${t}.
			You can enable wp-cli support by adding "wp-cli" to the list of extra libraries in your blueprint as follows:
			{
				"extraLibraries": [ "wp-cli" ]
			}
			Read more about it in the documentation.
			https://wordpress.github.io/wordpress-playground/blueprints/data-format#extra-libraries`);
}, Vu = async (e, { command: t, wpCliPath: r = Lo }) => {
  await Gu(e, r);
  let i;
  if (typeof t == "string" ? (t = t.trim(), i = ib(t)) : i = t, i.shift() !== "wp")
    throw new Error('The first argument must be "wp".');
  let s = !1;
  const n = i.map((p) => p.startsWith("wordpress/") ? (s = !0, `/${p}`) : p);
  s && Te.error(
    `
The wp-cli step in your Blueprint refers to a relative path.

Playground recently changed the working directory from '/' to '/wordpress' to better mimic 
how real web servers work. This means relative paths that used to work may no longer 
point to the correct location.

Playground automatically updated the path for you, but at one point path rewriting will be removed. Please
update your code to use an absolute path instead:

Instead of:

        {
            "step": "wp-cli",
            "command": "wp media import wordpress/wp-content/Select-storage-method.png --post_id=4 --title='Select your storage method' --featured_image"
        }

Use:

        {
            "step": "wp-cli",
            "command": "wp media import /wordpress/wp-content/Select-storage-method.png --post_id=4 --title='Select your storage method' --featured_image"
        }

This will ensure your code works reliably regardless of the current working directory.
        `.trim()
  );
  const o = await e.documentRoot;
  await e.writeFile("/tmp/stdout", ""), await e.writeFile("/tmp/stderr", ""), await e.writeFile(
    Ae(o, "run-cli.php"),
    `<?php
		// Set up the environment to emulate a shell script
		// call.

		// Set SHELL_PIPE to 0 to ensure WP-CLI formats
		// the output as ASCII tables.
		// @see https://github.com/wp-cli/wp-cli/issues/1102
		putenv( 'SHELL_PIPE=0' );

		// Set the argv global.
		$GLOBALS['argv'] = array_merge([
		  "/tmp/wp-cli.phar",
		  "--path=${o}"
		], ${xt(n)});

		// Provide stdin, stdout, stderr streams outside of
		// the CLI SAPI.
		define('STDIN', fopen('php://stdin', 'rb'));
		define('STDOUT', fopen('php://stdout', 'wb'));
		define('STDERR', fopen('php://stderr', 'wb'));

		require( ${xt(r)} );
		`
  );
  const l = await e.run({
    scriptPath: Ae(o, "run-cli.php")
  });
  if (l.errors)
    throw new Error(l.errors);
  return l;
};
function ib(e) {
  let i = 0, a = "";
  const s = [];
  let n = "";
  for (let o = 0; o < e.length; o++) {
    const l = e[o];
    i === 0 ? l === '"' || l === "'" ? (i = 1, a = l) : l.match(/\s/) ? (n && s.push(n), n = "") : n += l : i === 1 && (l === "\\" ? (o++, n += e[o]) : l === a ? (i = 0, a = "") : n += l);
  }
  return n && s.push(n), s;
}
const ab = async (e, { wpCliPath: t }) => {
  await Gu(e, t), await Co(e, {
    consts: {
      WP_ALLOW_MULTISITE: 1
    }
  });
  const r = new URL(await e.absoluteUrl);
  if (r.port !== "") {
    let s = `The current host is ${r.host}, but WordPress multisites do not support custom ports.`;
    throw r.hostname === "localhost" && (s += " For development, you can set up a playground.test domain using the instructions at https://wordpress.github.io/wordpress-playground/contributing/code."), new Error(s);
  }
  const i = r.pathname.replace(/\/$/, "") + "/", a = `${r.protocol}//${r.hostname}${i}`;
  await zu(e, {
    options: {
      siteurl: a,
      home: a
    }
  }), await Vu(e, {
    command: `wp core multisite-convert --base="${i}"`
  });
}, ob = async (e, { fromPath: t, toPath: r }) => {
  (!t.startsWith("/") || !r.startsWith("/")) && Te.error(
    `
The cp() step in your Blueprint refers to a relative path.

Playground recently changed the working directory from '/' to '/wordpress' to better mimic 
how real web servers work. This means relative paths that used to work may no longer 
point to the correct location.

Playground automatically updated the path for you, but at one point path rewriting will be removed. Please
update your code to use an absolute path instead:

Instead of:  cp({ fromPath: 'wordpress/wp-load.php', toPath: 'wordpress/wp-load.php' });
Use:         cp({ fromPath: '/wordpress/wp-load.php', toPath: '/wordpress/wp-load.php' });

This will ensure your code works reliably regardless of the current working directory.
		`.trim()
  ), t.startsWith("/") || (t = `/${t}`), r.startsWith("/") || (r = `/${r}`), await e.writeFile(
    r,
    await e.readFileAsBuffer(t)
  );
}, lb = async (e, { fromPath: t, toPath: r }) => {
  (!t.startsWith("/") || !r.startsWith("/")) && Te.error(
    `
The mv() step in your Blueprint refers to a relative path.

Playground recently changed the working directory from '/' to '/wordpress' to better mimic 
how real web servers work. This means relative paths that used to work may no longer 
point to the correct location.

Playground automatically updated the path for you, but at one point path rewriting will be removed. Please
update your code to use an absolute path instead:

Instead of:  mv({ fromPath: 'wordpress/wp-load.php', toPath: 'wordpress/wp-load.php' });
Use:         mv({ fromPath: '/wordpress/wp-load.php', toPath: '/wordpress/wp-load.php' });

This will ensure your code works reliably regardless of the current working directory.
		`.trim()
  ), t.startsWith("/") || (t = `/${t}`), r.startsWith("/") || (r = `/${r}`), await e.mv(t, r);
}, fb = async (e, { path: t }) => {
  t.startsWith("/") || Te.error(
    `
The mkdir() step in your Blueprint refers to a relative path.

Playground recently changed the working directory from '/' to '/wordpress' to better mimic 
how real web servers work. This means relative paths that used to work may no longer 
point to the correct location.

Playground automatically updated the path for you, but at one point path rewriting will be removed. Please
update your code to use an absolute path instead:

Instead of:  mkdir({ path: 'wordpress/my-new-folder' });
Use:         mkdir({ path: '/wordpress/my-new-folder' });

This will ensure your code works reliably regardless of the current working directory.
		`.trim()
  ), await e.mkdir(t);
}, pb = async (e, { path: t }) => {
  t.startsWith("/") || (Te.error(
    `
The rmdir() step in your Blueprint refers to a relative path.

Playground recently changed the working directory from '/' to '/wordpress' to better mimic 
how real web servers work. This means relative paths that used to work may no longer 
point to the correct location.

Playground automatically updated the path for you, but at one point path rewriting will be removed. Please
update your code to use an absolute path instead:

Instead of:  rmdir({ path: 'wordpress/wp-load.php' });
Use:         rmdir({ path: '/wordpress/wp-load.php' });

This will ensure your code works reliably regardless of the current working directory.
		`.trim()
  ), t = `/${t}`), await e.rmdir(t);
}, Ro = async (e, { path: t, data: r }) => {
  r instanceof File && (r = new Uint8Array(await r.arrayBuffer())), t.startsWith("/") || (Te.error(
    `
The writeFile() step in your Blueprint refers to a relative path.

Playground recently changed the working directory from '/' to '/wordpress' to better mimic 
how real web servers work. This means relative paths that used to work may no longer 
point to the correct location.

Playground automatically updated the path for you, but at one point path rewriting will be removed. Please
update your code to use an absolute path instead:

Instead of:  writeFile({ path: 'wordpress/wp-load.php', data: '<?php echo "Hello World!"; ?>' });
Use:         writeFile({ path: '/wordpress/wp-load.php', data: '<?php echo "Hello World!"; ?>' });

This will ensure your code works reliably regardless of the current working directory.
		`.trim()
  ), t = `/${t}`), t.startsWith("/wordpress/wp-content/mu-plugins") && !await e.fileExists("/wordpress/wp-content/mu-plugins") && await e.mkdir("/wordpress/wp-content/mu-plugins"), await e.writeFile(t, r);
}, cb = async (e, { writeToPath: t, filesTree: r }) => {
  t.startsWith("/") || (Te.error(
    `
The writeFiles() step in your Blueprint refers to a relative path.

Playground recently changed the working directory from '/' to '/wordpress' to better mimic 
how real web servers work. This means relative paths that used to work may no longer
point to the correct location.

Playground automatically updated the path for you, but at one point path rewriting will be removed. Please
update your code to use an absolute path instead:

Instead of:  writeFiles({ writeToPath: 'wordpress/wp-content/plugins/my-plugin', filesTree: { name: 'style.css': 'a { color: red; }' });
Use:         writeFiles({ writeToPath: '/wordpress/wp-content/plugins/my-plugin', filesTree: { name: 'style.css': 'a { color: red; }' });

This will ensure your code works reliably regardless of the current working directory.
		`.trim()
  ), t = `/${t}`), await oi(e, t, r.files);
}, Zu = async (e, { siteUrl: t }) => {
  await Co(e, {
    consts: {
      WP_HOME: t,
      WP_SITEURL: t
    }
  });
}, ub = async (e, { file: t }, r) => {
  await db(e, t, r);
};
async function db(e, t, r) {
  var i;
  (i = r == null ? void 0 : r.tracker) == null || i.setCaption("Importing content"), await Ro(e, {
    path: "/tmp/import.wxr",
    data: t
  }), await e.run({
    $_SERVER: {
      /**
       * get_site_url() infers the protocol from $_SERVER['HTTPS'] instead of
       * using the stored siteurl option. The importer relies on that behavior
       * when rewriting links in the WXR payload, so we populate the flag here
       * just as the web request layer would.
       */
      HTTPS: (await e.absoluteUrl).startsWith("https://") ? "on" : ""
    },
    code: `<?php
	define('WP_LOAD_IMPORTERS', true);
	require 'wp-load.php';
	require 'wp-admin/includes/admin.php';

	/**
	 * Disable all kses filters to prevent content sanitization during import.
	 * It messes up Playground URL scheme by mangling transforming code such as:
	 *
	 *     <a href="/scope:kind-quiet-lake/index.php">Test</a>
	 *
	 * into:
	 *
	 *     <a href="kind-quiet-lake/index.php">Test</a>
	 */
	kses_remove_filters();

	// Set current user for the importer to pick it up as the default
	// post author.
	$admin_id = get_users(array('role' => 'Administrator') )[0]->ID;
	wp_set_current_user( $admin_id );

	$wp_import                  = new WP_Import();
	$import_data                = $wp_import->parse( getenv('IMPORT_FILE') );

	// Prepare the data to be used in process_author_mapping();
	$wp_import->get_authors_from_import( $import_data );

	// We no longer need the original data, so unset to avoid using excess
	// memory.
	unset( $import_data );

	// Drive the import
	$wp_import->fetch_attachments = getenv('FETCH_ATTACHMENTS') === 'true';

	$_GET  = array(
		'import' => 'wordpress',
		'step'   => 2,
	);
	$_POST = array(
		'imported_authors'  => array(),
		'user_map'          => array(),
		'fetch_attachments' => $wp_import->fetch_attachments,
	);

	$GLOBALS['wpcli_import_current_file'] = basename( $file );
	$wp_import->import( getenv('IMPORT_FILE'), [
		'rewrite_urls' => true,
	] );
	`,
    env: {
      IMPORT_FILE: "/tmp/import.wxr",
      FETCH_ATTACHMENTS: "true"
    }
  });
}
const Yu = async (e, { themeSlug: t = "" }, r) => {
  var a;
  (a = r == null ? void 0 : r.tracker) == null || a.setCaption("Importing theme starter content");
  const i = await e.documentRoot;
  await e.run({
    code: `<?php

		/**
		 * Ensure that the customizer loads as an admin user.
		 *
		 * For compatibility with themes, this MUST be run prior to theme inclusion, which is why this is a plugins_loaded filter instead
		 * of running _wp_customize_include() manually after load.
		 */
		function importThemeStarterContent_plugins_loaded() {
			// Set as the admin user, this ensures we can customize the site.
			wp_set_current_user(
				get_users( [ 'role' => 'Administrator' ] )[0]
			);

			// Force the site to be fresh, although it should already be.
			add_filter( 'pre_option_fresh_site', '__return_true' );

			/*
			 * Simulate this request as the customizer loading with the current theme in preview mode.
			 *
			 * See _wp_customize_include()
			 */
			$_REQUEST['wp_customize']    = 'on';
			$_REQUEST['customize_theme'] = ${xt(t)} ?: get_stylesheet();

			/*
			 * Claim this is a ajax request saving settings, to avoid the preview filters being applied.
			 */
			$_REQUEST['action'] = 'customize_save';
			add_filter( 'wp_doing_ajax', '__return_true' );

			$_GET = $_REQUEST;
		}
		playground_add_filter( 'plugins_loaded', 'importThemeStarterContent_plugins_loaded', 0 );

		require ${xt(i)} . '/wp-load.php';

		// Return early if there's no starter content.
		if ( ! get_theme_starter_content() ) {
			return;
		}

		// Import the Starter Content.
		$wp_customize->import_theme_starter_content();

		// Publish the changeset, which publishes the starter content.
		wp_publish_post( $wp_customize->changeset_post_id() );
		`
  });
}, $o = async (e, { zipFile: t, zipPath: r, extractToPath: i }) => {
  if (r)
    Te.warn(
      'The "zipPath" option of the unzip() Blueprint step is deprecated and will be removed. Use "zipFile" instead.'
    );
  else if (!t)
    throw new Error("Either zipPath or zipFile must be provided");
  await ju(e, t || r, i);
}, Xu = [
  "db.php",
  "plugins/akismet",
  "plugins/hello.php",
  "plugins/wordpress-importer",
  "mu-plugins/sqlite-database-integration",
  "mu-plugins/playground-includes",
  "mu-plugins/0-playground.php",
  "mu-plugins/0-sqlite.php",
  /*
   * Listing core themes like that here isn't ideal, especially since
   * developers may actually want to use one of them.
   * @TODO Let's give the user a choice whether or not to include them.
   */
  "themes/twentytwenty",
  "themes/twentytwentyone",
  "themes/twentytwentytwo",
  "themes/twentytwentythree",
  "themes/twentytwentyfour",
  "themes/twentytwentyfive",
  "themes/twentytwentysix"
], hb = async (e, { wordPressFilesZip: t, pathInZip: r = "" }) => {
  const i = await e.documentRoot;
  let a = Ae("/tmp", "import");
  await e.mkdir(a), await $o(e, {
    zipFile: t,
    extractToPath: a
  }), a = Ae(a, r);
  const s = Ae(a, "wp-content"), n = Ae(i, "wp-content");
  for (const c of Xu) {
    const m = Ae(
      s,
      c
    );
    await up(e, m);
    const h = Ae(n, c);
    await e.fileExists(h) && (await e.mkdir(Ca(m)), await e.mv(h, m));
  }
  const o = Ae(
    a,
    "wp-content",
    "database"
  );
  await e.fileExists(o) || await e.mv(
    Ae(i, "wp-content", "database"),
    o
  );
  const l = await e.listFiles(a);
  for (const c of l)
    await up(e, Ae(i, c)), await e.mv(
      Ae(a, c),
      Ae(i, c)
    );
  await e.rmdir(a), await tb(e, i), await Zu(e, {
    siteUrl: await e.absoluteUrl
  });
  const p = xt(
    Ae(i, "wp-admin", "upgrade.php")
  );
  await e.run({
    code: `<?php
            $_GET['step'] = 'upgrade_db';
            require ${p};
            `
  });
};
async function up(e, t) {
  await e.fileExists(t) && (await e.isDir(t) ? await e.rmdir(t) : await e.unlink(t));
}
async function mb(e) {
  const t = await e.request({
    url: "/wp-admin/export.php?download=true&content=all"
  });
  return new File([t.bytes], "export.xml");
}
async function Ju(e, {
  targetPath: t,
  zipFile: r,
  ifAlreadyInstalled: i = "overwrite",
  targetFolderName: a = ""
}) {
  const n = r.name.replace(/\.zip$/, ""), o = Ae(await e.documentRoot, "wp-content"), l = Ae(o, js()), p = Ae(l, "assets", n);
  await e.fileExists(p) && await e.rmdir(l, {
    recursive: !0
  }), await e.mkdir(l);
  try {
    await $o(e, {
      zipFile: r,
      extractToPath: p
    });
    let c = await e.listFiles(p, {
      prependPath: !0
    });
    c = c.filter((y) => !y.endsWith("/__MACOSX"));
    const m = c.length === 1 && await e.isDir(c[0]);
    let h, g = "";
    m ? (g = c[0], h = c[0].split("/").pop()) : (g = p, h = n), a && a.length && (h = a);
    const R = `${t}/${h}`;
    if (await e.fileExists(R)) {
      if (!await e.isDir(R))
        throw new Error(
          `Cannot install asset ${h} to ${R} because a file with the same name already exists. Note it's a file, not a directory! Is this by mistake?`
        );
      if (i === "overwrite")
        await e.rmdir(R, {
          recursive: !0
        });
      else {
        if (i === "skip")
          return {
            assetFolderPath: R,
            assetFolderName: h
          };
        throw new Error(
          `Cannot install asset ${h} to ${t} because it already exists and the ifAlreadyInstalled option was set to ${i}`
        );
      }
    }
    return await e.mv(g, R), {
      assetFolderPath: R,
      assetFolderName: h
    };
  } finally {
    await e.rmdir(l, {
      recursive: !0
    });
  }
}
const yb = async (e, { pluginData: t, pluginZipFile: r, ifAlreadyInstalled: i, options: a = {} }, s) => {
  r && (t = r, Te.warn(
    'The "pluginZipFile" option is deprecated. Use "pluginData" instead.'
  ));
  const n = Ae(
    await e.documentRoot,
    "wp-content",
    "plugins"
  ), o = "targetFolderName" in a ? a.targetFolderName : "";
  let l = "", p = "";
  const c = async (h) => {
    if (h.name.toLowerCase().endsWith(".zip"))
      return !0;
    const g = new Uint8Array(await h.arrayBuffer(), 0, 4);
    return g[0] === 80 && g[1] === 75 && g[2] === 3 && g[3] === 4;
  };
  if (t instanceof File)
    if (await c(t)) {
      const h = t.name.split("/").pop() || "plugin.zip";
      p = gi(h), s == null || s.tracker.setCaption(
        `Installing the ${p} plugin`
      );
      const g = await Ju(e, {
        ifAlreadyInstalled: i,
        zipFile: t,
        targetPath: `${await e.documentRoot}/wp-content/plugins`,
        targetFolderName: o
      });
      l = g.assetFolderPath, p = g.assetFolderName;
    } else if (t.name.endsWith(".php")) {
      const h = Ae(
        n,
        t.name
      );
      await Ro(e, {
        path: h,
        data: t
      }), l = n, p = t.name;
    } else
      throw new Error(
        "pluginData looks like a file but does not look like a .zip or .php file."
      );
  else if (t) {
    p = t.name, s == null || s.tracker.setCaption(`Installing the ${p} plugin`);
    const h = Ae(
      n,
      o || t.name
    );
    await oi(e, h, t.files, {
      rmRoot: !0
    }), l = h;
  }
  ("activate" in a ? a.activate : !0) && await Mu(
    e,
    {
      pluginPath: l,
      pluginName: p
    },
    s
  );
}, _b = async (e, { themeData: t, themeZipFile: r, ifAlreadyInstalled: i, options: a = {} }, s) => {
  r && (t = r, Te.warn(
    'The "themeZipFile" option is deprecated. Use "themeData" instead.'
  ));
  const n = "targetFolderName" in a ? a.targetFolderName : "";
  let o = "", l = "";
  if (t instanceof File) {
    const m = t.name.split("/").pop() || "theme.zip";
    l = gi(m), s == null || s.tracker.setCaption(`Installing the ${l} theme`), o = (await Ju(e, {
      ifAlreadyInstalled: i,
      zipFile: t,
      targetPath: `${await e.documentRoot}/wp-content/themes`,
      targetFolderName: n
    })).assetFolderName;
  } else {
    l = t.name, o = n || l, s == null || s.tracker.setCaption(`Installing the ${l} theme`);
    const m = Ae(
      await e.documentRoot,
      "wp-content",
      "themes",
      o
    );
    await oi(e, m, t.files, {
      rmRoot: !0
    });
  }
  ("activate" in a ? a.activate : !0) && await qu(
    e,
    {
      themeFolderName: o
    },
    s
  ), ("importStarterContent" in a ? a.importStarterContent : !1) && await Yu(
    e,
    {
      themeSlug: o
    },
    s
  );
}, gb = async (e, { username: t = "admin" } = {}, r) => {
  r == null || r.tracker.setCaption((r == null ? void 0 : r.initialCaption) || "Logging in"), e.defineConstant("PLAYGROUND_AUTO_LOGIN_AS_USER", t);
}, wb = async (e, t, r) => {
  var a;
  (a = r == null ? void 0 : r.tracker) == null || a.setCaption("Resetting WordPress data");
  const i = await e.documentRoot;
  await e.run({
    env: {
      DOCROOT: i
    },
    code: `<?php
		require getenv('DOCROOT') . '/wp-load.php';

		$GLOBALS['@pdo']->query('DELETE FROM wp_posts WHERE id > 0');
		$GLOBALS['@pdo']->query("UPDATE SQLITE_SEQUENCE SET SEQ=0 WHERE NAME='wp_posts'");
		
		$GLOBALS['@pdo']->query('DELETE FROM wp_postmeta WHERE post_id > 1');
		$GLOBALS['@pdo']->query("UPDATE SQLITE_SEQUENCE SET SEQ=20 WHERE NAME='wp_postmeta'");

		$GLOBALS['@pdo']->query('DELETE FROM wp_comments');
		$GLOBALS['@pdo']->query("UPDATE SQLITE_SEQUENCE SET SEQ=0 WHERE NAME='wp_comments'");

		$GLOBALS['@pdo']->query('DELETE FROM wp_commentmeta');
		$GLOBALS['@pdo']->query("UPDATE SQLITE_SEQUENCE SET SEQ=0 WHERE NAME='wp_commentmeta'");
		`
  });
}, bb = async (e, { options: t }) => {
  await e.request({
    url: "/wp-admin/install.php?step=2",
    method: "POST",
    body: {
      language: "en",
      prefix: "wp_",
      weblog_title: "My WordPress Website",
      user_name: t.adminPassword || "admin",
      admin_password: t.adminPassword || "password",
      // The installation wizard demands typing the same password twice
      admin_password2: t.adminPassword || "password",
      Submit: "Install WordPress",
      pw_weak: "1",
      admin_email: "admin@localhost.com"
    }
  });
}, vb = async (e, { selfContained: t = !1 } = {}) => {
  const r = "/tmp/wordpress-playground.zip", i = await e.documentRoot, a = Ae(i, "wp-content");
  let s = Xu;
  t && (s = s.filter((l) => !l.startsWith("themes/twenty")).filter(
    (l) => l !== "mu-plugins/sqlite-database-integration"
  ));
  const n = ai({
    zipPath: r,
    wpContentPath: a,
    documentRoot: i,
    exceptPaths: s.map(
      (l) => Ae(i, "wp-content", l)
    ),
    additionalPaths: t ? {
      [Ae(i, "wp-config.php")]: "wp-config.php"
    } : {}
  });
  await Sb(
    e,
    `zipDir(${n.wpContentPath}, ${n.zipPath}, array(
			'exclude_paths' => ${n.exceptPaths},
			'zip_root'      => ${n.documentRoot},
			'additional_paths' => ${n.additionalPaths}
		));`
  );
  const o = await e.readFileAsBuffer(r);
  return e.unlink(r), o;
}, xb = `<?php

function zipDir($root, $output, $options = array())
{
    $root = rtrim($root, '/');
    $additionalPaths = array_key_exists('additional_paths', $options) ? $options['additional_paths'] : array();
    $excludePaths = array_key_exists('exclude_paths', $options) ? $options['exclude_paths'] : array();
    $zip_root = array_key_exists('zip_root', $options) ? $options['zip_root'] : $root;

    $zip = new ZipArchive;
    $res = $zip->open($output, ZipArchive::CREATE);
    if ($res === TRUE) {
        $directories = array(
            $root . '/'
        );
        while (sizeof($directories)) {
            $current_dir = array_pop($directories);

            if ($handle = opendir($current_dir)) {
                while (false !== ($entry = readdir($handle))) {
                    if ($entry == '.' || $entry == '..') {
                        continue;
                    }

                    $entry = join_paths($current_dir, $entry);
                    if (in_array($entry, $excludePaths)) {
                        continue;
                    }

                    if (is_dir($entry)) {
                        $directory_path = $entry . '/';
                        array_push($directories, $directory_path);
                    } else if (is_file($entry)) {
                        // ensure compliance with zip spec by only using relative paths for files
                        $zip->addFile($entry, ltrim(substr($entry, strlen($zip_root)), '/'));
                    }
                }
                closedir($handle);
            }
        }
        foreach ($additionalPaths as $disk_path => $zip_path) {
            $zip->addFile($disk_path, $zip_path);
        }
        $zip->close();
        chmod($output, 0777);
    }
}

function join_paths()
{
    $paths = array();

    foreach (func_get_args() as $arg) {
        if ($arg !== '') {
            $paths[] = $arg;
        }
    }

    return preg_replace('#/+#', '/', join('/', $paths));
}
`;
async function Sb(e, t) {
  return await e.run({
    code: xb + t
  });
}
const Eb = async (e, t) => {
  const a = (await (await fetch(
    `https://api.wordpress.org/translations/core/1.0/?version=${e}`
  )).json()).translations.find(
    (s) => s.language.toLowerCase() === t.toLowerCase()
  );
  if (!a)
    throw new Error(
      `Failed to get ${t} translation package for WordPress ${e}.`
    );
  return a.package;
}, kb = async (e, { language: t }, r) => {
  r == null || r.tracker.setCaption((r == null ? void 0 : r.initialCaption) || "Translating"), await e.defineConstant("WPLANG", t);
  const i = await e.documentRoot, a = (await e.run({
    code: `<?php
			require '${i}/wp-includes/version.php';
			echo $wp_version;
		`
  })).text, s = [
    {
      url: await Eb(a, t),
      type: "core"
    }
  ], o = (await e.run({
    code: `<?php
		require_once('${i}/wp-load.php');
		require_once('${i}/wp-admin/includes/plugin.php');
		echo json_encode(
			array_values(
				array_map(
					function($plugin) {
						return [
							'slug'    => $plugin['TextDomain'],
							'version' => $plugin['Version']
						];
					},
					array_filter(
						get_plugins(),
						function($plugin) {
							return !empty($plugin['TextDomain']);
						}
					)
				)
			)
		);`
  })).json;
  for (const { slug: h, version: g } of o)
    s.push({
      url: `https://downloads.wordpress.org/translation/plugin/${h}/${g}/${t}.zip`,
      type: "plugin"
    });
  const p = (await e.run({
    code: `<?php
		require_once('${i}/wp-load.php');
		require_once('${i}/wp-admin/includes/theme.php');
		echo json_encode(
			array_values(
				array_map(
					function($theme) {
						return [
							'slug'    => $theme->get('TextDomain'),
							'version' => $theme->get('Version')
						];
					},
					wp_get_themes()
				)
			)
		);`
  })).json;
  for (const { slug: h, version: g } of p)
    s.push({
      url: `https://downloads.wordpress.org/translation/theme/${h}/${g}/${t}.zip`,
      type: "theme"
    });
  await e.isDir(`${i}/wp-content/languages/plugins`) || await e.mkdir(`${i}/wp-content/languages/plugins`), await e.isDir(`${i}/wp-content/languages/themes`) || await e.mkdir(`${i}/wp-content/languages/themes`);
  const c = new cn({ concurrency: 5 }), m = s.map(
    ({ url: h, type: g }) => c.run(async () => {
      try {
        const R = await fetch(h);
        if (!R.ok)
          throw new Error(
            `Failed to download translations for ${g}: ${R.statusText}`
          );
        let y = `${i}/wp-content/languages`;
        g === "plugin" ? y += "/plugins" : g === "theme" && (y += "/themes"), await ju(
          e,
          new File(
            [await R.blob()],
            `${t}-${g}.zip`
          ),
          y
        );
      } catch (R) {
        if (g === "core")
          throw new Error(
            `Failed to download translations for WordPress. Please check if the language code ${t} is correct. You can find all available languages and translations on https://translate.wordpress.org/.`
          );
        Te.warn(
          `Error downloading translations for ${g}: ${R}`
        );
      }
    })
  );
  await Promise.all(m);
}, Pb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  activatePlugin: Mu,
  activateTheme: qu,
  cp: ob,
  defineSiteUrl: Zu,
  defineWpConfigConsts: Co,
  enableMultisite: ab,
  exportWXR: mb,
  importThemeStarterContent: Yu,
  importWordPressFiles: hb,
  importWxr: ub,
  installPlugin: yb,
  installTheme: _b,
  login: gb,
  mkdir: fb,
  mv: lb,
  request: Qw,
  resetData: wb,
  rm: eo,
  rmdir: pb,
  runPHP: Zw,
  runPHPWithOptions: Yw,
  runSql: Jw,
  runWpInstallationWizard: bb,
  setSiteLanguage: kb,
  setSiteOptions: zu,
  unzip: $o,
  updateUserMeta: nb,
  wpCLI: Vu,
  writeFile: Ro,
  writeFiles: cb,
  zipWpContent: vb
}, Symbol.toStringTag, { value: "Module" })), Ab = {
  properties: {
    landingPage: {
      type: "string",
      description: "The URL to navigate to after the blueprint has been run."
    },
    description: {
      type: "string",
      description: "Optional description. It doesn't do anything but is exposed as a courtesy to developers who may want to document which blueprint file does what.",
      deprecated: "Use meta.description instead."
    },
    meta: {
      type: "object",
      properties: {
        title: {
          type: "string",
          description: "A clear and concise name for your Blueprint."
        },
        description: {
          type: "string",
          description: "A brief explanation of what your Blueprint offers."
        },
        author: {
          type: "string",
          description: "A GitHub username of the author of this Blueprint."
        },
        categories: {
          type: "array",
          items: { type: "string" },
          description: "Relevant categories to help users find your Blueprint in the future Blueprints section on WordPress.org."
        }
      },
      required: ["title", "author"],
      additionalProperties: !1,
      description: "Optional metadata. Used by the Blueprints gallery at https://github.com/WordPress/blueprints"
    },
    preferredVersions: {
      type: "object",
      properties: {
        php: {
          anyOf: [
            { $ref: "#/definitions/SupportedPHPVersion" },
            { type: "string", const: "latest" }
          ],
          description: "The preferred PHP version to use. If not specified, the latest supported version will be used"
        },
        wp: {
          type: "string",
          description: "The preferred WordPress version to use. If not specified, the latest supported version will be used"
        }
      },
      required: ["php", "wp"],
      additionalProperties: !1,
      description: "The preferred PHP and WordPress versions to use."
    },
    features: {
      type: "object",
      properties: {
        intl: { type: "boolean" },
        networking: {
          type: "boolean",
          description: "Should boot with support for network request via wp_safe_remote_get?"
        }
      },
      additionalProperties: !1
    },
    extraLibraries: {
      type: "array",
      items: { $ref: "#/definitions/ExtraLibrary" },
      description: "Extra libraries to preload into the Playground instance."
    },
    constants: {
      $ref: "#/definitions/PHPConstants",
      description: "PHP Constants to define on every request"
    },
    plugins: {
      type: "array",
      items: {
        anyOf: [
          { type: "string" },
          { $ref: "#/definitions/FileReference" }
        ]
      },
      description: "WordPress plugins to install and activate"
    },
    siteOptions: {
      type: "object",
      additionalProperties: { type: "string" },
      properties: {
        blogname: { type: "string", description: "The site title" }
      },
      description: "WordPress site options to define"
    },
    login: {
      anyOf: [
        { type: "boolean" },
        {
          type: "object",
          properties: {
            username: { type: "string" },
            password: { type: "string" }
          },
          required: ["username", "password"],
          additionalProperties: !1
        }
      ],
      description: "User to log in as. If true, logs the user in as admin/password."
    },
    phpExtensionBundles: {
      deprecated: "No longer used. Feel free to remove it from your Blueprint."
    },
    steps: {
      type: "array",
      items: {
        anyOf: [
          { $ref: "#/definitions/StepDefinition" },
          { type: "string" },
          { not: {} },
          { type: "boolean", const: !1 },
          { type: "null" }
        ]
      },
      description: "The steps to run after every other operation in this Blueprint was executed."
    },
    $schema: { type: "string" }
  }
}, Tb = {
  enum: ["8.4", "8.3", "8.2", "8.1", "8.0", "7.4", "7.3", "7.2"]
}, Ob = {
  additionalProperties: { type: ["string", "boolean", "number"] }
}, Qu = Object.prototype.hasOwnProperty;
function Ee(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  const o = n;
  let l = !1;
  const p = n;
  if (n === n)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      let T;
      if (e.resource === void 0 && (T = "resource") || e.path === void 0 && (T = "path")) {
        const H = {
          instancePath: t,
          schemaPath: "#/definitions/VFSReference/required",
          keyword: "required",
          params: { missingProperty: T },
          message: "must have required property '" + T + "'"
        };
        s === null ? s = [H] : s.push(H), n++;
      } else {
        const H = n;
        for (const k in e)
          if (!(k === "resource" || k === "path")) {
            const A = {
              instancePath: t,
              schemaPath: "#/definitions/VFSReference/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: k },
              message: "must NOT have additional properties"
            };
            s === null ? s = [A] : s.push(A), n++;
            break;
          }
        if (H === n) {
          if (e.resource !== void 0) {
            let k = e.resource;
            const A = n;
            if (typeof k != "string") {
              const L = {
                instancePath: t + "/resource",
                schemaPath: "#/definitions/VFSReference/properties/resource/type",
                keyword: "type",
                params: { type: "string" },
                message: "must be string"
              };
              s === null ? s = [L] : s.push(L), n++;
            }
            if (k !== "vfs") {
              const L = {
                instancePath: t + "/resource",
                schemaPath: "#/definitions/VFSReference/properties/resource/const",
                keyword: "const",
                params: { allowedValue: "vfs" },
                message: "must be equal to constant"
              };
              s === null ? s = [L] : s.push(L), n++;
            }
            var m = A === n;
          } else
            var m = !0;
          if (m)
            if (e.path !== void 0) {
              const k = n;
              if (typeof e.path != "string") {
                const L = {
                  instancePath: t + "/path",
                  schemaPath: "#/definitions/VFSReference/properties/path/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                };
                s === null ? s = [L] : s.push(L), n++;
              }
              var m = k === n;
            } else
              var m = !0;
        }
      }
    } else {
      const T = {
        instancePath: t,
        schemaPath: "#/definitions/VFSReference/type",
        keyword: "type",
        params: { type: "object" },
        message: "must be object"
      };
      s === null ? s = [T] : s.push(T), n++;
    }
  var h = p === n;
  if (l = l || h, !l) {
    const T = n;
    if (n === n)
      if (e && typeof e == "object" && !Array.isArray(e)) {
        let A;
        if (e.resource === void 0 && (A = "resource") || e.name === void 0 && (A = "name") || e.contents === void 0 && (A = "contents")) {
          const L = {
            instancePath: t,
            schemaPath: "#/definitions/LiteralReference/required",
            keyword: "required",
            params: { missingProperty: A },
            message: "must have required property '" + A + "'"
          };
          s === null ? s = [L] : s.push(L), n++;
        } else {
          const L = n;
          for (const S in e)
            if (!(S === "resource" || S === "name" || S === "contents")) {
              const P = {
                instancePath: t,
                schemaPath: "#/definitions/LiteralReference/additionalProperties",
                keyword: "additionalProperties",
                params: { additionalProperty: S },
                message: "must NOT have additional properties"
              };
              s === null ? s = [P] : s.push(P), n++;
              break;
            }
          if (L === n) {
            if (e.resource !== void 0) {
              let S = e.resource;
              const P = n;
              if (typeof S != "string") {
                const I = {
                  instancePath: t + "/resource",
                  schemaPath: "#/definitions/LiteralReference/properties/resource/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                };
                s === null ? s = [I] : s.push(I), n++;
              }
              if (S !== "literal") {
                const I = {
                  instancePath: t + "/resource",
                  schemaPath: "#/definitions/LiteralReference/properties/resource/const",
                  keyword: "const",
                  params: { allowedValue: "literal" },
                  message: "must be equal to constant"
                };
                s === null ? s = [I] : s.push(I), n++;
              }
              var g = P === n;
            } else
              var g = !0;
            if (g) {
              if (e.name !== void 0) {
                const S = n;
                if (typeof e.name != "string") {
                  const I = {
                    instancePath: t + "/name",
                    schemaPath: "#/definitions/LiteralReference/properties/name/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  };
                  s === null ? s = [I] : s.push(I), n++;
                }
                var g = S === n;
              } else
                var g = !0;
              if (g)
                if (e.contents !== void 0) {
                  let S = e.contents;
                  const P = n, I = n;
                  let $ = !1;
                  const N = n;
                  if (typeof S != "string") {
                    const M = {
                      instancePath: t + "/contents",
                      schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/0/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    };
                    s === null ? s = [M] : s.push(M), n++;
                  }
                  var R = N === n;
                  if ($ = $ || R, !$) {
                    const M = n;
                    if (n === M)
                      if (S && typeof S == "object" && !Array.isArray(S)) {
                        let z;
                        if (S.BYTES_PER_ELEMENT === void 0 && (z = "BYTES_PER_ELEMENT") || S.buffer === void 0 && (z = "buffer") || S.byteLength === void 0 && (z = "byteLength") || S.byteOffset === void 0 && (z = "byteOffset") || S.length === void 0 && (z = "length")) {
                          const se = {
                            instancePath: t + "/contents",
                            schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/required",
                            keyword: "required",
                            params: {
                              missingProperty: z
                            },
                            message: "must have required property '" + z + "'"
                          };
                          s === null ? s = [se] : s.push(se), n++;
                        } else {
                          const se = n;
                          for (const G in S)
                            if (!(G === "BYTES_PER_ELEMENT" || G === "buffer" || G === "byteLength" || G === "byteOffset" || G === "length")) {
                              let Q = S[G];
                              const ee = n;
                              if (!(typeof Q == "number" && isFinite(
                                Q
                              ))) {
                                const V = {
                                  instancePath: t + "/contents/" + G.replace(
                                    /~/g,
                                    "~0"
                                  ).replace(
                                    /\//g,
                                    "~1"
                                  ),
                                  schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/additionalProperties/type",
                                  keyword: "type",
                                  params: {
                                    type: "number"
                                  },
                                  message: "must be number"
                                };
                                s === null ? s = [
                                  V
                                ] : s.push(
                                  V
                                ), n++;
                              }
                              var y = ee === n;
                              if (!y)
                                break;
                            }
                          if (se === n) {
                            if (S.BYTES_PER_ELEMENT !== void 0) {
                              let G = S.BYTES_PER_ELEMENT;
                              const Q = n;
                              if (!(typeof G == "number" && isFinite(
                                G
                              ))) {
                                const ee = {
                                  instancePath: t + "/contents/BYTES_PER_ELEMENT",
                                  schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/properties/BYTES_PER_ELEMENT/type",
                                  keyword: "type",
                                  params: {
                                    type: "number"
                                  },
                                  message: "must be number"
                                };
                                s === null ? s = [
                                  ee
                                ] : s.push(
                                  ee
                                ), n++;
                              }
                              var _ = Q === n;
                            } else
                              var _ = !0;
                            if (_) {
                              if (S.buffer !== void 0) {
                                let G = S.buffer;
                                const Q = n;
                                if (n === Q)
                                  if (G && typeof G == "object" && !Array.isArray(
                                    G
                                  )) {
                                    let V;
                                    if (G.byteLength === void 0 && (V = "byteLength")) {
                                      const fe = {
                                        instancePath: t + "/contents/buffer",
                                        schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/properties/buffer/required",
                                        keyword: "required",
                                        params: {
                                          missingProperty: V
                                        },
                                        message: "must have required property '" + V + "'"
                                      };
                                      s === null ? s = [
                                        fe
                                      ] : s.push(
                                        fe
                                      ), n++;
                                    } else {
                                      const fe = n;
                                      for (const ie in G)
                                        if (ie !== "byteLength") {
                                          const ae = {
                                            instancePath: t + "/contents/buffer",
                                            schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/properties/buffer/additionalProperties",
                                            keyword: "additionalProperties",
                                            params: {
                                              additionalProperty: ie
                                            },
                                            message: "must NOT have additional properties"
                                          };
                                          s === null ? s = [
                                            ae
                                          ] : s.push(
                                            ae
                                          ), n++;
                                          break;
                                        }
                                      if (fe === n && G.byteLength !== void 0) {
                                        let ie = G.byteLength;
                                        if (!(typeof ie == "number" && isFinite(
                                          ie
                                        ))) {
                                          const ae = {
                                            instancePath: t + "/contents/buffer/byteLength",
                                            schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/properties/buffer/properties/byteLength/type",
                                            keyword: "type",
                                            params: {
                                              type: "number"
                                            },
                                            message: "must be number"
                                          };
                                          s === null ? s = [
                                            ae
                                          ] : s.push(
                                            ae
                                          ), n++;
                                        }
                                      }
                                    }
                                  } else {
                                    const V = {
                                      instancePath: t + "/contents/buffer",
                                      schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/properties/buffer/type",
                                      keyword: "type",
                                      params: {
                                        type: "object"
                                      },
                                      message: "must be object"
                                    };
                                    s === null ? s = [
                                      V
                                    ] : s.push(
                                      V
                                    ), n++;
                                  }
                                var _ = Q === n;
                              } else
                                var _ = !0;
                              if (_) {
                                if (S.byteLength !== void 0) {
                                  let G = S.byteLength;
                                  const Q = n;
                                  if (!(typeof G == "number" && isFinite(
                                    G
                                  ))) {
                                    const V = {
                                      instancePath: t + "/contents/byteLength",
                                      schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/properties/byteLength/type",
                                      keyword: "type",
                                      params: {
                                        type: "number"
                                      },
                                      message: "must be number"
                                    };
                                    s === null ? s = [
                                      V
                                    ] : s.push(
                                      V
                                    ), n++;
                                  }
                                  var _ = Q === n;
                                } else
                                  var _ = !0;
                                if (_) {
                                  if (S.byteOffset !== void 0) {
                                    let G = S.byteOffset;
                                    const Q = n;
                                    if (!(typeof G == "number" && isFinite(
                                      G
                                    ))) {
                                      const V = {
                                        instancePath: t + "/contents/byteOffset",
                                        schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/properties/byteOffset/type",
                                        keyword: "type",
                                        params: {
                                          type: "number"
                                        },
                                        message: "must be number"
                                      };
                                      s === null ? s = [
                                        V
                                      ] : s.push(
                                        V
                                      ), n++;
                                    }
                                    var _ = Q === n;
                                  } else
                                    var _ = !0;
                                  if (_)
                                    if (S.length !== void 0) {
                                      let G = S.length;
                                      const Q = n;
                                      if (!(typeof G == "number" && isFinite(
                                        G
                                      ))) {
                                        const V = {
                                          instancePath: t + "/contents/length",
                                          schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/properties/length/type",
                                          keyword: "type",
                                          params: {
                                            type: "number"
                                          },
                                          message: "must be number"
                                        };
                                        s === null ? s = [
                                          V
                                        ] : s.push(
                                          V
                                        ), n++;
                                      }
                                      var _ = Q === n;
                                    } else
                                      var _ = !0;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        const z = {
                          instancePath: t + "/contents",
                          schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf/1/type",
                          keyword: "type",
                          params: { type: "object" },
                          message: "must be object"
                        };
                        s === null ? s = [z] : s.push(z), n++;
                      }
                    var R = M === n;
                    $ = $ || R;
                  }
                  if ($)
                    n = I, s !== null && (I ? s.length = I : s = null);
                  else {
                    const M = {
                      instancePath: t + "/contents",
                      schemaPath: "#/definitions/LiteralReference/properties/contents/anyOf",
                      keyword: "anyOf",
                      params: {},
                      message: "must match a schema in anyOf"
                    };
                    s === null ? s = [M] : s.push(M), n++;
                  }
                  var g = P === n;
                } else
                  var g = !0;
            }
          }
        }
      } else {
        const A = {
          instancePath: t,
          schemaPath: "#/definitions/LiteralReference/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        };
        s === null ? s = [A] : s.push(A), n++;
      }
    var h = T === n;
    if (l = l || h, !l) {
      const A = n;
      if (n === n)
        if (e && typeof e == "object" && !Array.isArray(e)) {
          let P;
          if (e.resource === void 0 && (P = "resource") || e.slug === void 0 && (P = "slug")) {
            const I = {
              instancePath: t,
              schemaPath: "#/definitions/CoreThemeReference/required",
              keyword: "required",
              params: { missingProperty: P },
              message: "must have required property '" + P + "'"
            };
            s === null ? s = [I] : s.push(I), n++;
          } else {
            const I = n;
            for (const $ in e)
              if (!($ === "resource" || $ === "slug")) {
                const N = {
                  instancePath: t,
                  schemaPath: "#/definitions/CoreThemeReference/additionalProperties",
                  keyword: "additionalProperties",
                  params: { additionalProperty: $ },
                  message: "must NOT have additional properties"
                };
                s === null ? s = [N] : s.push(N), n++;
                break;
              }
            if (I === n) {
              if (e.resource !== void 0) {
                let $ = e.resource;
                const N = n;
                if (typeof $ != "string") {
                  const U = {
                    instancePath: t + "/resource",
                    schemaPath: "#/definitions/CoreThemeReference/properties/resource/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  };
                  s === null ? s = [U] : s.push(U), n++;
                }
                if ($ !== "wordpress.org/themes") {
                  const U = {
                    instancePath: t + "/resource",
                    schemaPath: "#/definitions/CoreThemeReference/properties/resource/const",
                    keyword: "const",
                    params: {
                      allowedValue: "wordpress.org/themes"
                    },
                    message: "must be equal to constant"
                  };
                  s === null ? s = [U] : s.push(U), n++;
                }
                var w = N === n;
              } else
                var w = !0;
              if (w)
                if (e.slug !== void 0) {
                  const $ = n;
                  if (typeof e.slug != "string") {
                    const U = {
                      instancePath: t + "/slug",
                      schemaPath: "#/definitions/CoreThemeReference/properties/slug/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    };
                    s === null ? s = [U] : s.push(U), n++;
                  }
                  var w = $ === n;
                } else
                  var w = !0;
            }
          }
        } else {
          const P = {
            instancePath: t,
            schemaPath: "#/definitions/CoreThemeReference/type",
            keyword: "type",
            params: { type: "object" },
            message: "must be object"
          };
          s === null ? s = [P] : s.push(P), n++;
        }
      var h = A === n;
      if (l = l || h, !l) {
        const P = n;
        if (n === n)
          if (e && typeof e == "object" && !Array.isArray(e)) {
            let N;
            if (e.resource === void 0 && (N = "resource") || e.slug === void 0 && (N = "slug")) {
              const U = {
                instancePath: t,
                schemaPath: "#/definitions/CorePluginReference/required",
                keyword: "required",
                params: { missingProperty: N },
                message: "must have required property '" + N + "'"
              };
              s === null ? s = [U] : s.push(U), n++;
            } else {
              const U = n;
              for (const M in e)
                if (!(M === "resource" || M === "slug")) {
                  const Z = {
                    instancePath: t,
                    schemaPath: "#/definitions/CorePluginReference/additionalProperties",
                    keyword: "additionalProperties",
                    params: { additionalProperty: M },
                    message: "must NOT have additional properties"
                  };
                  s === null ? s = [Z] : s.push(Z), n++;
                  break;
                }
              if (U === n) {
                if (e.resource !== void 0) {
                  let M = e.resource;
                  const Z = n;
                  if (typeof M != "string") {
                    const z = {
                      instancePath: t + "/resource",
                      schemaPath: "#/definitions/CorePluginReference/properties/resource/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    };
                    s === null ? s = [z] : s.push(z), n++;
                  }
                  if (M !== "wordpress.org/plugins") {
                    const z = {
                      instancePath: t + "/resource",
                      schemaPath: "#/definitions/CorePluginReference/properties/resource/const",
                      keyword: "const",
                      params: {
                        allowedValue: "wordpress.org/plugins"
                      },
                      message: "must be equal to constant"
                    };
                    s === null ? s = [z] : s.push(z), n++;
                  }
                  var C = Z === n;
                } else
                  var C = !0;
                if (C)
                  if (e.slug !== void 0) {
                    const M = n;
                    if (typeof e.slug != "string") {
                      const z = {
                        instancePath: t + "/slug",
                        schemaPath: "#/definitions/CorePluginReference/properties/slug/type",
                        keyword: "type",
                        params: { type: "string" },
                        message: "must be string"
                      };
                      s === null ? s = [z] : s.push(z), n++;
                    }
                    var C = M === n;
                  } else
                    var C = !0;
              }
            }
          } else {
            const N = {
              instancePath: t,
              schemaPath: "#/definitions/CorePluginReference/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object"
            };
            s === null ? s = [N] : s.push(N), n++;
          }
        var h = P === n;
        if (l = l || h, !l) {
          const N = n;
          if (n === n)
            if (e && typeof e == "object" && !Array.isArray(e)) {
              let Z;
              if (e.resource === void 0 && (Z = "resource") || e.url === void 0 && (Z = "url")) {
                const z = {
                  instancePath: t,
                  schemaPath: "#/definitions/UrlReference/required",
                  keyword: "required",
                  params: { missingProperty: Z },
                  message: "must have required property '" + Z + "'"
                };
                s === null ? s = [z] : s.push(z), n++;
              } else {
                const z = n;
                for (const se in e)
                  if (!(se === "resource" || se === "url" || se === "caption")) {
                    const G = {
                      instancePath: t,
                      schemaPath: "#/definitions/UrlReference/additionalProperties",
                      keyword: "additionalProperties",
                      params: {
                        additionalProperty: se
                      },
                      message: "must NOT have additional properties"
                    };
                    s === null ? s = [G] : s.push(G), n++;
                    break;
                  }
                if (z === n) {
                  if (e.resource !== void 0) {
                    let se = e.resource;
                    const G = n;
                    if (typeof se != "string") {
                      const Q = {
                        instancePath: t + "/resource",
                        schemaPath: "#/definitions/UrlReference/properties/resource/type",
                        keyword: "type",
                        params: { type: "string" },
                        message: "must be string"
                      };
                      s === null ? s = [Q] : s.push(Q), n++;
                    }
                    if (se !== "url") {
                      const Q = {
                        instancePath: t + "/resource",
                        schemaPath: "#/definitions/UrlReference/properties/resource/const",
                        keyword: "const",
                        params: { allowedValue: "url" },
                        message: "must be equal to constant"
                      };
                      s === null ? s = [Q] : s.push(Q), n++;
                    }
                    var E = G === n;
                  } else
                    var E = !0;
                  if (E) {
                    if (e.url !== void 0) {
                      const se = n;
                      if (typeof e.url != "string") {
                        const Q = {
                          instancePath: t + "/url",
                          schemaPath: "#/definitions/UrlReference/properties/url/type",
                          keyword: "type",
                          params: { type: "string" },
                          message: "must be string"
                        };
                        s === null ? s = [Q] : s.push(Q), n++;
                      }
                      var E = se === n;
                    } else
                      var E = !0;
                    if (E)
                      if (e.caption !== void 0) {
                        const se = n;
                        if (typeof e.caption != "string") {
                          const Q = {
                            instancePath: t + "/caption",
                            schemaPath: "#/definitions/UrlReference/properties/caption/type",
                            keyword: "type",
                            params: {
                              type: "string"
                            },
                            message: "must be string"
                          };
                          s === null ? s = [Q] : s.push(Q), n++;
                        }
                        var E = se === n;
                      } else
                        var E = !0;
                  }
                }
              }
            } else {
              const Z = {
                instancePath: t,
                schemaPath: "#/definitions/UrlReference/type",
                keyword: "type",
                params: { type: "object" },
                message: "must be object"
              };
              s === null ? s = [Z] : s.push(Z), n++;
            }
          var h = N === n;
          if (l = l || h, !l) {
            const Z = n;
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let G;
                if (e.resource === void 0 && (G = "resource") || e.path === void 0 && (G = "path")) {
                  const Q = {
                    instancePath: t,
                    schemaPath: "#/definitions/BundledReference/required",
                    keyword: "required",
                    params: { missingProperty: G },
                    message: "must have required property '" + G + "'"
                  };
                  s === null ? s = [Q] : s.push(Q), n++;
                } else {
                  const Q = n;
                  for (const ee in e)
                    if (!(ee === "resource" || ee === "path")) {
                      const V = {
                        instancePath: t,
                        schemaPath: "#/definitions/BundledReference/additionalProperties",
                        keyword: "additionalProperties",
                        params: {
                          additionalProperty: ee
                        },
                        message: "must NOT have additional properties"
                      };
                      s === null ? s = [V] : s.push(V), n++;
                      break;
                    }
                  if (Q === n) {
                    if (e.resource !== void 0) {
                      let ee = e.resource;
                      const V = n;
                      if (typeof ee != "string") {
                        const fe = {
                          instancePath: t + "/resource",
                          schemaPath: "#/definitions/BundledReference/properties/resource/type",
                          keyword: "type",
                          params: { type: "string" },
                          message: "must be string"
                        };
                        s === null ? s = [fe] : s.push(fe), n++;
                      }
                      if (ee !== "bundled") {
                        const fe = {
                          instancePath: t + "/resource",
                          schemaPath: "#/definitions/BundledReference/properties/resource/const",
                          keyword: "const",
                          params: {
                            allowedValue: "bundled"
                          },
                          message: "must be equal to constant"
                        };
                        s === null ? s = [fe] : s.push(fe), n++;
                      }
                      var D = V === n;
                    } else
                      var D = !0;
                    if (D)
                      if (e.path !== void 0) {
                        const ee = n;
                        if (typeof e.path != "string") {
                          const fe = {
                            instancePath: t + "/path",
                            schemaPath: "#/definitions/BundledReference/properties/path/type",
                            keyword: "type",
                            params: {
                              type: "string"
                            },
                            message: "must be string"
                          };
                          s === null ? s = [fe] : s.push(fe), n++;
                        }
                        var D = ee === n;
                      } else
                        var D = !0;
                  }
                }
              } else {
                const G = {
                  instancePath: t,
                  schemaPath: "#/definitions/BundledReference/type",
                  keyword: "type",
                  params: { type: "object" },
                  message: "must be object"
                };
                s === null ? s = [G] : s.push(G), n++;
              }
            var h = Z === n;
            l = l || h;
          }
        }
      }
    }
  }
  if (l)
    n = o, s !== null && (o ? s.length = o : s = null);
  else {
    const T = {
      instancePath: t,
      schemaPath: "#/anyOf",
      keyword: "anyOf",
      params: {},
      message: "must match a schema in anyOf"
    };
    return s === null ? s = [T] : s.push(T), n++, Ee.errors = s, !1;
  }
  return Ee.errors = s, n === 0;
}
const Es = {
  oneOf: [
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "activatePlugin" },
        pluginPath: {
          type: "string",
          description: "Path to the plugin directory as absolute path (/wordpress/wp-content/plugins/plugin-name); or the plugin entry file relative to the plugins directory (plugin-name/plugin-name.php)."
        },
        pluginName: {
          type: "string",
          description: "Optional. Plugin name to display in the progress bar."
        }
      },
      required: ["pluginPath", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "activateTheme" },
        themeFolderName: {
          type: "string",
          description: "The name of the theme folder inside wp-content/themes/"
        }
      },
      required: ["step", "themeFolderName"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "cp" },
        fromPath: { type: "string", description: "Source path" },
        toPath: { type: "string", description: "Target path" }
      },
      required: ["fromPath", "step", "toPath"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "defineWpConfigConsts" },
        consts: {
          type: "object",
          additionalProperties: {},
          description: "The constants to define"
        },
        method: {
          type: "string",
          enum: ["rewrite-wp-config", "define-before-run"],
          description: `The method of defining the constants in wp-config.php. Possible values are:

- rewrite-wp-config: Default. Rewrites the wp-config.php file to                      explicitly call define() with the requested                      name and value. This method alters the file                      on the disk, but it doesn't conflict with                      existing define() calls in wp-config.php.

- define-before-run: Defines the constant before running the requested                      script. It doesn't alter any files on the disk, but                      constants defined this way may conflict with existing                      define() calls in wp-config.php.`
        },
        virtualize: {
          type: "boolean",
          deprecated: `This option is noop and will be removed in a future version.
This option is only kept in here to avoid breaking Blueprint schema validation
for existing apps using this option.`
        }
      },
      required: ["consts", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "defineSiteUrl" },
        siteUrl: { type: "string", description: "The URL" }
      },
      required: ["siteUrl", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "enableMultisite" },
        wpCliPath: { type: "string", description: "wp-cli.phar path" }
      },
      required: ["step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "importWxr" },
        file: {
          $ref: "#/definitions/FileReference",
          description: "The file to import"
        },
        importer: {
          type: "string",
          enum: ["data-liberation", "default"],
          description: "The importer to use. Possible values:\n\n- `default`: The importer from https://github.com/humanmade/WordPress-Importer\n- `data-liberation`: The experimental Data Liberation WXR importer developed at                      https://github.com/WordPress/wordpress-playground/issues/1894\n\nThis option is deprecated. The syntax will not be removed, but once the Data Liberation importer matures, it will become the only supported importer and the `importer` option will be ignored.",
          deprecated: !0
        }
      },
      required: ["file", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: {
          type: "string",
          const: "importThemeStarterContent",
          description: "The step identifier."
        },
        themeSlug: {
          type: "string",
          description: "The name of the theme to import content from."
        }
      },
      required: ["step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "importWordPressFiles" },
        wordPressFilesZip: {
          $ref: "#/definitions/FileReference",
          description: "The zip file containing the top-level WordPress files and directories."
        },
        pathInZip: {
          type: "string",
          description: "The path inside the zip file where the WordPress files are."
        }
      },
      required: ["step", "wordPressFilesZip"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        ifAlreadyInstalled: {
          type: "string",
          enum: ["overwrite", "skip", "error"],
          description: "What to do if the asset already exists."
        },
        step: {
          type: "string",
          const: "installPlugin",
          description: "The step identifier."
        },
        pluginData: {
          anyOf: [
            { $ref: "#/definitions/FileReference" },
            { $ref: "#/definitions/DirectoryReference" }
          ],
          description: "The plugin files to install. It can be a plugin zip file, a single PHP file, or a directory containing all the plugin files at its root."
        },
        pluginZipFile: {
          $ref: "#/definitions/FileReference",
          deprecated: ". Use 'pluginData' instead."
        },
        options: {
          $ref: "#/definitions/InstallPluginOptions",
          description: "Optional installation options."
        }
      },
      required: ["pluginData", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        ifAlreadyInstalled: {
          type: "string",
          enum: ["overwrite", "skip", "error"],
          description: "What to do if the asset already exists."
        },
        step: {
          type: "string",
          const: "installTheme",
          description: "The step identifier."
        },
        themeData: {
          anyOf: [
            { $ref: "#/definitions/FileReference" },
            { $ref: "#/definitions/DirectoryReference" }
          ],
          description: "The theme files to install. It can be either a theme zip file, or a directory containing all the theme files at its root."
        },
        themeZipFile: {
          $ref: "#/definitions/FileReference",
          deprecated: ". Use 'themeData' instead."
        },
        options: {
          $ref: "#/definitions/InstallThemeOptions",
          description: "Optional installation options."
        }
      },
      required: ["step", "themeData"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "login" },
        username: {
          type: "string",
          description: "The user to log in as. Defaults to 'admin'."
        },
        password: {
          type: "string",
          deprecated: `The password field is deprecated and will be removed in a future version.
Only the username field is required for user authentication.`
        }
      },
      required: ["step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "mkdir" },
        path: {
          type: "string",
          description: "The path of the directory you want to create"
        }
      },
      required: ["path", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "mv" },
        fromPath: { type: "string", description: "Source path" },
        toPath: { type: "string", description: "Target path" }
      },
      required: ["fromPath", "step", "toPath"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "resetData" }
      },
      required: ["step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "request" },
        request: {
          $ref: "#/definitions/PHPRequest",
          description: "Request details (See /wordpress-playground/api/universal/interface/PHPRequest)"
        }
      },
      required: ["request", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "rm" },
        path: { type: "string", description: "The path to remove" }
      },
      required: ["path", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "rmdir" },
        path: { type: "string", description: "The path to remove" }
      },
      required: ["path", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: {
          type: "string",
          const: "runPHP",
          description: "The step identifier."
        },
        code: {
          anyOf: [
            { type: "string" },
            {
              type: "object",
              properties: {
                filename: {
                  type: "string",
                  description: "This property is ignored during Blueprint v1 execution but exists so the same runPHP step structure can be used for Blueprints v1 and v2."
                },
                content: { type: "string" }
              },
              required: ["filename", "content"],
              additionalProperties: !1
            }
          ],
          description: "The PHP code to run."
        }
      },
      required: ["code", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "runPHPWithOptions" },
        options: {
          $ref: "#/definitions/PHPRunOptions",
          description: "Run options (See /wordpress-playground/api/universal/interface/PHPRunOptions/))"
        }
      },
      required: ["options", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "runWpInstallationWizard" },
        options: { $ref: "#/definitions/WordPressInstallationOptions" }
      },
      required: ["options", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: {
          type: "string",
          const: "runSql",
          description: "The step identifier."
        },
        sql: {
          $ref: "#/definitions/FileReference",
          description: "The SQL to run. Each non-empty line must contain a valid SQL query."
        }
      },
      required: ["sql", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: {
          type: "string",
          const: "setSiteOptions",
          description: 'The name of the step. Must be "setSiteOptions".'
        },
        options: {
          type: "object",
          additionalProperties: {},
          description: "The options to set on the site."
        }
      },
      required: ["options", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "unzip" },
        zipFile: {
          $ref: "#/definitions/FileReference",
          description: "The zip file to extract"
        },
        zipPath: {
          type: "string",
          description: "The path of the zip file to extract",
          deprecated: "Use zipFile instead."
        },
        extractToPath: {
          type: "string",
          description: "The path to extract the zip file to"
        }
      },
      required: ["extractToPath", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "updateUserMeta" },
        meta: {
          type: "object",
          additionalProperties: {},
          description: 'An object of user meta values to set, e.g. { "first_name": "John" }'
        },
        userId: { type: "number", description: "User ID" }
      },
      required: ["meta", "step", "userId"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "writeFile" },
        path: {
          type: "string",
          description: "The path of the file to write to"
        },
        data: {
          anyOf: [
            { $ref: "#/definitions/FileReference" },
            { type: "string" },
            {
              type: "object",
              properties: {
                BYTES_PER_ELEMENT: { type: "number" },
                buffer: {
                  type: "object",
                  properties: {
                    byteLength: { type: "number" }
                  },
                  required: ["byteLength"],
                  additionalProperties: !1
                },
                byteLength: { type: "number" },
                byteOffset: { type: "number" },
                length: { type: "number" }
              },
              required: [
                "BYTES_PER_ELEMENT",
                "buffer",
                "byteLength",
                "byteOffset",
                "length"
              ],
              additionalProperties: { type: "number" }
            }
          ],
          description: "The data to write"
        }
      },
      required: ["data", "path", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "writeFiles" },
        writeToPath: {
          type: "string",
          description: "The path of the file to write to"
        },
        filesTree: {
          $ref: "#/definitions/DirectoryReference",
          description: "The 'filesTree' defines the directory structure, supporting 'literal:directory' or 'git:directory' types. The 'name' represents the root directory, while 'files' is an object where keys are file paths, and values contain either file content as a string or nested objects for subdirectories."
        }
      },
      required: ["filesTree", "step", "writeToPath"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: {
          type: "string",
          const: "wp-cli",
          description: "The step identifier."
        },
        command: {
          anyOf: [
            { type: "string" },
            { type: "array", items: { type: "string" } }
          ],
          description: "The WP CLI command to run."
        },
        wpCliPath: { type: "string", description: "wp-cli.phar path" }
      },
      required: ["command", "step"]
    },
    {
      type: "object",
      additionalProperties: !1,
      properties: {
        progress: {
          type: "object",
          properties: {
            weight: { type: "number" },
            caption: { type: "string" }
          },
          additionalProperties: !1
        },
        step: { type: "string", const: "setSiteLanguage" },
        language: {
          type: "string",
          description: "The language to set, e.g. 'en_US'"
        }
      },
      required: ["language", "step"]
    }
  ]
}, Cb = {
  enum: ["branch", "tag", "commit", "refname"]
};
function st(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  if (e && typeof e == "object" && !Array.isArray(e)) {
    let l;
    if (e.resource === void 0 && (l = "resource") || e.url === void 0 && (l = "url") || e.ref === void 0 && (l = "ref"))
      return st.errors = [
        {
          instancePath: t,
          schemaPath: "#/required",
          keyword: "required",
          params: { missingProperty: l },
          message: "must have required property '" + l + "'"
        }
      ], !1;
    for (const p in e)
      if (!(p === "resource" || p === "url" || p === "ref" || p === "refType" || p === "path" || p === ".git"))
        return st.errors = [
          {
            instancePath: t,
            schemaPath: "#/additionalProperties",
            keyword: "additionalProperties",
            params: { additionalProperty: p },
            message: "must NOT have additional properties"
          }
        ], !1;
    {
      if (e.resource !== void 0) {
        let p = e.resource;
        const c = n;
        if (typeof p != "string")
          return st.errors = [
            {
              instancePath: t + "/resource",
              schemaPath: "#/properties/resource/type",
              keyword: "type",
              params: { type: "string" },
              message: "must be string"
            }
          ], !1;
        if (p !== "git:directory")
          return st.errors = [
            {
              instancePath: t + "/resource",
              schemaPath: "#/properties/resource/const",
              keyword: "const",
              params: { allowedValue: "git:directory" },
              message: "must be equal to constant"
            }
          ], !1;
        var o = c === n;
      } else
        var o = !0;
      if (o) {
        if (e.url !== void 0) {
          const p = n;
          if (typeof e.url != "string")
            return st.errors = [
              {
                instancePath: t + "/url",
                schemaPath: "#/properties/url/type",
                keyword: "type",
                params: { type: "string" },
                message: "must be string"
              }
            ], !1;
          var o = p === n;
        } else
          var o = !0;
        if (o) {
          if (e.ref !== void 0) {
            const p = n;
            if (typeof e.ref != "string")
              return st.errors = [
                {
                  instancePath: t + "/ref",
                  schemaPath: "#/properties/ref/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ], !1;
            var o = p === n;
          } else
            var o = !0;
          if (o) {
            if (e.refType !== void 0) {
              let p = e.refType;
              const c = n;
              if (typeof p != "string")
                return st.errors = [
                  {
                    instancePath: t + "/refType",
                    schemaPath: "#/definitions/GitDirectoryRefType/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  }
                ], !1;
              if (!(p === "branch" || p === "tag" || p === "commit" || p === "refname"))
                return st.errors = [
                  {
                    instancePath: t + "/refType",
                    schemaPath: "#/definitions/GitDirectoryRefType/enum",
                    keyword: "enum",
                    params: {
                      allowedValues: Cb.enum
                    },
                    message: "must be equal to one of the allowed values"
                  }
                ], !1;
              var o = c === n;
            } else
              var o = !0;
            if (o) {
              if (e.path !== void 0) {
                const p = n;
                if (typeof e.path != "string")
                  return st.errors = [
                    {
                      instancePath: t + "/path",
                      schemaPath: "#/properties/path/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    }
                  ], !1;
                var o = p === n;
              } else
                var o = !0;
              if (o)
                if (e[".git"] !== void 0) {
                  const p = n;
                  if (typeof e[".git"] != "boolean")
                    return st.errors = [
                      {
                        instancePath: t + "/.git",
                        schemaPath: "#/properties/.git/type",
                        keyword: "type",
                        params: {
                          type: "boolean"
                        },
                        message: "must be boolean"
                      }
                    ], !1;
                  var o = p === n;
                } else
                  var o = !0;
            }
          }
        }
      }
    }
  } else
    return st.errors = [
      {
        instancePath: t,
        schemaPath: "#/type",
        keyword: "type",
        params: { type: "object" },
        message: "must be object"
      }
    ], !1;
  return st.errors = s, n === 0;
}
const Lb = {
  additionalProperties: {
    anyOf: [
      { $ref: "#/definitions/FileTree" },
      { type: ["object", "string"] }
    ]
  }
}, Aa = { validate: $r };
function $r(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  if (n === 0)
    if (e && typeof e == "object" && !Array.isArray(e))
      for (const p in e) {
        let c = e[p];
        const m = n, h = n;
        let g = !1;
        const R = n;
        Aa.validate(c, {
          instancePath: t + "/" + p.replace(/~/g, "~0").replace(/\//g, "~1"),
          parentData: e,
          parentDataProperty: p,
          rootData: a
        }) || (s = s === null ? Aa.validate.errors : s.concat(Aa.validate.errors), n = s.length);
        var o = R === n;
        if (g = g || o, !g) {
          const y = n;
          if (!(c && typeof c == "object" && !Array.isArray(c)) && typeof c != "string") {
            const w = {
              instancePath: t + "/" + p.replace(/~/g, "~0").replace(/\//g, "~1"),
              schemaPath: "#/additionalProperties/anyOf/1/type",
              keyword: "type",
              params: {
                type: Lb.additionalProperties.anyOf[1].type
              },
              message: "must be object,string"
            };
            s === null ? s = [w] : s.push(w), n++;
          }
          var o = y === n;
          g = g || o;
        }
        if (g)
          n = h, s !== null && (h ? s.length = h : s = null);
        else {
          const y = {
            instancePath: t + "/" + p.replace(/~/g, "~0").replace(/\//g, "~1"),
            schemaPath: "#/additionalProperties/anyOf",
            keyword: "anyOf",
            params: {},
            message: "must match a schema in anyOf"
          };
          return s === null ? s = [y] : s.push(y), n++, $r.errors = s, !1;
        }
        var l = m === n;
        if (!l)
          break;
      }
    else
      return $r.errors = [
        {
          instancePath: t,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ], !1;
  return $r.errors = s, n === 0;
}
function Mt(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  if (n === 0)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      let l;
      if (e.files === void 0 && (l = "files") || e.name === void 0 && (l = "name") || e.resource === void 0 && (l = "resource"))
        return Mt.errors = [
          {
            instancePath: t,
            schemaPath: "#/required",
            keyword: "required",
            params: { missingProperty: l },
            message: "must have required property '" + l + "'"
          }
        ], !1;
      {
        const p = n;
        for (const c in e)
          if (!(c === "resource" || c === "files" || c === "name"))
            return Mt.errors = [
              {
                instancePath: t,
                schemaPath: "#/additionalProperties",
                keyword: "additionalProperties",
                params: { additionalProperty: c },
                message: "must NOT have additional properties"
              }
            ], !1;
        if (p === n) {
          if (e.resource !== void 0) {
            let c = e.resource;
            const m = n;
            if (typeof c != "string")
              return Mt.errors = [
                {
                  instancePath: t + "/resource",
                  schemaPath: "#/properties/resource/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ], !1;
            if (c !== "literal:directory")
              return Mt.errors = [
                {
                  instancePath: t + "/resource",
                  schemaPath: "#/properties/resource/const",
                  keyword: "const",
                  params: {
                    allowedValue: "literal:directory"
                  },
                  message: "must be equal to constant"
                }
              ], !1;
            var o = m === n;
          } else
            var o = !0;
          if (o) {
            if (e.files !== void 0) {
              const c = n;
              $r(e.files, {
                instancePath: t + "/files",
                parentData: e,
                parentDataProperty: "files",
                rootData: a
              }) || (s = s === null ? $r.errors : s.concat($r.errors), n = s.length);
              var o = c === n;
            } else
              var o = !0;
            if (o)
              if (e.name !== void 0) {
                const c = n;
                if (typeof e.name != "string")
                  return Mt.errors = [
                    {
                      instancePath: t + "/name",
                      schemaPath: "#/properties/name/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    }
                  ], !1;
                var o = c === n;
              } else
                var o = !0;
          }
        }
      }
    } else
      return Mt.errors = [
        {
          instancePath: t,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ], !1;
  return Mt.errors = s, n === 0;
}
function It(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  const o = n;
  let l = !1;
  const p = n;
  st(e, {
    instancePath: t,
    parentData: r,
    parentDataProperty: i,
    rootData: a
  }) || (s = s === null ? st.errors : s.concat(st.errors), n = s.length);
  var c = p === n;
  if (l = l || c, !l) {
    const m = n;
    Mt(e, {
      instancePath: t,
      parentData: r,
      parentDataProperty: i,
      rootData: a
    }) || (s = s === null ? Mt.errors : s.concat(Mt.errors), n = s.length);
    var c = m === n;
    l = l || c;
  }
  if (l)
    n = o, s !== null && (o ? s.length = o : s = null);
  else {
    const m = {
      instancePath: t,
      schemaPath: "#/anyOf",
      keyword: "anyOf",
      params: {},
      message: "must match a schema in anyOf"
    };
    return s === null ? s = [m] : s.push(m), n++, It.errors = s, !1;
  }
  return It.errors = s, n === 0;
}
const ed = {
  enum: ["GET", "POST", "HEAD", "OPTIONS", "PATCH", "PUT", "DELETE"]
};
function wt(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  if (n === 0)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      let w;
      if (e.url === void 0 && (w = "url"))
        return wt.errors = [
          {
            instancePath: t,
            schemaPath: "#/required",
            keyword: "required",
            params: { missingProperty: w },
            message: "must have required property '" + w + "'"
          }
        ], !1;
      {
        const C = n;
        for (const E in e)
          if (!(E === "method" || E === "url" || E === "headers" || E === "body"))
            return wt.errors = [
              {
                instancePath: t,
                schemaPath: "#/additionalProperties",
                keyword: "additionalProperties",
                params: { additionalProperty: E },
                message: "must NOT have additional properties"
              }
            ], !1;
        if (C === n) {
          if (e.method !== void 0) {
            let E = e.method;
            const D = n;
            if (typeof E != "string")
              return wt.errors = [
                {
                  instancePath: t + "/method",
                  schemaPath: "#/definitions/HTTPMethod/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ], !1;
            if (!(E === "GET" || E === "POST" || E === "HEAD" || E === "OPTIONS" || E === "PATCH" || E === "PUT" || E === "DELETE"))
              return wt.errors = [
                {
                  instancePath: t + "/method",
                  schemaPath: "#/definitions/HTTPMethod/enum",
                  keyword: "enum",
                  params: { allowedValues: ed.enum },
                  message: "must be equal to one of the allowed values"
                }
              ], !1;
            var o = D === n;
          } else
            var o = !0;
          if (o) {
            if (e.url !== void 0) {
              const E = n;
              if (typeof e.url != "string")
                return wt.errors = [
                  {
                    instancePath: t + "/url",
                    schemaPath: "#/properties/url/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  }
                ], !1;
              var o = E === n;
            } else
              var o = !0;
            if (o) {
              if (e.headers !== void 0) {
                let E = e.headers;
                const D = n;
                if (n === n)
                  if (E && typeof E == "object" && !Array.isArray(E))
                    for (const k in E) {
                      const A = n;
                      if (typeof E[k] != "string")
                        return wt.errors = [
                          {
                            instancePath: t + "/headers/" + k.replace(
                              /~/g,
                              "~0"
                            ).replace(
                              /\//g,
                              "~1"
                            ),
                            schemaPath: "#/definitions/PHPRequestHeaders/additionalProperties/type",
                            keyword: "type",
                            params: {
                              type: "string"
                            },
                            message: "must be string"
                          }
                        ], !1;
                      var l = A === n;
                      if (!l)
                        break;
                    }
                  else
                    return wt.errors = [
                      {
                        instancePath: t + "/headers",
                        schemaPath: "#/definitions/PHPRequestHeaders/type",
                        keyword: "type",
                        params: { type: "object" },
                        message: "must be object"
                      }
                    ], !1;
                var o = D === n;
              } else
                var o = !0;
              if (o)
                if (e.body !== void 0) {
                  let E = e.body;
                  const D = n, T = n;
                  let H = !1;
                  const k = n;
                  if (typeof E != "string") {
                    const L = {
                      instancePath: t + "/body",
                      schemaPath: "#/properties/body/anyOf/0/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    };
                    s === null ? s = [L] : s.push(L), n++;
                  }
                  var p = k === n;
                  if (H = H || p, !H) {
                    const L = n;
                    if (n === L)
                      if (E && typeof E == "object" && !Array.isArray(E)) {
                        let P;
                        if (E.BYTES_PER_ELEMENT === void 0 && (P = "BYTES_PER_ELEMENT") || E.buffer === void 0 && (P = "buffer") || E.byteLength === void 0 && (P = "byteLength") || E.byteOffset === void 0 && (P = "byteOffset") || E.length === void 0 && (P = "length")) {
                          const I = {
                            instancePath: t + "/body",
                            schemaPath: "#/properties/body/anyOf/1/required",
                            keyword: "required",
                            params: {
                              missingProperty: P
                            },
                            message: "must have required property '" + P + "'"
                          };
                          s === null ? s = [I] : s.push(I), n++;
                        } else {
                          const I = n;
                          for (const $ in E)
                            if (!($ === "BYTES_PER_ELEMENT" || $ === "buffer" || $ === "byteLength" || $ === "byteOffset" || $ === "length")) {
                              let N = E[$];
                              const U = n;
                              if (!(typeof N == "number" && isFinite(
                                N
                              ))) {
                                const M = {
                                  instancePath: t + "/body/" + $.replace(
                                    /~/g,
                                    "~0"
                                  ).replace(
                                    /\//g,
                                    "~1"
                                  ),
                                  schemaPath: "#/properties/body/anyOf/1/additionalProperties/type",
                                  keyword: "type",
                                  params: {
                                    type: "number"
                                  },
                                  message: "must be number"
                                };
                                s === null ? s = [
                                  M
                                ] : s.push(
                                  M
                                ), n++;
                              }
                              var c = U === n;
                              if (!c)
                                break;
                            }
                          if (I === n) {
                            if (E.BYTES_PER_ELEMENT !== void 0) {
                              let $ = E.BYTES_PER_ELEMENT;
                              const N = n;
                              if (!(typeof $ == "number" && isFinite(
                                $
                              ))) {
                                const U = {
                                  instancePath: t + "/body/BYTES_PER_ELEMENT",
                                  schemaPath: "#/properties/body/anyOf/1/properties/BYTES_PER_ELEMENT/type",
                                  keyword: "type",
                                  params: {
                                    type: "number"
                                  },
                                  message: "must be number"
                                };
                                s === null ? s = [
                                  U
                                ] : s.push(
                                  U
                                ), n++;
                              }
                              var m = N === n;
                            } else
                              var m = !0;
                            if (m) {
                              if (E.buffer !== void 0) {
                                let $ = E.buffer;
                                const N = n;
                                if (n === N)
                                  if ($ && typeof $ == "object" && !Array.isArray(
                                    $
                                  )) {
                                    let M;
                                    if ($.byteLength === void 0 && (M = "byteLength")) {
                                      const Z = {
                                        instancePath: t + "/body/buffer",
                                        schemaPath: "#/properties/body/anyOf/1/properties/buffer/required",
                                        keyword: "required",
                                        params: {
                                          missingProperty: M
                                        },
                                        message: "must have required property '" + M + "'"
                                      };
                                      s === null ? s = [
                                        Z
                                      ] : s.push(
                                        Z
                                      ), n++;
                                    } else {
                                      const Z = n;
                                      for (const z in $)
                                        if (z !== "byteLength") {
                                          const se = {
                                            instancePath: t + "/body/buffer",
                                            schemaPath: "#/properties/body/anyOf/1/properties/buffer/additionalProperties",
                                            keyword: "additionalProperties",
                                            params: {
                                              additionalProperty: z
                                            },
                                            message: "must NOT have additional properties"
                                          };
                                          s === null ? s = [
                                            se
                                          ] : s.push(
                                            se
                                          ), n++;
                                          break;
                                        }
                                      if (Z === n && $.byteLength !== void 0) {
                                        let z = $.byteLength;
                                        if (!(typeof z == "number" && isFinite(
                                          z
                                        ))) {
                                          const se = {
                                            instancePath: t + "/body/buffer/byteLength",
                                            schemaPath: "#/properties/body/anyOf/1/properties/buffer/properties/byteLength/type",
                                            keyword: "type",
                                            params: {
                                              type: "number"
                                            },
                                            message: "must be number"
                                          };
                                          s === null ? s = [
                                            se
                                          ] : s.push(
                                            se
                                          ), n++;
                                        }
                                      }
                                    }
                                  } else {
                                    const M = {
                                      instancePath: t + "/body/buffer",
                                      schemaPath: "#/properties/body/anyOf/1/properties/buffer/type",
                                      keyword: "type",
                                      params: {
                                        type: "object"
                                      },
                                      message: "must be object"
                                    };
                                    s === null ? s = [
                                      M
                                    ] : s.push(
                                      M
                                    ), n++;
                                  }
                                var m = N === n;
                              } else
                                var m = !0;
                              if (m) {
                                if (E.byteLength !== void 0) {
                                  let $ = E.byteLength;
                                  const N = n;
                                  if (!(typeof $ == "number" && isFinite(
                                    $
                                  ))) {
                                    const M = {
                                      instancePath: t + "/body/byteLength",
                                      schemaPath: "#/properties/body/anyOf/1/properties/byteLength/type",
                                      keyword: "type",
                                      params: {
                                        type: "number"
                                      },
                                      message: "must be number"
                                    };
                                    s === null ? s = [
                                      M
                                    ] : s.push(
                                      M
                                    ), n++;
                                  }
                                  var m = N === n;
                                } else
                                  var m = !0;
                                if (m) {
                                  if (E.byteOffset !== void 0) {
                                    let $ = E.byteOffset;
                                    const N = n;
                                    if (!(typeof $ == "number" && isFinite(
                                      $
                                    ))) {
                                      const M = {
                                        instancePath: t + "/body/byteOffset",
                                        schemaPath: "#/properties/body/anyOf/1/properties/byteOffset/type",
                                        keyword: "type",
                                        params: {
                                          type: "number"
                                        },
                                        message: "must be number"
                                      };
                                      s === null ? s = [
                                        M
                                      ] : s.push(
                                        M
                                      ), n++;
                                    }
                                    var m = N === n;
                                  } else
                                    var m = !0;
                                  if (m)
                                    if (E.length !== void 0) {
                                      let $ = E.length;
                                      const N = n;
                                      if (!(typeof $ == "number" && isFinite(
                                        $
                                      ))) {
                                        const M = {
                                          instancePath: t + "/body/length",
                                          schemaPath: "#/properties/body/anyOf/1/properties/length/type",
                                          keyword: "type",
                                          params: {
                                            type: "number"
                                          },
                                          message: "must be number"
                                        };
                                        s === null ? s = [
                                          M
                                        ] : s.push(
                                          M
                                        ), n++;
                                      }
                                      var m = N === n;
                                    } else
                                      var m = !0;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        const P = {
                          instancePath: t + "/body",
                          schemaPath: "#/properties/body/anyOf/1/type",
                          keyword: "type",
                          params: { type: "object" },
                          message: "must be object"
                        };
                        s === null ? s = [P] : s.push(P), n++;
                      }
                    var p = L === n;
                    if (H = H || p, !H) {
                      const P = n;
                      if (n === P)
                        if (E && typeof E == "object" && !Array.isArray(E))
                          for (const $ in E) {
                            let N = E[$];
                            const U = n, M = n;
                            let Z = !1;
                            const z = n;
                            if (typeof N != "string") {
                              const se = {
                                instancePath: t + "/body/" + $.replace(
                                  /~/g,
                                  "~0"
                                ).replace(
                                  /\//g,
                                  "~1"
                                ),
                                schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/0/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              };
                              s === null ? s = [
                                se
                              ] : s.push(
                                se
                              ), n++;
                            }
                            var h = z === n;
                            if (Z = Z || h, !Z) {
                              const se = n;
                              if (n === se)
                                if (N && typeof N == "object" && !Array.isArray(
                                  N
                                )) {
                                  let Q;
                                  if (N.BYTES_PER_ELEMENT === void 0 && (Q = "BYTES_PER_ELEMENT") || N.buffer === void 0 && (Q = "buffer") || N.byteLength === void 0 && (Q = "byteLength") || N.byteOffset === void 0 && (Q = "byteOffset") || N.length === void 0 && (Q = "length")) {
                                    const ee = {
                                      instancePath: t + "/body/" + $.replace(
                                        /~/g,
                                        "~0"
                                      ).replace(
                                        /\//g,
                                        "~1"
                                      ),
                                      schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/required",
                                      keyword: "required",
                                      params: {
                                        missingProperty: Q
                                      },
                                      message: "must have required property '" + Q + "'"
                                    };
                                    s === null ? s = [
                                      ee
                                    ] : s.push(
                                      ee
                                    ), n++;
                                  } else {
                                    const ee = n;
                                    for (const V in N)
                                      if (!(V === "BYTES_PER_ELEMENT" || V === "buffer" || V === "byteLength" || V === "byteOffset" || V === "length")) {
                                        let fe = N[V];
                                        const ie = n;
                                        if (!(typeof fe == "number" && isFinite(
                                          fe
                                        ))) {
                                          const ae = {
                                            instancePath: t + "/body/" + $.replace(
                                              /~/g,
                                              "~0"
                                            ).replace(
                                              /\//g,
                                              "~1"
                                            ) + "/" + V.replace(
                                              /~/g,
                                              "~0"
                                            ).replace(
                                              /\//g,
                                              "~1"
                                            ),
                                            schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/additionalProperties/type",
                                            keyword: "type",
                                            params: {
                                              type: "number"
                                            },
                                            message: "must be number"
                                          };
                                          s === null ? s = [
                                            ae
                                          ] : s.push(
                                            ae
                                          ), n++;
                                        }
                                        var g = ie === n;
                                        if (!g)
                                          break;
                                      }
                                    if (ee === n) {
                                      if (N.BYTES_PER_ELEMENT !== void 0) {
                                        let V = N.BYTES_PER_ELEMENT;
                                        const fe = n;
                                        if (!(typeof V == "number" && isFinite(
                                          V
                                        ))) {
                                          const ie = {
                                            instancePath: t + "/body/" + $.replace(
                                              /~/g,
                                              "~0"
                                            ).replace(
                                              /\//g,
                                              "~1"
                                            ) + "/BYTES_PER_ELEMENT",
                                            schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/properties/BYTES_PER_ELEMENT/type",
                                            keyword: "type",
                                            params: {
                                              type: "number"
                                            },
                                            message: "must be number"
                                          };
                                          s === null ? s = [
                                            ie
                                          ] : s.push(
                                            ie
                                          ), n++;
                                        }
                                        var R = fe === n;
                                      } else
                                        var R = !0;
                                      if (R) {
                                        if (N.buffer !== void 0) {
                                          let V = N.buffer;
                                          const fe = n;
                                          if (n === fe)
                                            if (V && typeof V == "object" && !Array.isArray(
                                              V
                                            )) {
                                              let ae;
                                              if (V.byteLength === void 0 && (ae = "byteLength")) {
                                                const Pe = {
                                                  instancePath: t + "/body/" + $.replace(
                                                    /~/g,
                                                    "~0"
                                                  ).replace(
                                                    /\//g,
                                                    "~1"
                                                  ) + "/buffer",
                                                  schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/properties/buffer/required",
                                                  keyword: "required",
                                                  params: {
                                                    missingProperty: ae
                                                  },
                                                  message: "must have required property '" + ae + "'"
                                                };
                                                s === null ? s = [
                                                  Pe
                                                ] : s.push(
                                                  Pe
                                                ), n++;
                                              } else {
                                                const Pe = n;
                                                for (const Oe in V)
                                                  if (Oe !== "byteLength") {
                                                    const Xe = {
                                                      instancePath: t + "/body/" + $.replace(
                                                        /~/g,
                                                        "~0"
                                                      ).replace(
                                                        /\//g,
                                                        "~1"
                                                      ) + "/buffer",
                                                      schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/properties/buffer/additionalProperties",
                                                      keyword: "additionalProperties",
                                                      params: {
                                                        additionalProperty: Oe
                                                      },
                                                      message: "must NOT have additional properties"
                                                    };
                                                    s === null ? s = [
                                                      Xe
                                                    ] : s.push(
                                                      Xe
                                                    ), n++;
                                                    break;
                                                  }
                                                if (Pe === n && V.byteLength !== void 0) {
                                                  let Oe = V.byteLength;
                                                  if (!(typeof Oe == "number" && isFinite(
                                                    Oe
                                                  ))) {
                                                    const Xe = {
                                                      instancePath: t + "/body/" + $.replace(
                                                        /~/g,
                                                        "~0"
                                                      ).replace(
                                                        /\//g,
                                                        "~1"
                                                      ) + "/buffer/byteLength",
                                                      schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/properties/buffer/properties/byteLength/type",
                                                      keyword: "type",
                                                      params: {
                                                        type: "number"
                                                      },
                                                      message: "must be number"
                                                    };
                                                    s === null ? s = [
                                                      Xe
                                                    ] : s.push(
                                                      Xe
                                                    ), n++;
                                                  }
                                                }
                                              }
                                            } else {
                                              const ae = {
                                                instancePath: t + "/body/" + $.replace(
                                                  /~/g,
                                                  "~0"
                                                ).replace(
                                                  /\//g,
                                                  "~1"
                                                ) + "/buffer",
                                                schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/properties/buffer/type",
                                                keyword: "type",
                                                params: {
                                                  type: "object"
                                                },
                                                message: "must be object"
                                              };
                                              s === null ? s = [
                                                ae
                                              ] : s.push(
                                                ae
                                              ), n++;
                                            }
                                          var R = fe === n;
                                        } else
                                          var R = !0;
                                        if (R) {
                                          if (N.byteLength !== void 0) {
                                            let V = N.byteLength;
                                            const fe = n;
                                            if (!(typeof V == "number" && isFinite(
                                              V
                                            ))) {
                                              const ae = {
                                                instancePath: t + "/body/" + $.replace(
                                                  /~/g,
                                                  "~0"
                                                ).replace(
                                                  /\//g,
                                                  "~1"
                                                ) + "/byteLength",
                                                schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/properties/byteLength/type",
                                                keyword: "type",
                                                params: {
                                                  type: "number"
                                                },
                                                message: "must be number"
                                              };
                                              s === null ? s = [
                                                ae
                                              ] : s.push(
                                                ae
                                              ), n++;
                                            }
                                            var R = fe === n;
                                          } else
                                            var R = !0;
                                          if (R) {
                                            if (N.byteOffset !== void 0) {
                                              let V = N.byteOffset;
                                              const fe = n;
                                              if (!(typeof V == "number" && isFinite(
                                                V
                                              ))) {
                                                const ae = {
                                                  instancePath: t + "/body/" + $.replace(
                                                    /~/g,
                                                    "~0"
                                                  ).replace(
                                                    /\//g,
                                                    "~1"
                                                  ) + "/byteOffset",
                                                  schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/properties/byteOffset/type",
                                                  keyword: "type",
                                                  params: {
                                                    type: "number"
                                                  },
                                                  message: "must be number"
                                                };
                                                s === null ? s = [
                                                  ae
                                                ] : s.push(
                                                  ae
                                                ), n++;
                                              }
                                              var R = fe === n;
                                            } else
                                              var R = !0;
                                            if (R)
                                              if (N.length !== void 0) {
                                                let V = N.length;
                                                const fe = n;
                                                if (!(typeof V == "number" && isFinite(
                                                  V
                                                ))) {
                                                  const ae = {
                                                    instancePath: t + "/body/" + $.replace(
                                                      /~/g,
                                                      "~0"
                                                    ).replace(
                                                      /\//g,
                                                      "~1"
                                                    ) + "/length",
                                                    schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/properties/length/type",
                                                    keyword: "type",
                                                    params: {
                                                      type: "number"
                                                    },
                                                    message: "must be number"
                                                  };
                                                  s === null ? s = [
                                                    ae
                                                  ] : s.push(
                                                    ae
                                                  ), n++;
                                                }
                                                var R = fe === n;
                                              } else
                                                var R = !0;
                                          }
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  const Q = {
                                    instancePath: t + "/body/" + $.replace(
                                      /~/g,
                                      "~0"
                                    ).replace(
                                      /\//g,
                                      "~1"
                                    ),
                                    schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/1/type",
                                    keyword: "type",
                                    params: {
                                      type: "object"
                                    },
                                    message: "must be object"
                                  };
                                  s === null ? s = [
                                    Q
                                  ] : s.push(
                                    Q
                                  ), n++;
                                }
                              var h = se === n;
                              if (Z = Z || h, !Z) {
                                const Q = n;
                                if (n === Q)
                                  if (N && typeof N == "object" && !Array.isArray(
                                    N
                                  )) {
                                    let V;
                                    if (N.lastModified === void 0 && (V = "lastModified") || N.name === void 0 && (V = "name") || N.size === void 0 && (V = "size") || N.type === void 0 && (V = "type") || N.webkitRelativePath === void 0 && (V = "webkitRelativePath")) {
                                      const fe = {
                                        instancePath: t + "/body/" + $.replace(
                                          /~/g,
                                          "~0"
                                        ).replace(
                                          /\//g,
                                          "~1"
                                        ),
                                        schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/2/required",
                                        keyword: "required",
                                        params: {
                                          missingProperty: V
                                        },
                                        message: "must have required property '" + V + "'"
                                      };
                                      s === null ? s = [
                                        fe
                                      ] : s.push(
                                        fe
                                      ), n++;
                                    } else {
                                      const fe = n;
                                      for (const ie in N)
                                        if (!(ie === "size" || ie === "type" || ie === "lastModified" || ie === "name" || ie === "webkitRelativePath")) {
                                          const ae = {
                                            instancePath: t + "/body/" + $.replace(
                                              /~/g,
                                              "~0"
                                            ).replace(
                                              /\//g,
                                              "~1"
                                            ),
                                            schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/2/additionalProperties",
                                            keyword: "additionalProperties",
                                            params: {
                                              additionalProperty: ie
                                            },
                                            message: "must NOT have additional properties"
                                          };
                                          s === null ? s = [
                                            ae
                                          ] : s.push(
                                            ae
                                          ), n++;
                                          break;
                                        }
                                      if (fe === n) {
                                        if (N.size !== void 0) {
                                          let ie = N.size;
                                          const ae = n;
                                          if (!(typeof ie == "number" && isFinite(
                                            ie
                                          ))) {
                                            const Pe = {
                                              instancePath: t + "/body/" + $.replace(
                                                /~/g,
                                                "~0"
                                              ).replace(
                                                /\//g,
                                                "~1"
                                              ) + "/size",
                                              schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/2/properties/size/type",
                                              keyword: "type",
                                              params: {
                                                type: "number"
                                              },
                                              message: "must be number"
                                            };
                                            s === null ? s = [
                                              Pe
                                            ] : s.push(
                                              Pe
                                            ), n++;
                                          }
                                          var y = ae === n;
                                        } else
                                          var y = !0;
                                        if (y) {
                                          if (N.type !== void 0) {
                                            const ie = n;
                                            if (typeof N.type != "string") {
                                              const Pe = {
                                                instancePath: t + "/body/" + $.replace(
                                                  /~/g,
                                                  "~0"
                                                ).replace(
                                                  /\//g,
                                                  "~1"
                                                ) + "/type",
                                                schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/2/properties/type/type",
                                                keyword: "type",
                                                params: {
                                                  type: "string"
                                                },
                                                message: "must be string"
                                              };
                                              s === null ? s = [
                                                Pe
                                              ] : s.push(
                                                Pe
                                              ), n++;
                                            }
                                            var y = ie === n;
                                          } else
                                            var y = !0;
                                          if (y) {
                                            if (N.lastModified !== void 0) {
                                              let ie = N.lastModified;
                                              const ae = n;
                                              if (!(typeof ie == "number" && isFinite(
                                                ie
                                              ))) {
                                                const Oe = {
                                                  instancePath: t + "/body/" + $.replace(
                                                    /~/g,
                                                    "~0"
                                                  ).replace(
                                                    /\//g,
                                                    "~1"
                                                  ) + "/lastModified",
                                                  schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/2/properties/lastModified/type",
                                                  keyword: "type",
                                                  params: {
                                                    type: "number"
                                                  },
                                                  message: "must be number"
                                                };
                                                s === null ? s = [
                                                  Oe
                                                ] : s.push(
                                                  Oe
                                                ), n++;
                                              }
                                              var y = ae === n;
                                            } else
                                              var y = !0;
                                            if (y) {
                                              if (N.name !== void 0) {
                                                const ie = n;
                                                if (typeof N.name != "string") {
                                                  const Pe = {
                                                    instancePath: t + "/body/" + $.replace(
                                                      /~/g,
                                                      "~0"
                                                    ).replace(
                                                      /\//g,
                                                      "~1"
                                                    ) + "/name",
                                                    schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/2/properties/name/type",
                                                    keyword: "type",
                                                    params: {
                                                      type: "string"
                                                    },
                                                    message: "must be string"
                                                  };
                                                  s === null ? s = [
                                                    Pe
                                                  ] : s.push(
                                                    Pe
                                                  ), n++;
                                                }
                                                var y = ie === n;
                                              } else
                                                var y = !0;
                                              if (y)
                                                if (N.webkitRelativePath !== void 0) {
                                                  const ie = n;
                                                  if (typeof N.webkitRelativePath != "string") {
                                                    const Pe = {
                                                      instancePath: t + "/body/" + $.replace(
                                                        /~/g,
                                                        "~0"
                                                      ).replace(
                                                        /\//g,
                                                        "~1"
                                                      ) + "/webkitRelativePath",
                                                      schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/2/properties/webkitRelativePath/type",
                                                      keyword: "type",
                                                      params: {
                                                        type: "string"
                                                      },
                                                      message: "must be string"
                                                    };
                                                    s === null ? s = [
                                                      Pe
                                                    ] : s.push(
                                                      Pe
                                                    ), n++;
                                                  }
                                                  var y = ie === n;
                                                } else
                                                  var y = !0;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  } else {
                                    const V = {
                                      instancePath: t + "/body/" + $.replace(
                                        /~/g,
                                        "~0"
                                      ).replace(
                                        /\//g,
                                        "~1"
                                      ),
                                      schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf/2/type",
                                      keyword: "type",
                                      params: {
                                        type: "object"
                                      },
                                      message: "must be object"
                                    };
                                    s === null ? s = [
                                      V
                                    ] : s.push(
                                      V
                                    ), n++;
                                  }
                                var h = Q === n;
                                Z = Z || h;
                              }
                            }
                            if (Z)
                              n = M, s !== null && (M ? s.length = M : s = null);
                            else {
                              const se = {
                                instancePath: t + "/body/" + $.replace(
                                  /~/g,
                                  "~0"
                                ).replace(
                                  /\//g,
                                  "~1"
                                ),
                                schemaPath: "#/properties/body/anyOf/2/additionalProperties/anyOf",
                                keyword: "anyOf",
                                params: {},
                                message: "must match a schema in anyOf"
                              };
                              s === null ? s = [
                                se
                              ] : s.push(
                                se
                              ), n++;
                            }
                            var _ = U === n;
                            if (!_)
                              break;
                          }
                        else {
                          const $ = {
                            instancePath: t + "/body",
                            schemaPath: "#/properties/body/anyOf/2/type",
                            keyword: "type",
                            params: {
                              type: "object"
                            },
                            message: "must be object"
                          };
                          s === null ? s = [$] : s.push($), n++;
                        }
                      var p = P === n;
                      H = H || p;
                    }
                  }
                  if (H)
                    n = T, s !== null && (T ? s.length = T : s = null);
                  else {
                    const L = {
                      instancePath: t + "/body",
                      schemaPath: "#/properties/body/anyOf",
                      keyword: "anyOf",
                      params: {},
                      message: "must match a schema in anyOf"
                    };
                    return s === null ? s = [L] : s.push(L), n++, wt.errors = s, !1;
                  }
                  var o = D === n;
                } else
                  var o = !0;
            }
          }
        }
      }
    } else
      return wt.errors = [
        {
          instancePath: t,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ], !1;
  return wt.errors = s, n === 0;
}
const Rb = {
  properties: {
    relativeUri: {
      type: "string",
      description: "Request path following the domain:port part â€“ after any URL rewriting rules (e.g. apache .htaccess) have been applied."
    },
    scriptPath: {
      type: "string",
      description: "Path of the .php file to execute."
    },
    protocol: { type: "string", description: "Request protocol." },
    method: {
      $ref: "#/definitions/HTTPMethod",
      description: "Request method. Default: `GET`."
    },
    headers: {
      $ref: "#/definitions/PHPRequestHeaders",
      description: "Request headers."
    },
    body: {
      anyOf: [
        { type: "string" },
        {
          type: "object",
          properties: {
            BYTES_PER_ELEMENT: { type: "number" },
            buffer: {
              type: "object",
              properties: { byteLength: { type: "number" } },
              required: ["byteLength"],
              additionalProperties: !1
            },
            byteLength: { type: "number" },
            byteOffset: { type: "number" },
            length: { type: "number" }
          },
          required: [
            "BYTES_PER_ELEMENT",
            "buffer",
            "byteLength",
            "byteOffset",
            "length"
          ],
          additionalProperties: { type: "number" }
        }
      ],
      description: "Request body."
    },
    env: {
      type: "object",
      additionalProperties: { type: "string" },
      description: "Environment variables to set for this run."
    },
    $_SERVER: {
      type: "object",
      additionalProperties: { type: "string" },
      description: "$_SERVER entries to set for this run."
    },
    code: {
      type: "string",
      description: "The code snippet to eval instead of a php file."
    }
  }
};
function Me(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  if (n === 0)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      const R = n;
      for (const y in e)
        if (!Qu.call(Rb.properties, y))
          return Me.errors = [
            {
              instancePath: t,
              schemaPath: "#/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: y },
              message: "must NOT have additional properties"
            }
          ], !1;
      if (R === n) {
        if (e.relativeUri !== void 0) {
          const y = n;
          if (typeof e.relativeUri != "string")
            return Me.errors = [
              {
                instancePath: t + "/relativeUri",
                schemaPath: "#/properties/relativeUri/type",
                keyword: "type",
                params: { type: "string" },
                message: "must be string"
              }
            ], !1;
          var o = y === n;
        } else
          var o = !0;
        if (o) {
          if (e.scriptPath !== void 0) {
            const y = n;
            if (typeof e.scriptPath != "string")
              return Me.errors = [
                {
                  instancePath: t + "/scriptPath",
                  schemaPath: "#/properties/scriptPath/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ], !1;
            var o = y === n;
          } else
            var o = !0;
          if (o) {
            if (e.protocol !== void 0) {
              const y = n;
              if (typeof e.protocol != "string")
                return Me.errors = [
                  {
                    instancePath: t + "/protocol",
                    schemaPath: "#/properties/protocol/type",
                    keyword: "type",
                    params: { type: "string" },
                    message: "must be string"
                  }
                ], !1;
              var o = y === n;
            } else
              var o = !0;
            if (o) {
              if (e.method !== void 0) {
                let y = e.method;
                const _ = n;
                if (typeof y != "string")
                  return Me.errors = [
                    {
                      instancePath: t + "/method",
                      schemaPath: "#/definitions/HTTPMethod/type",
                      keyword: "type",
                      params: { type: "string" },
                      message: "must be string"
                    }
                  ], !1;
                if (!(y === "GET" || y === "POST" || y === "HEAD" || y === "OPTIONS" || y === "PATCH" || y === "PUT" || y === "DELETE"))
                  return Me.errors = [
                    {
                      instancePath: t + "/method",
                      schemaPath: "#/definitions/HTTPMethod/enum",
                      keyword: "enum",
                      params: {
                        allowedValues: ed.enum
                      },
                      message: "must be equal to one of the allowed values"
                    }
                  ], !1;
                var o = _ === n;
              } else
                var o = !0;
              if (o) {
                if (e.headers !== void 0) {
                  let y = e.headers;
                  const _ = n;
                  if (n === n)
                    if (y && typeof y == "object" && !Array.isArray(y))
                      for (const E in y) {
                        const D = n;
                        if (typeof y[E] != "string")
                          return Me.errors = [
                            {
                              instancePath: t + "/headers/" + E.replace(
                                /~/g,
                                "~0"
                              ).replace(
                                /\//g,
                                "~1"
                              ),
                              schemaPath: "#/definitions/PHPRequestHeaders/additionalProperties/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        var l = D === n;
                        if (!l)
                          break;
                      }
                    else
                      return Me.errors = [
                        {
                          instancePath: t + "/headers",
                          schemaPath: "#/definitions/PHPRequestHeaders/type",
                          keyword: "type",
                          params: { type: "object" },
                          message: "must be object"
                        }
                      ], !1;
                  var o = _ === n;
                } else
                  var o = !0;
                if (o) {
                  if (e.body !== void 0) {
                    let y = e.body;
                    const _ = n, w = n;
                    let C = !1;
                    const E = n;
                    if (typeof y != "string") {
                      const T = {
                        instancePath: t + "/body",
                        schemaPath: "#/properties/body/anyOf/0/type",
                        keyword: "type",
                        params: { type: "string" },
                        message: "must be string"
                      };
                      s === null ? s = [T] : s.push(T), n++;
                    }
                    var p = E === n;
                    if (C = C || p, !C) {
                      const T = n;
                      if (n === T)
                        if (y && typeof y == "object" && !Array.isArray(y)) {
                          let k;
                          if (y.BYTES_PER_ELEMENT === void 0 && (k = "BYTES_PER_ELEMENT") || y.buffer === void 0 && (k = "buffer") || y.byteLength === void 0 && (k = "byteLength") || y.byteOffset === void 0 && (k = "byteOffset") || y.length === void 0 && (k = "length")) {
                            const A = {
                              instancePath: t + "/body",
                              schemaPath: "#/properties/body/anyOf/1/required",
                              keyword: "required",
                              params: {
                                missingProperty: k
                              },
                              message: "must have required property '" + k + "'"
                            };
                            s === null ? s = [A] : s.push(A), n++;
                          } else {
                            const A = n;
                            for (const L in y)
                              if (!(L === "BYTES_PER_ELEMENT" || L === "buffer" || L === "byteLength" || L === "byteOffset" || L === "length")) {
                                let S = y[L];
                                const P = n;
                                if (!(typeof S == "number" && isFinite(
                                  S
                                ))) {
                                  const I = {
                                    instancePath: t + "/body/" + L.replace(
                                      /~/g,
                                      "~0"
                                    ).replace(
                                      /\//g,
                                      "~1"
                                    ),
                                    schemaPath: "#/properties/body/anyOf/1/additionalProperties/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  };
                                  s === null ? s = [
                                    I
                                  ] : s.push(
                                    I
                                  ), n++;
                                }
                                var c = P === n;
                                if (!c)
                                  break;
                              }
                            if (A === n) {
                              if (y.BYTES_PER_ELEMENT !== void 0) {
                                let L = y.BYTES_PER_ELEMENT;
                                const S = n;
                                if (!(typeof L == "number" && isFinite(
                                  L
                                ))) {
                                  const P = {
                                    instancePath: t + "/body/BYTES_PER_ELEMENT",
                                    schemaPath: "#/properties/body/anyOf/1/properties/BYTES_PER_ELEMENT/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  };
                                  s === null ? s = [
                                    P
                                  ] : s.push(
                                    P
                                  ), n++;
                                }
                                var m = S === n;
                              } else
                                var m = !0;
                              if (m) {
                                if (y.buffer !== void 0) {
                                  let L = y.buffer;
                                  const S = n;
                                  if (n === S)
                                    if (L && typeof L == "object" && !Array.isArray(
                                      L
                                    )) {
                                      let I;
                                      if (L.byteLength === void 0 && (I = "byteLength")) {
                                        const $ = {
                                          instancePath: t + "/body/buffer",
                                          schemaPath: "#/properties/body/anyOf/1/properties/buffer/required",
                                          keyword: "required",
                                          params: {
                                            missingProperty: I
                                          },
                                          message: "must have required property '" + I + "'"
                                        };
                                        s === null ? s = [
                                          $
                                        ] : s.push(
                                          $
                                        ), n++;
                                      } else {
                                        const $ = n;
                                        for (const N in L)
                                          if (N !== "byteLength") {
                                            const U = {
                                              instancePath: t + "/body/buffer",
                                              schemaPath: "#/properties/body/anyOf/1/properties/buffer/additionalProperties",
                                              keyword: "additionalProperties",
                                              params: {
                                                additionalProperty: N
                                              },
                                              message: "must NOT have additional properties"
                                            };
                                            s === null ? s = [
                                              U
                                            ] : s.push(
                                              U
                                            ), n++;
                                            break;
                                          }
                                        if ($ === n && L.byteLength !== void 0) {
                                          let N = L.byteLength;
                                          if (!(typeof N == "number" && isFinite(
                                            N
                                          ))) {
                                            const U = {
                                              instancePath: t + "/body/buffer/byteLength",
                                              schemaPath: "#/properties/body/anyOf/1/properties/buffer/properties/byteLength/type",
                                              keyword: "type",
                                              params: {
                                                type: "number"
                                              },
                                              message: "must be number"
                                            };
                                            s === null ? s = [
                                              U
                                            ] : s.push(
                                              U
                                            ), n++;
                                          }
                                        }
                                      }
                                    } else {
                                      const I = {
                                        instancePath: t + "/body/buffer",
                                        schemaPath: "#/properties/body/anyOf/1/properties/buffer/type",
                                        keyword: "type",
                                        params: {
                                          type: "object"
                                        },
                                        message: "must be object"
                                      };
                                      s === null ? s = [
                                        I
                                      ] : s.push(
                                        I
                                      ), n++;
                                    }
                                  var m = S === n;
                                } else
                                  var m = !0;
                                if (m) {
                                  if (y.byteLength !== void 0) {
                                    let L = y.byteLength;
                                    const S = n;
                                    if (!(typeof L == "number" && isFinite(
                                      L
                                    ))) {
                                      const I = {
                                        instancePath: t + "/body/byteLength",
                                        schemaPath: "#/properties/body/anyOf/1/properties/byteLength/type",
                                        keyword: "type",
                                        params: {
                                          type: "number"
                                        },
                                        message: "must be number"
                                      };
                                      s === null ? s = [
                                        I
                                      ] : s.push(
                                        I
                                      ), n++;
                                    }
                                    var m = S === n;
                                  } else
                                    var m = !0;
                                  if (m) {
                                    if (y.byteOffset !== void 0) {
                                      let L = y.byteOffset;
                                      const S = n;
                                      if (!(typeof L == "number" && isFinite(
                                        L
                                      ))) {
                                        const I = {
                                          instancePath: t + "/body/byteOffset",
                                          schemaPath: "#/properties/body/anyOf/1/properties/byteOffset/type",
                                          keyword: "type",
                                          params: {
                                            type: "number"
                                          },
                                          message: "must be number"
                                        };
                                        s === null ? s = [
                                          I
                                        ] : s.push(
                                          I
                                        ), n++;
                                      }
                                      var m = S === n;
                                    } else
                                      var m = !0;
                                    if (m)
                                      if (y.length !== void 0) {
                                        let L = y.length;
                                        const S = n;
                                        if (!(typeof L == "number" && isFinite(
                                          L
                                        ))) {
                                          const I = {
                                            instancePath: t + "/body/length",
                                            schemaPath: "#/properties/body/anyOf/1/properties/length/type",
                                            keyword: "type",
                                            params: {
                                              type: "number"
                                            },
                                            message: "must be number"
                                          };
                                          s === null ? s = [
                                            I
                                          ] : s.push(
                                            I
                                          ), n++;
                                        }
                                        var m = S === n;
                                      } else
                                        var m = !0;
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          const k = {
                            instancePath: t + "/body",
                            schemaPath: "#/properties/body/anyOf/1/type",
                            keyword: "type",
                            params: {
                              type: "object"
                            },
                            message: "must be object"
                          };
                          s === null ? s = [k] : s.push(k), n++;
                        }
                      var p = T === n;
                      C = C || p;
                    }
                    if (C)
                      n = w, s !== null && (w ? s.length = w : s = null);
                    else {
                      const T = {
                        instancePath: t + "/body",
                        schemaPath: "#/properties/body/anyOf",
                        keyword: "anyOf",
                        params: {},
                        message: "must match a schema in anyOf"
                      };
                      return s === null ? s = [T] : s.push(T), n++, Me.errors = s, !1;
                    }
                    var o = _ === n;
                  } else
                    var o = !0;
                  if (o) {
                    if (e.env !== void 0) {
                      let y = e.env;
                      const _ = n;
                      if (n === _)
                        if (y && typeof y == "object" && !Array.isArray(y))
                          for (const C in y) {
                            const E = n;
                            if (typeof y[C] != "string")
                              return Me.errors = [
                                {
                                  instancePath: t + "/env/" + C.replace(
                                    /~/g,
                                    "~0"
                                  ).replace(
                                    /\//g,
                                    "~1"
                                  ),
                                  schemaPath: "#/properties/env/additionalProperties/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var h = E === n;
                            if (!h)
                              break;
                          }
                        else
                          return Me.errors = [
                            {
                              instancePath: t + "/env",
                              schemaPath: "#/properties/env/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var o = _ === n;
                    } else
                      var o = !0;
                    if (o) {
                      if (e.$_SERVER !== void 0) {
                        let y = e.$_SERVER;
                        const _ = n;
                        if (n === _)
                          if (y && typeof y == "object" && !Array.isArray(y))
                            for (const C in y) {
                              const E = n;
                              if (typeof y[C] != "string")
                                return Me.errors = [
                                  {
                                    instancePath: t + "/$_SERVER/" + C.replace(
                                      /~/g,
                                      "~0"
                                    ).replace(
                                      /\//g,
                                      "~1"
                                    ),
                                    schemaPath: "#/properties/%24_SERVER/additionalProperties/type",
                                    keyword: "type",
                                    params: {
                                      type: "string"
                                    },
                                    message: "must be string"
                                  }
                                ], !1;
                              var g = E === n;
                              if (!g)
                                break;
                            }
                          else
                            return Me.errors = [
                              {
                                instancePath: t + "/$_SERVER",
                                schemaPath: "#/properties/%24_SERVER/type",
                                keyword: "type",
                                params: {
                                  type: "object"
                                },
                                message: "must be object"
                              }
                            ], !1;
                        var o = _ === n;
                      } else
                        var o = !0;
                      if (o)
                        if (e.code !== void 0) {
                          const y = n;
                          if (typeof e.code != "string")
                            return Me.errors = [
                              {
                                instancePath: t + "/code",
                                schemaPath: "#/properties/code/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var o = y === n;
                        } else
                          var o = !0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else
      return Me.errors = [
        {
          instancePath: t,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ], !1;
  return Me.errors = s, n === 0;
}
function b(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  if (n === 0)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      let We;
      if (e.step === void 0 && (We = "step"))
        return b.errors = [
          {
            instancePath: t,
            schemaPath: "#/required",
            keyword: "required",
            params: { missingProperty: We },
            message: "must have required property '" + We + "'"
          }
        ], !1;
      {
        const ce = e.step;
        if (typeof ce == "string")
          if (ce === "activatePlugin") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.pluginPath === void 0 && (j = "pluginPath") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/0/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "pluginPath" || f === "pluginName"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/0/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/0/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/0/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var o = re === n;
                            } else
                              var o = !0;
                            if (o)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/0/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var o = x === n;
                              } else
                                var o = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/0/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var l = F === n;
                    } else
                      var l = !0;
                    if (l) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/0/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "activatePlugin")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/0/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "activatePlugin"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var l = F === n;
                      } else
                        var l = !0;
                      if (l) {
                        if (e.pluginPath !== void 0) {
                          const f = n;
                          if (typeof e.pluginPath != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/pluginPath",
                                schemaPath: "#/oneOf/0/properties/pluginPath/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var l = f === n;
                        } else
                          var l = !0;
                        if (l)
                          if (e.pluginName !== void 0) {
                            const f = n;
                            if (typeof e.pluginName != "string")
                              return b.errors = [
                                {
                                  instancePath: t + "/pluginName",
                                  schemaPath: "#/oneOf/0/properties/pluginName/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var l = f === n;
                          } else
                            var l = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/0/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "activateTheme") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.step === void 0 && (j = "step") || e.themeFolderName === void 0 && (j = "themeFolderName"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/1/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "themeFolderName"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/1/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/1/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/1/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var p = re === n;
                            } else
                              var p = !0;
                            if (p)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/1/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var p = x === n;
                              } else
                                var p = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/1/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var c = F === n;
                    } else
                      var c = !0;
                    if (c) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/1/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "activateTheme")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/1/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "activateTheme"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var c = F === n;
                      } else
                        var c = !0;
                      if (c)
                        if (e.themeFolderName !== void 0) {
                          const f = n;
                          if (typeof e.themeFolderName != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/themeFolderName",
                                schemaPath: "#/oneOf/1/properties/themeFolderName/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var c = f === n;
                        } else
                          var c = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/1/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "cp") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.fromPath === void 0 && (j = "fromPath") || e.step === void 0 && (j = "step") || e.toPath === void 0 && (j = "toPath"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/2/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "fromPath" || f === "toPath"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/2/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/2/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/2/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var m = re === n;
                            } else
                              var m = !0;
                            if (m)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/2/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var m = x === n;
                              } else
                                var m = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/2/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var h = F === n;
                    } else
                      var h = !0;
                    if (h) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/2/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "cp")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/2/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "cp"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var h = F === n;
                      } else
                        var h = !0;
                      if (h) {
                        if (e.fromPath !== void 0) {
                          const f = n;
                          if (typeof e.fromPath != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/fromPath",
                                schemaPath: "#/oneOf/2/properties/fromPath/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var h = f === n;
                        } else
                          var h = !0;
                        if (h)
                          if (e.toPath !== void 0) {
                            const f = n;
                            if (typeof e.toPath != "string")
                              return b.errors = [
                                {
                                  instancePath: t + "/toPath",
                                  schemaPath: "#/oneOf/2/properties/toPath/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var h = f === n;
                          } else
                            var h = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/2/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "defineWpConfigConsts") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.consts === void 0 && (j = "consts") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/3/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "consts" || f === "method" || f === "virtualize"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/3/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/3/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/3/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var g = re === n;
                            } else
                              var g = !0;
                            if (g)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/3/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var g = x === n;
                              } else
                                var g = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/3/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var R = F === n;
                    } else
                      var R = !0;
                    if (R) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/3/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "defineWpConfigConsts")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/3/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "defineWpConfigConsts"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var R = F === n;
                      } else
                        var R = !0;
                      if (R) {
                        if (e.consts !== void 0) {
                          let f = e.consts;
                          const F = n;
                          if (n === F && !(f && typeof f == "object" && !Array.isArray(
                            f
                          )))
                            return b.errors = [
                              {
                                instancePath: t + "/consts",
                                schemaPath: "#/oneOf/3/properties/consts/type",
                                keyword: "type",
                                params: {
                                  type: "object"
                                },
                                message: "must be object"
                              }
                            ], !1;
                          var R = F === n;
                        } else
                          var R = !0;
                        if (R) {
                          if (e.method !== void 0) {
                            let f = e.method;
                            const F = n;
                            if (typeof f != "string")
                              return b.errors = [
                                {
                                  instancePath: t + "/method",
                                  schemaPath: "#/oneOf/3/properties/method/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            if (!(f === "rewrite-wp-config" || f === "define-before-run"))
                              return b.errors = [
                                {
                                  instancePath: t + "/method",
                                  schemaPath: "#/oneOf/3/properties/method/enum",
                                  keyword: "enum",
                                  params: {
                                    allowedValues: Es.oneOf[3].properties.method.enum
                                  },
                                  message: "must be equal to one of the allowed values"
                                }
                              ], !1;
                            var R = F === n;
                          } else
                            var R = !0;
                          if (R)
                            if (e.virtualize !== void 0) {
                              const f = n;
                              if (typeof e.virtualize != "boolean")
                                return b.errors = [
                                  {
                                    instancePath: t + "/virtualize",
                                    schemaPath: "#/oneOf/3/properties/virtualize/type",
                                    keyword: "type",
                                    params: {
                                      type: "boolean"
                                    },
                                    message: "must be boolean"
                                  }
                                ], !1;
                              var R = f === n;
                            } else
                              var R = !0;
                        }
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/3/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "defineSiteUrl") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.siteUrl === void 0 && (j = "siteUrl") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/4/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "siteUrl"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/4/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/4/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/4/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var y = re === n;
                            } else
                              var y = !0;
                            if (y)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/4/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var y = x === n;
                              } else
                                var y = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/4/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var _ = F === n;
                    } else
                      var _ = !0;
                    if (_) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/4/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "defineSiteUrl")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/4/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "defineSiteUrl"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var _ = F === n;
                      } else
                        var _ = !0;
                      if (_)
                        if (e.siteUrl !== void 0) {
                          const f = n;
                          if (typeof e.siteUrl != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/siteUrl",
                                schemaPath: "#/oneOf/4/properties/siteUrl/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var _ = f === n;
                        } else
                          var _ = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/4/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "enableMultisite") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/5/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "wpCliPath"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/5/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/5/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/5/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var w = re === n;
                            } else
                              var w = !0;
                            if (w)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/5/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var w = x === n;
                              } else
                                var w = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/5/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var C = F === n;
                    } else
                      var C = !0;
                    if (C) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/5/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "enableMultisite")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/5/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "enableMultisite"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var C = F === n;
                      } else
                        var C = !0;
                      if (C)
                        if (e.wpCliPath !== void 0) {
                          const f = n;
                          if (typeof e.wpCliPath != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/wpCliPath",
                                schemaPath: "#/oneOf/5/properties/wpCliPath/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var C = f === n;
                        } else
                          var C = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/5/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "importWxr") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.file === void 0 && (j = "file") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/6/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "file" || f === "importer"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/6/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/6/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/6/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var E = re === n;
                            } else
                              var E = !0;
                            if (E)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/6/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var E = x === n;
                              } else
                                var E = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/6/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var D = F === n;
                    } else
                      var D = !0;
                    if (D) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/6/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "importWxr")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/6/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "importWxr"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var D = F === n;
                      } else
                        var D = !0;
                      if (D) {
                        if (e.file !== void 0) {
                          const f = n;
                          Ee(e.file, {
                            instancePath: t + "/file",
                            parentData: e,
                            parentDataProperty: "file",
                            rootData: a
                          }) || (s = s === null ? Ee.errors : s.concat(
                            Ee.errors
                          ), n = s.length);
                          var D = f === n;
                        } else
                          var D = !0;
                        if (D)
                          if (e.importer !== void 0) {
                            let f = e.importer;
                            const F = n;
                            if (typeof f != "string")
                              return b.errors = [
                                {
                                  instancePath: t + "/importer",
                                  schemaPath: "#/oneOf/6/properties/importer/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            if (!(f === "data-liberation" || f === "default"))
                              return b.errors = [
                                {
                                  instancePath: t + "/importer",
                                  schemaPath: "#/oneOf/6/properties/importer/enum",
                                  keyword: "enum",
                                  params: {
                                    allowedValues: Es.oneOf[6].properties.importer.enum
                                  },
                                  message: "must be equal to one of the allowed values"
                                }
                              ], !1;
                            var D = F === n;
                          } else
                            var D = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/6/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "importThemeStarterContent") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/7/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "themeSlug"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/7/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/7/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/7/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var T = re === n;
                            } else
                              var T = !0;
                            if (T)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/7/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var T = x === n;
                              } else
                                var T = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/7/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var H = F === n;
                    } else
                      var H = !0;
                    if (H) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/7/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "importThemeStarterContent")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/7/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "importThemeStarterContent"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var H = F === n;
                      } else
                        var H = !0;
                      if (H)
                        if (e.themeSlug !== void 0) {
                          const f = n;
                          if (typeof e.themeSlug != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/themeSlug",
                                schemaPath: "#/oneOf/7/properties/themeSlug/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var H = f === n;
                        } else
                          var H = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/7/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "importWordPressFiles") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.step === void 0 && (j = "step") || e.wordPressFilesZip === void 0 && (j = "wordPressFilesZip"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/8/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "wordPressFilesZip" || f === "pathInZip"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/8/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/8/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/8/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var k = re === n;
                            } else
                              var k = !0;
                            if (k)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/8/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var k = x === n;
                              } else
                                var k = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/8/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var A = F === n;
                    } else
                      var A = !0;
                    if (A) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/8/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "importWordPressFiles")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/8/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "importWordPressFiles"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var A = F === n;
                      } else
                        var A = !0;
                      if (A) {
                        if (e.wordPressFilesZip !== void 0) {
                          const f = n;
                          Ee(
                            e.wordPressFilesZip,
                            {
                              instancePath: t + "/wordPressFilesZip",
                              parentData: e,
                              parentDataProperty: "wordPressFilesZip",
                              rootData: a
                            }
                          ) || (s = s === null ? Ee.errors : s.concat(
                            Ee.errors
                          ), n = s.length);
                          var A = f === n;
                        } else
                          var A = !0;
                        if (A)
                          if (e.pathInZip !== void 0) {
                            const f = n;
                            if (typeof e.pathInZip != "string")
                              return b.errors = [
                                {
                                  instancePath: t + "/pathInZip",
                                  schemaPath: "#/oneOf/8/properties/pathInZip/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var A = f === n;
                          } else
                            var A = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/8/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "installPlugin") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.pluginData === void 0 && (j = "pluginData") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/9/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "ifAlreadyInstalled" || f === "step" || f === "pluginData" || f === "pluginZipFile" || f === "options"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/9/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/9/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/9/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var L = re === n;
                            } else
                              var L = !0;
                            if (L)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/9/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var L = x === n;
                              } else
                                var L = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/9/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var S = F === n;
                    } else
                      var S = !0;
                    if (S) {
                      if (e.ifAlreadyInstalled !== void 0) {
                        let f = e.ifAlreadyInstalled;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/ifAlreadyInstalled",
                              schemaPath: "#/oneOf/9/properties/ifAlreadyInstalled/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (!(f === "overwrite" || f === "skip" || f === "error"))
                          return b.errors = [
                            {
                              instancePath: t + "/ifAlreadyInstalled",
                              schemaPath: "#/oneOf/9/properties/ifAlreadyInstalled/enum",
                              keyword: "enum",
                              params: {
                                allowedValues: Es.oneOf[9].properties.ifAlreadyInstalled.enum
                              },
                              message: "must be equal to one of the allowed values"
                            }
                          ], !1;
                        var S = F === n;
                      } else
                        var S = !0;
                      if (S) {
                        if (e.step !== void 0) {
                          let f = e.step;
                          const F = n;
                          if (typeof f != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/step",
                                schemaPath: "#/oneOf/9/properties/step/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          if (f !== "installPlugin")
                            return b.errors = [
                              {
                                instancePath: t + "/step",
                                schemaPath: "#/oneOf/9/properties/step/const",
                                keyword: "const",
                                params: {
                                  allowedValue: "installPlugin"
                                },
                                message: "must be equal to constant"
                              }
                            ], !1;
                          var S = F === n;
                        } else
                          var S = !0;
                        if (S) {
                          if (e.pluginData !== void 0) {
                            let f = e.pluginData;
                            const F = n, te = n;
                            let x = !1;
                            const re = n;
                            Ee(
                              f,
                              {
                                instancePath: t + "/pluginData",
                                parentData: e,
                                parentDataProperty: "pluginData",
                                rootData: a
                              }
                            ) || (s = s === null ? Ee.errors : s.concat(
                              Ee.errors
                            ), n = s.length);
                            var P = re === n;
                            if (x = x || P, !x) {
                              const xe = n;
                              It(
                                f,
                                {
                                  instancePath: t + "/pluginData",
                                  parentData: e,
                                  parentDataProperty: "pluginData",
                                  rootData: a
                                }
                              ) || (s = s === null ? It.errors : s.concat(
                                It.errors
                              ), n = s.length);
                              var P = xe === n;
                              x = x || P;
                            }
                            if (x)
                              n = te, s !== null && (te ? s.length = te : s = null);
                            else {
                              const xe = {
                                instancePath: t + "/pluginData",
                                schemaPath: "#/oneOf/9/properties/pluginData/anyOf",
                                keyword: "anyOf",
                                params: {},
                                message: "must match a schema in anyOf"
                              };
                              return s === null ? s = [
                                xe
                              ] : s.push(
                                xe
                              ), n++, b.errors = s, !1;
                            }
                            var S = F === n;
                          } else
                            var S = !0;
                          if (S) {
                            if (e.pluginZipFile !== void 0) {
                              const f = n;
                              Ee(
                                e.pluginZipFile,
                                {
                                  instancePath: t + "/pluginZipFile",
                                  parentData: e,
                                  parentDataProperty: "pluginZipFile",
                                  rootData: a
                                }
                              ) || (s = s === null ? Ee.errors : s.concat(
                                Ee.errors
                              ), n = s.length);
                              var S = f === n;
                            } else
                              var S = !0;
                            if (S)
                              if (e.options !== void 0) {
                                let f = e.options;
                                const F = n;
                                if (n === n)
                                  if (f && typeof f == "object" && !Array.isArray(
                                    f
                                  )) {
                                    const re = n;
                                    for (const Ce in f)
                                      if (!(Ce === "activate" || Ce === "targetFolderName"))
                                        return b.errors = [
                                          {
                                            instancePath: t + "/options",
                                            schemaPath: "#/definitions/InstallPluginOptions/additionalProperties",
                                            keyword: "additionalProperties",
                                            params: {
                                              additionalProperty: Ce
                                            },
                                            message: "must NOT have additional properties"
                                          }
                                        ], !1;
                                    if (re === n) {
                                      if (f.activate !== void 0) {
                                        const Ce = n;
                                        if (typeof f.activate != "boolean")
                                          return b.errors = [
                                            {
                                              instancePath: t + "/options/activate",
                                              schemaPath: "#/definitions/InstallPluginOptions/properties/activate/type",
                                              keyword: "type",
                                              params: {
                                                type: "boolean"
                                              },
                                              message: "must be boolean"
                                            }
                                          ], !1;
                                        var I = Ce === n;
                                      } else
                                        var I = !0;
                                      if (I)
                                        if (f.targetFolderName !== void 0) {
                                          const Ce = n;
                                          if (typeof f.targetFolderName != "string")
                                            return b.errors = [
                                              {
                                                instancePath: t + "/options/targetFolderName",
                                                schemaPath: "#/definitions/InstallPluginOptions/properties/targetFolderName/type",
                                                keyword: "type",
                                                params: {
                                                  type: "string"
                                                },
                                                message: "must be string"
                                              }
                                            ], !1;
                                          var I = Ce === n;
                                        } else
                                          var I = !0;
                                    }
                                  } else
                                    return b.errors = [
                                      {
                                        instancePath: t + "/options",
                                        schemaPath: "#/definitions/InstallPluginOptions/type",
                                        keyword: "type",
                                        params: {
                                          type: "object"
                                        },
                                        message: "must be object"
                                      }
                                    ], !1;
                                var S = F === n;
                              } else
                                var S = !0;
                          }
                        }
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/9/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "installTheme") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.step === void 0 && (j = "step") || e.themeData === void 0 && (j = "themeData"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/10/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "ifAlreadyInstalled" || f === "step" || f === "themeData" || f === "themeZipFile" || f === "options"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/10/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/10/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/10/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var $ = re === n;
                            } else
                              var $ = !0;
                            if ($)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/10/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var $ = x === n;
                              } else
                                var $ = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/10/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var N = F === n;
                    } else
                      var N = !0;
                    if (N) {
                      if (e.ifAlreadyInstalled !== void 0) {
                        let f = e.ifAlreadyInstalled;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/ifAlreadyInstalled",
                              schemaPath: "#/oneOf/10/properties/ifAlreadyInstalled/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (!(f === "overwrite" || f === "skip" || f === "error"))
                          return b.errors = [
                            {
                              instancePath: t + "/ifAlreadyInstalled",
                              schemaPath: "#/oneOf/10/properties/ifAlreadyInstalled/enum",
                              keyword: "enum",
                              params: {
                                allowedValues: Es.oneOf[10].properties.ifAlreadyInstalled.enum
                              },
                              message: "must be equal to one of the allowed values"
                            }
                          ], !1;
                        var N = F === n;
                      } else
                        var N = !0;
                      if (N) {
                        if (e.step !== void 0) {
                          let f = e.step;
                          const F = n;
                          if (typeof f != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/step",
                                schemaPath: "#/oneOf/10/properties/step/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          if (f !== "installTheme")
                            return b.errors = [
                              {
                                instancePath: t + "/step",
                                schemaPath: "#/oneOf/10/properties/step/const",
                                keyword: "const",
                                params: {
                                  allowedValue: "installTheme"
                                },
                                message: "must be equal to constant"
                              }
                            ], !1;
                          var N = F === n;
                        } else
                          var N = !0;
                        if (N) {
                          if (e.themeData !== void 0) {
                            let f = e.themeData;
                            const F = n, te = n;
                            let x = !1;
                            const re = n;
                            Ee(
                              f,
                              {
                                instancePath: t + "/themeData",
                                parentData: e,
                                parentDataProperty: "themeData",
                                rootData: a
                              }
                            ) || (s = s === null ? Ee.errors : s.concat(
                              Ee.errors
                            ), n = s.length);
                            var U = re === n;
                            if (x = x || U, !x) {
                              const xe = n;
                              It(
                                f,
                                {
                                  instancePath: t + "/themeData",
                                  parentData: e,
                                  parentDataProperty: "themeData",
                                  rootData: a
                                }
                              ) || (s = s === null ? It.errors : s.concat(
                                It.errors
                              ), n = s.length);
                              var U = xe === n;
                              x = x || U;
                            }
                            if (x)
                              n = te, s !== null && (te ? s.length = te : s = null);
                            else {
                              const xe = {
                                instancePath: t + "/themeData",
                                schemaPath: "#/oneOf/10/properties/themeData/anyOf",
                                keyword: "anyOf",
                                params: {},
                                message: "must match a schema in anyOf"
                              };
                              return s === null ? s = [
                                xe
                              ] : s.push(
                                xe
                              ), n++, b.errors = s, !1;
                            }
                            var N = F === n;
                          } else
                            var N = !0;
                          if (N) {
                            if (e.themeZipFile !== void 0) {
                              const f = n;
                              Ee(
                                e.themeZipFile,
                                {
                                  instancePath: t + "/themeZipFile",
                                  parentData: e,
                                  parentDataProperty: "themeZipFile",
                                  rootData: a
                                }
                              ) || (s = s === null ? Ee.errors : s.concat(
                                Ee.errors
                              ), n = s.length);
                              var N = f === n;
                            } else
                              var N = !0;
                            if (N)
                              if (e.options !== void 0) {
                                let f = e.options;
                                const F = n;
                                if (n === n)
                                  if (f && typeof f == "object" && !Array.isArray(
                                    f
                                  )) {
                                    const re = n;
                                    for (const Ce in f)
                                      if (!(Ce === "activate" || Ce === "importStarterContent" || Ce === "targetFolderName"))
                                        return b.errors = [
                                          {
                                            instancePath: t + "/options",
                                            schemaPath: "#/definitions/InstallThemeOptions/additionalProperties",
                                            keyword: "additionalProperties",
                                            params: {
                                              additionalProperty: Ce
                                            },
                                            message: "must NOT have additional properties"
                                          }
                                        ], !1;
                                    if (re === n) {
                                      if (f.activate !== void 0) {
                                        const Ce = n;
                                        if (typeof f.activate != "boolean")
                                          return b.errors = [
                                            {
                                              instancePath: t + "/options/activate",
                                              schemaPath: "#/definitions/InstallThemeOptions/properties/activate/type",
                                              keyword: "type",
                                              params: {
                                                type: "boolean"
                                              },
                                              message: "must be boolean"
                                            }
                                          ], !1;
                                        var M = Ce === n;
                                      } else
                                        var M = !0;
                                      if (M) {
                                        if (f.importStarterContent !== void 0) {
                                          const Ce = n;
                                          if (typeof f.importStarterContent != "boolean")
                                            return b.errors = [
                                              {
                                                instancePath: t + "/options/importStarterContent",
                                                schemaPath: "#/definitions/InstallThemeOptions/properties/importStarterContent/type",
                                                keyword: "type",
                                                params: {
                                                  type: "boolean"
                                                },
                                                message: "must be boolean"
                                              }
                                            ], !1;
                                          var M = Ce === n;
                                        } else
                                          var M = !0;
                                        if (M)
                                          if (f.targetFolderName !== void 0) {
                                            const Ce = n;
                                            if (typeof f.targetFolderName != "string")
                                              return b.errors = [
                                                {
                                                  instancePath: t + "/options/targetFolderName",
                                                  schemaPath: "#/definitions/InstallThemeOptions/properties/targetFolderName/type",
                                                  keyword: "type",
                                                  params: {
                                                    type: "string"
                                                  },
                                                  message: "must be string"
                                                }
                                              ], !1;
                                            var M = Ce === n;
                                          } else
                                            var M = !0;
                                      }
                                    }
                                  } else
                                    return b.errors = [
                                      {
                                        instancePath: t + "/options",
                                        schemaPath: "#/definitions/InstallThemeOptions/type",
                                        keyword: "type",
                                        params: {
                                          type: "object"
                                        },
                                        message: "must be object"
                                      }
                                    ], !1;
                                var N = F === n;
                              } else
                                var N = !0;
                          }
                        }
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/10/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "login") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/11/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "username" || f === "password"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/11/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/11/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/11/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var Z = re === n;
                            } else
                              var Z = !0;
                            if (Z)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/11/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var Z = x === n;
                              } else
                                var Z = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/11/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var z = F === n;
                    } else
                      var z = !0;
                    if (z) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/11/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "login")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/11/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "login"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var z = F === n;
                      } else
                        var z = !0;
                      if (z) {
                        if (e.username !== void 0) {
                          const f = n;
                          if (typeof e.username != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/username",
                                schemaPath: "#/oneOf/11/properties/username/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var z = f === n;
                        } else
                          var z = !0;
                        if (z)
                          if (e.password !== void 0) {
                            const f = n;
                            if (typeof e.password != "string")
                              return b.errors = [
                                {
                                  instancePath: t + "/password",
                                  schemaPath: "#/oneOf/11/properties/password/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var z = f === n;
                          } else
                            var z = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/11/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "mkdir") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.path === void 0 && (j = "path") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/12/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "path"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/12/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/12/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/12/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var se = re === n;
                            } else
                              var se = !0;
                            if (se)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/12/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var se = x === n;
                              } else
                                var se = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/12/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var G = F === n;
                    } else
                      var G = !0;
                    if (G) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/12/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "mkdir")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/12/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "mkdir"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var G = F === n;
                      } else
                        var G = !0;
                      if (G)
                        if (e.path !== void 0) {
                          const f = n;
                          if (typeof e.path != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/path",
                                schemaPath: "#/oneOf/12/properties/path/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var G = f === n;
                        } else
                          var G = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/12/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "mv") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.fromPath === void 0 && (j = "fromPath") || e.step === void 0 && (j = "step") || e.toPath === void 0 && (j = "toPath"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/13/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "fromPath" || f === "toPath"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/13/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/13/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/13/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var Q = re === n;
                            } else
                              var Q = !0;
                            if (Q)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/13/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var Q = x === n;
                              } else
                                var Q = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/13/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var ee = F === n;
                    } else
                      var ee = !0;
                    if (ee) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/13/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "mv")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/13/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "mv"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var ee = F === n;
                      } else
                        var ee = !0;
                      if (ee) {
                        if (e.fromPath !== void 0) {
                          const f = n;
                          if (typeof e.fromPath != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/fromPath",
                                schemaPath: "#/oneOf/13/properties/fromPath/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var ee = f === n;
                        } else
                          var ee = !0;
                        if (ee)
                          if (e.toPath !== void 0) {
                            const f = n;
                            if (typeof e.toPath != "string")
                              return b.errors = [
                                {
                                  instancePath: t + "/toPath",
                                  schemaPath: "#/oneOf/13/properties/toPath/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var ee = f === n;
                          } else
                            var ee = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/13/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "resetData") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/14/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/14/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/14/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/14/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var V = re === n;
                            } else
                              var V = !0;
                            if (V)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/14/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var V = x === n;
                              } else
                                var V = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/14/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var fe = F === n;
                    } else
                      var fe = !0;
                    if (fe)
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/14/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "resetData")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/14/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "resetData"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var fe = F === n;
                      } else
                        var fe = !0;
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/14/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "request") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.request === void 0 && (j = "request") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/15/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "request"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/15/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/15/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/15/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var ie = re === n;
                            } else
                              var ie = !0;
                            if (ie)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/15/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var ie = x === n;
                              } else
                                var ie = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/15/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var ae = F === n;
                    } else
                      var ae = !0;
                    if (ae) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/15/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "request")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/15/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "request"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var ae = F === n;
                      } else
                        var ae = !0;
                      if (ae)
                        if (e.request !== void 0) {
                          const f = n;
                          wt(
                            e.request,
                            {
                              instancePath: t + "/request",
                              parentData: e,
                              parentDataProperty: "request",
                              rootData: a
                            }
                          ) || (s = s === null ? wt.errors : s.concat(
                            wt.errors
                          ), n = s.length);
                          var ae = f === n;
                        } else
                          var ae = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/15/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "rm") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.path === void 0 && (j = "path") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/16/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "path"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/16/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/16/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/16/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var Pe = re === n;
                            } else
                              var Pe = !0;
                            if (Pe)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/16/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var Pe = x === n;
                              } else
                                var Pe = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/16/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var Oe = F === n;
                    } else
                      var Oe = !0;
                    if (Oe) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/16/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "rm")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/16/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "rm"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var Oe = F === n;
                      } else
                        var Oe = !0;
                      if (Oe)
                        if (e.path !== void 0) {
                          const f = n;
                          if (typeof e.path != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/path",
                                schemaPath: "#/oneOf/16/properties/path/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var Oe = f === n;
                        } else
                          var Oe = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/16/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "rmdir") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.path === void 0 && (j = "path") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/17/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "path"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/17/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/17/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/17/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var Xe = re === n;
                            } else
                              var Xe = !0;
                            if (Xe)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/17/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var Xe = x === n;
                              } else
                                var Xe = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/17/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var tt = F === n;
                    } else
                      var tt = !0;
                    if (tt) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/17/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "rmdir")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/17/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "rmdir"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var tt = F === n;
                      } else
                        var tt = !0;
                      if (tt)
                        if (e.path !== void 0) {
                          const f = n;
                          if (typeof e.path != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/path",
                                schemaPath: "#/oneOf/17/properties/path/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var tt = f === n;
                        } else
                          var tt = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/17/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "runPHP") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.code === void 0 && (j = "code") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/18/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "code"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/18/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/18/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/18/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var St = re === n;
                            } else
                              var St = !0;
                            if (St)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/18/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var St = x === n;
                              } else
                                var St = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/18/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var Ie = F === n;
                    } else
                      var Ie = !0;
                    if (Ie) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/18/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "runPHP")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/18/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "runPHP"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var Ie = F === n;
                      } else
                        var Ie = !0;
                      if (Ie)
                        if (e.code !== void 0) {
                          let f = e.code;
                          const F = n, te = n;
                          let x = !1;
                          const re = n;
                          if (typeof f != "string") {
                            const xe = {
                              instancePath: t + "/code",
                              schemaPath: "#/oneOf/18/properties/code/anyOf/0/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            };
                            s === null ? s = [xe] : s.push(xe), n++;
                          }
                          var De = re === n;
                          if (x = x || De, !x) {
                            const xe = n;
                            if (n === xe)
                              if (f && typeof f == "object" && !Array.isArray(
                                f
                              )) {
                                let Ke;
                                if (f.filename === void 0 && (Ke = "filename") || f.content === void 0 && (Ke = "content")) {
                                  const Qt = {
                                    instancePath: t + "/code",
                                    schemaPath: "#/oneOf/18/properties/code/anyOf/1/required",
                                    keyword: "required",
                                    params: {
                                      missingProperty: Ke
                                    },
                                    message: "must have required property '" + Ke + "'"
                                  };
                                  s === null ? s = [
                                    Qt
                                  ] : s.push(
                                    Qt
                                  ), n++;
                                } else {
                                  const Qt = n;
                                  for (const Ue in f)
                                    if (!(Ue === "filename" || Ue === "content")) {
                                      const Bt = {
                                        instancePath: t + "/code",
                                        schemaPath: "#/oneOf/18/properties/code/anyOf/1/additionalProperties",
                                        keyword: "additionalProperties",
                                        params: {
                                          additionalProperty: Ue
                                        },
                                        message: "must NOT have additional properties"
                                      };
                                      s === null ? s = [
                                        Bt
                                      ] : s.push(
                                        Bt
                                      ), n++;
                                      break;
                                    }
                                  if (Qt === n) {
                                    if (f.filename !== void 0) {
                                      const Ue = n;
                                      if (typeof f.filename != "string") {
                                        const Bt = {
                                          instancePath: t + "/code/filename",
                                          schemaPath: "#/oneOf/18/properties/code/anyOf/1/properties/filename/type",
                                          keyword: "type",
                                          params: {
                                            type: "string"
                                          },
                                          message: "must be string"
                                        };
                                        s === null ? s = [
                                          Bt
                                        ] : s.push(
                                          Bt
                                        ), n++;
                                      }
                                      var ft = Ue === n;
                                    } else
                                      var ft = !0;
                                    if (ft)
                                      if (f.content !== void 0) {
                                        const Ue = n;
                                        if (typeof f.content != "string") {
                                          const we = {
                                            instancePath: t + "/code/content",
                                            schemaPath: "#/oneOf/18/properties/code/anyOf/1/properties/content/type",
                                            keyword: "type",
                                            params: {
                                              type: "string"
                                            },
                                            message: "must be string"
                                          };
                                          s === null ? s = [
                                            we
                                          ] : s.push(
                                            we
                                          ), n++;
                                        }
                                        var ft = Ue === n;
                                      } else
                                        var ft = !0;
                                  }
                                }
                              } else {
                                const Ke = {
                                  instancePath: t + "/code",
                                  schemaPath: "#/oneOf/18/properties/code/anyOf/1/type",
                                  keyword: "type",
                                  params: {
                                    type: "object"
                                  },
                                  message: "must be object"
                                };
                                s === null ? s = [
                                  Ke
                                ] : s.push(
                                  Ke
                                ), n++;
                              }
                            var De = xe === n;
                            x = x || De;
                          }
                          if (x)
                            n = te, s !== null && (te ? s.length = te : s = null);
                          else {
                            const xe = {
                              instancePath: t + "/code",
                              schemaPath: "#/oneOf/18/properties/code/anyOf",
                              keyword: "anyOf",
                              params: {},
                              message: "must match a schema in anyOf"
                            };
                            return s === null ? s = [xe] : s.push(xe), n++, b.errors = s, !1;
                          }
                          var Ie = F === n;
                        } else
                          var Ie = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/18/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "runPHPWithOptions") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.options === void 0 && (j = "options") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/19/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "options"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/19/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/19/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/19/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var Le = re === n;
                            } else
                              var Le = !0;
                            if (Le)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/19/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var Le = x === n;
                              } else
                                var Le = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/19/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var v = F === n;
                    } else
                      var v = !0;
                    if (v) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/19/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "runPHPWithOptions")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/19/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "runPHPWithOptions"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var v = F === n;
                      } else
                        var v = !0;
                      if (v)
                        if (e.options !== void 0) {
                          const f = n;
                          Me(
                            e.options,
                            {
                              instancePath: t + "/options",
                              parentData: e,
                              parentDataProperty: "options",
                              rootData: a
                            }
                          ) || (s = s === null ? Me.errors : s.concat(
                            Me.errors
                          ), n = s.length);
                          var v = f === n;
                        } else
                          var v = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/19/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "runWpInstallationWizard") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.options === void 0 && (j = "options") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/20/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "options"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/20/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/20/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/20/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var u = re === n;
                            } else
                              var u = !0;
                            if (u)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/20/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var u = x === n;
                              } else
                                var u = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/20/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var d = F === n;
                    } else
                      var d = !0;
                    if (d) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/20/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "runWpInstallationWizard")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/20/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "runWpInstallationWizard"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var d = F === n;
                      } else
                        var d = !0;
                      if (d)
                        if (e.options !== void 0) {
                          let f = e.options;
                          const F = n;
                          if (n === n)
                            if (f && typeof f == "object" && !Array.isArray(
                              f
                            )) {
                              const re = n;
                              for (const Ce in f)
                                if (!(Ce === "adminUsername" || Ce === "adminPassword"))
                                  return b.errors = [
                                    {
                                      instancePath: t + "/options",
                                      schemaPath: "#/definitions/WordPressInstallationOptions/additionalProperties",
                                      keyword: "additionalProperties",
                                      params: {
                                        additionalProperty: Ce
                                      },
                                      message: "must NOT have additional properties"
                                    }
                                  ], !1;
                              if (re === n) {
                                if (f.adminUsername !== void 0) {
                                  const Ce = n;
                                  if (typeof f.adminUsername != "string")
                                    return b.errors = [
                                      {
                                        instancePath: t + "/options/adminUsername",
                                        schemaPath: "#/definitions/WordPressInstallationOptions/properties/adminUsername/type",
                                        keyword: "type",
                                        params: {
                                          type: "string"
                                        },
                                        message: "must be string"
                                      }
                                    ], !1;
                                  var O = Ce === n;
                                } else
                                  var O = !0;
                                if (O)
                                  if (f.adminPassword !== void 0) {
                                    const Ce = n;
                                    if (typeof f.adminPassword != "string")
                                      return b.errors = [
                                        {
                                          instancePath: t + "/options/adminPassword",
                                          schemaPath: "#/definitions/WordPressInstallationOptions/properties/adminPassword/type",
                                          keyword: "type",
                                          params: {
                                            type: "string"
                                          },
                                          message: "must be string"
                                        }
                                      ], !1;
                                    var O = Ce === n;
                                  } else
                                    var O = !0;
                              }
                            } else
                              return b.errors = [
                                {
                                  instancePath: t + "/options",
                                  schemaPath: "#/definitions/WordPressInstallationOptions/type",
                                  keyword: "type",
                                  params: {
                                    type: "object"
                                  },
                                  message: "must be object"
                                }
                              ], !1;
                          var d = F === n;
                        } else
                          var d = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/20/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "runSql") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.sql === void 0 && (j = "sql") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/21/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "sql"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/21/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/21/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/21/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var B = re === n;
                            } else
                              var B = !0;
                            if (B)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/21/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var B = x === n;
                              } else
                                var B = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/21/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var K = F === n;
                    } else
                      var K = !0;
                    if (K) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/21/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "runSql")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/21/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "runSql"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var K = F === n;
                      } else
                        var K = !0;
                      if (K)
                        if (e.sql !== void 0) {
                          const f = n;
                          Ee(e.sql, {
                            instancePath: t + "/sql",
                            parentData: e,
                            parentDataProperty: "sql",
                            rootData: a
                          }) || (s = s === null ? Ee.errors : s.concat(
                            Ee.errors
                          ), n = s.length);
                          var K = f === n;
                        } else
                          var K = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/21/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "setSiteOptions") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.options === void 0 && (j = "options") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/22/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "options"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/22/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/22/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/22/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var X = re === n;
                            } else
                              var X = !0;
                            if (X)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/22/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var X = x === n;
                              } else
                                var X = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/22/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var pe = F === n;
                    } else
                      var pe = !0;
                    if (pe) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/22/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "setSiteOptions")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/22/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "setSiteOptions"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var pe = F === n;
                      } else
                        var pe = !0;
                      if (pe)
                        if (e.options !== void 0) {
                          let f = e.options;
                          const F = n;
                          if (n === F && !(f && typeof f == "object" && !Array.isArray(
                            f
                          )))
                            return b.errors = [
                              {
                                instancePath: t + "/options",
                                schemaPath: "#/oneOf/22/properties/options/type",
                                keyword: "type",
                                params: {
                                  type: "object"
                                },
                                message: "must be object"
                              }
                            ], !1;
                          var pe = F === n;
                        } else
                          var pe = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/22/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "unzip") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.extractToPath === void 0 && (j = "extractToPath") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/23/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "zipFile" || f === "zipPath" || f === "extractToPath"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/23/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/23/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/23/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var ge = re === n;
                            } else
                              var ge = !0;
                            if (ge)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/23/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var ge = x === n;
                              } else
                                var ge = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/23/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var he = F === n;
                    } else
                      var he = !0;
                    if (he) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/23/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "unzip")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/23/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "unzip"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var he = F === n;
                      } else
                        var he = !0;
                      if (he) {
                        if (e.zipFile !== void 0) {
                          const f = n;
                          Ee(
                            e.zipFile,
                            {
                              instancePath: t + "/zipFile",
                              parentData: e,
                              parentDataProperty: "zipFile",
                              rootData: a
                            }
                          ) || (s = s === null ? Ee.errors : s.concat(
                            Ee.errors
                          ), n = s.length);
                          var he = f === n;
                        } else
                          var he = !0;
                        if (he) {
                          if (e.zipPath !== void 0) {
                            const f = n;
                            if (typeof e.zipPath != "string")
                              return b.errors = [
                                {
                                  instancePath: t + "/zipPath",
                                  schemaPath: "#/oneOf/23/properties/zipPath/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var he = f === n;
                          } else
                            var he = !0;
                          if (he)
                            if (e.extractToPath !== void 0) {
                              const f = n;
                              if (typeof e.extractToPath != "string")
                                return b.errors = [
                                  {
                                    instancePath: t + "/extractToPath",
                                    schemaPath: "#/oneOf/23/properties/extractToPath/type",
                                    keyword: "type",
                                    params: {
                                      type: "string"
                                    },
                                    message: "must be string"
                                  }
                                ], !1;
                              var he = f === n;
                            } else
                              var he = !0;
                        }
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/23/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "updateUserMeta") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.meta === void 0 && (j = "meta") || e.step === void 0 && (j = "step") || e.userId === void 0 && (j = "userId"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/24/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "meta" || f === "userId"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/24/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/24/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/24/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var Be = re === n;
                            } else
                              var Be = !0;
                            if (Be)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/24/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var Be = x === n;
                              } else
                                var Be = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/24/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var ue = F === n;
                    } else
                      var ue = !0;
                    if (ue) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/24/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "updateUserMeta")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/24/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "updateUserMeta"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var ue = F === n;
                      } else
                        var ue = !0;
                      if (ue) {
                        if (e.meta !== void 0) {
                          let f = e.meta;
                          const F = n;
                          if (n === F && !(f && typeof f == "object" && !Array.isArray(
                            f
                          )))
                            return b.errors = [
                              {
                                instancePath: t + "/meta",
                                schemaPath: "#/oneOf/24/properties/meta/type",
                                keyword: "type",
                                params: {
                                  type: "object"
                                },
                                message: "must be object"
                              }
                            ], !1;
                          var ue = F === n;
                        } else
                          var ue = !0;
                        if (ue)
                          if (e.userId !== void 0) {
                            let f = e.userId;
                            const F = n;
                            if (!(typeof f == "number" && isFinite(
                              f
                            )))
                              return b.errors = [
                                {
                                  instancePath: t + "/userId",
                                  schemaPath: "#/oneOf/24/properties/userId/type",
                                  keyword: "type",
                                  params: {
                                    type: "number"
                                  },
                                  message: "must be number"
                                }
                              ], !1;
                            var ue = F === n;
                          } else
                            var ue = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/24/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "writeFile") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.data === void 0 && (j = "data") || e.path === void 0 && (j = "path") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/25/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "path" || f === "data"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/25/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/25/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/25/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var ht = re === n;
                            } else
                              var ht = !0;
                            if (ht)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/25/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var ht = x === n;
                              } else
                                var ht = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/25/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var rt = F === n;
                    } else
                      var rt = !0;
                    if (rt) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/25/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "writeFile")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/25/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "writeFile"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var rt = F === n;
                      } else
                        var rt = !0;
                      if (rt) {
                        if (e.path !== void 0) {
                          const f = n;
                          if (typeof e.path != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/path",
                                schemaPath: "#/oneOf/25/properties/path/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var rt = f === n;
                        } else
                          var rt = !0;
                        if (rt)
                          if (e.data !== void 0) {
                            let f = e.data;
                            const F = n, te = n;
                            let x = !1;
                            const re = n;
                            Ee(
                              f,
                              {
                                instancePath: t + "/data",
                                parentData: e,
                                parentDataProperty: "data",
                                rootData: a
                              }
                            ) || (s = s === null ? Ee.errors : s.concat(
                              Ee.errors
                            ), n = s.length);
                            var Ct = re === n;
                            if (x = x || Ct, !x) {
                              const xe = n;
                              if (typeof f != "string") {
                                const Ke = {
                                  instancePath: t + "/data",
                                  schemaPath: "#/oneOf/25/properties/data/anyOf/1/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                };
                                s === null ? s = [
                                  Ke
                                ] : s.push(
                                  Ke
                                ), n++;
                              }
                              var Ct = xe === n;
                              if (x = x || Ct, !x) {
                                const Ke = n;
                                if (n === Ke)
                                  if (f && typeof f == "object" && !Array.isArray(
                                    f
                                  )) {
                                    let Ue;
                                    if (f.BYTES_PER_ELEMENT === void 0 && (Ue = "BYTES_PER_ELEMENT") || f.buffer === void 0 && (Ue = "buffer") || f.byteLength === void 0 && (Ue = "byteLength") || f.byteOffset === void 0 && (Ue = "byteOffset") || f.length === void 0 && (Ue = "length")) {
                                      const Bt = {
                                        instancePath: t + "/data",
                                        schemaPath: "#/oneOf/25/properties/data/anyOf/2/required",
                                        keyword: "required",
                                        params: {
                                          missingProperty: Ue
                                        },
                                        message: "must have required property '" + Ue + "'"
                                      };
                                      s === null ? s = [
                                        Bt
                                      ] : s.push(
                                        Bt
                                      ), n++;
                                    } else {
                                      const Bt = n;
                                      for (const we in f)
                                        if (!(we === "BYTES_PER_ELEMENT" || we === "buffer" || we === "byteLength" || we === "byteOffset" || we === "length")) {
                                          let mt = f[we];
                                          const as = n;
                                          if (!(typeof mt == "number" && isFinite(
                                            mt
                                          ))) {
                                            const ze = {
                                              instancePath: t + "/data/" + we.replace(
                                                /~/g,
                                                "~0"
                                              ).replace(
                                                /\//g,
                                                "~1"
                                              ),
                                              schemaPath: "#/oneOf/25/properties/data/anyOf/2/additionalProperties/type",
                                              keyword: "type",
                                              params: {
                                                type: "number"
                                              },
                                              message: "must be number"
                                            };
                                            s === null ? s = [
                                              ze
                                            ] : s.push(
                                              ze
                                            ), n++;
                                          }
                                          var wi = as === n;
                                          if (!wi)
                                            break;
                                        }
                                      if (Bt === n) {
                                        if (f.BYTES_PER_ELEMENT !== void 0) {
                                          let we = f.BYTES_PER_ELEMENT;
                                          const mt = n;
                                          if (!(typeof we == "number" && isFinite(
                                            we
                                          ))) {
                                            const as = {
                                              instancePath: t + "/data/BYTES_PER_ELEMENT",
                                              schemaPath: "#/oneOf/25/properties/data/anyOf/2/properties/BYTES_PER_ELEMENT/type",
                                              keyword: "type",
                                              params: {
                                                type: "number"
                                              },
                                              message: "must be number"
                                            };
                                            s === null ? s = [
                                              as
                                            ] : s.push(
                                              as
                                            ), n++;
                                          }
                                          var nt = mt === n;
                                        } else
                                          var nt = !0;
                                        if (nt) {
                                          if (f.buffer !== void 0) {
                                            let we = f.buffer;
                                            const mt = n;
                                            if (n === mt)
                                              if (we && typeof we == "object" && !Array.isArray(
                                                we
                                              )) {
                                                let ze;
                                                if (we.byteLength === void 0 && (ze = "byteLength")) {
                                                  const os = {
                                                    instancePath: t + "/data/buffer",
                                                    schemaPath: "#/oneOf/25/properties/data/anyOf/2/properties/buffer/required",
                                                    keyword: "required",
                                                    params: {
                                                      missingProperty: ze
                                                    },
                                                    message: "must have required property '" + ze + "'"
                                                  };
                                                  s === null ? s = [
                                                    os
                                                  ] : s.push(
                                                    os
                                                  ), n++;
                                                } else {
                                                  const os = n;
                                                  for (const yn in we)
                                                    if (yn !== "byteLength") {
                                                      const _n = {
                                                        instancePath: t + "/data/buffer",
                                                        schemaPath: "#/oneOf/25/properties/data/anyOf/2/properties/buffer/additionalProperties",
                                                        keyword: "additionalProperties",
                                                        params: {
                                                          additionalProperty: yn
                                                        },
                                                        message: "must NOT have additional properties"
                                                      };
                                                      s === null ? s = [
                                                        _n
                                                      ] : s.push(
                                                        _n
                                                      ), n++;
                                                      break;
                                                    }
                                                  if (os === n && we.byteLength !== void 0) {
                                                    let yn = we.byteLength;
                                                    if (!(typeof yn == "number" && isFinite(
                                                      yn
                                                    ))) {
                                                      const _n = {
                                                        instancePath: t + "/data/buffer/byteLength",
                                                        schemaPath: "#/oneOf/25/properties/data/anyOf/2/properties/buffer/properties/byteLength/type",
                                                        keyword: "type",
                                                        params: {
                                                          type: "number"
                                                        },
                                                        message: "must be number"
                                                      };
                                                      s === null ? s = [
                                                        _n
                                                      ] : s.push(
                                                        _n
                                                      ), n++;
                                                    }
                                                  }
                                                }
                                              } else {
                                                const ze = {
                                                  instancePath: t + "/data/buffer",
                                                  schemaPath: "#/oneOf/25/properties/data/anyOf/2/properties/buffer/type",
                                                  keyword: "type",
                                                  params: {
                                                    type: "object"
                                                  },
                                                  message: "must be object"
                                                };
                                                s === null ? s = [
                                                  ze
                                                ] : s.push(
                                                  ze
                                                ), n++;
                                              }
                                            var nt = mt === n;
                                          } else
                                            var nt = !0;
                                          if (nt) {
                                            if (f.byteLength !== void 0) {
                                              let we = f.byteLength;
                                              const mt = n;
                                              if (!(typeof we == "number" && isFinite(
                                                we
                                              ))) {
                                                const ze = {
                                                  instancePath: t + "/data/byteLength",
                                                  schemaPath: "#/oneOf/25/properties/data/anyOf/2/properties/byteLength/type",
                                                  keyword: "type",
                                                  params: {
                                                    type: "number"
                                                  },
                                                  message: "must be number"
                                                };
                                                s === null ? s = [
                                                  ze
                                                ] : s.push(
                                                  ze
                                                ), n++;
                                              }
                                              var nt = mt === n;
                                            } else
                                              var nt = !0;
                                            if (nt) {
                                              if (f.byteOffset !== void 0) {
                                                let we = f.byteOffset;
                                                const mt = n;
                                                if (!(typeof we == "number" && isFinite(
                                                  we
                                                ))) {
                                                  const ze = {
                                                    instancePath: t + "/data/byteOffset",
                                                    schemaPath: "#/oneOf/25/properties/data/anyOf/2/properties/byteOffset/type",
                                                    keyword: "type",
                                                    params: {
                                                      type: "number"
                                                    },
                                                    message: "must be number"
                                                  };
                                                  s === null ? s = [
                                                    ze
                                                  ] : s.push(
                                                    ze
                                                  ), n++;
                                                }
                                                var nt = mt === n;
                                              } else
                                                var nt = !0;
                                              if (nt)
                                                if (f.length !== void 0) {
                                                  let we = f.length;
                                                  const mt = n;
                                                  if (!(typeof we == "number" && isFinite(
                                                    we
                                                  ))) {
                                                    const ze = {
                                                      instancePath: t + "/data/length",
                                                      schemaPath: "#/oneOf/25/properties/data/anyOf/2/properties/length/type",
                                                      keyword: "type",
                                                      params: {
                                                        type: "number"
                                                      },
                                                      message: "must be number"
                                                    };
                                                    s === null ? s = [
                                                      ze
                                                    ] : s.push(
                                                      ze
                                                    ), n++;
                                                  }
                                                  var nt = mt === n;
                                                } else
                                                  var nt = !0;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  } else {
                                    const Ue = {
                                      instancePath: t + "/data",
                                      schemaPath: "#/oneOf/25/properties/data/anyOf/2/type",
                                      keyword: "type",
                                      params: {
                                        type: "object"
                                      },
                                      message: "must be object"
                                    };
                                    s === null ? s = [
                                      Ue
                                    ] : s.push(
                                      Ue
                                    ), n++;
                                  }
                                var Ct = Ke === n;
                                x = x || Ct;
                              }
                            }
                            if (x)
                              n = te, s !== null && (te ? s.length = te : s = null);
                            else {
                              const xe = {
                                instancePath: t + "/data",
                                schemaPath: "#/oneOf/25/properties/data/anyOf",
                                keyword: "anyOf",
                                params: {},
                                message: "must match a schema in anyOf"
                              };
                              return s === null ? s = [
                                xe
                              ] : s.push(
                                xe
                              ), n++, b.errors = s, !1;
                            }
                            var rt = F === n;
                          } else
                            var rt = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/25/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "writeFiles") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.filesTree === void 0 && (j = "filesTree") || e.step === void 0 && (j = "step") || e.writeToPath === void 0 && (j = "writeToPath"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/26/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "writeToPath" || f === "filesTree"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/26/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/26/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/26/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var Mr = re === n;
                            } else
                              var Mr = !0;
                            if (Mr)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/26/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var Mr = x === n;
                              } else
                                var Mr = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/26/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var W = F === n;
                    } else
                      var W = !0;
                    if (W) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/26/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "writeFiles")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/26/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "writeFiles"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var W = F === n;
                      } else
                        var W = !0;
                      if (W) {
                        if (e.writeToPath !== void 0) {
                          const f = n;
                          if (typeof e.writeToPath != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/writeToPath",
                                schemaPath: "#/oneOf/26/properties/writeToPath/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var W = f === n;
                        } else
                          var W = !0;
                        if (W)
                          if (e.filesTree !== void 0) {
                            const f = n;
                            It(
                              e.filesTree,
                              {
                                instancePath: t + "/filesTree",
                                parentData: e,
                                parentDataProperty: "filesTree",
                                rootData: a
                              }
                            ) || (s = s === null ? It.errors : s.concat(
                              It.errors
                            ), n = s.length);
                            var W = f === n;
                          } else
                            var W = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/26/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "wp-cli") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.command === void 0 && (j = "command") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/27/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "command" || f === "wpCliPath"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/27/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/27/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/27/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var Y = re === n;
                            } else
                              var Y = !0;
                            if (Y)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/27/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var Y = x === n;
                              } else
                                var Y = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/27/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var q = F === n;
                    } else
                      var q = !0;
                    if (q) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/27/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "wp-cli")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/27/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "wp-cli"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var q = F === n;
                      } else
                        var q = !0;
                      if (q) {
                        if (e.command !== void 0) {
                          let f = e.command;
                          const F = n, te = n;
                          let x = !1;
                          const re = n;
                          if (typeof f != "string") {
                            const xe = {
                              instancePath: t + "/command",
                              schemaPath: "#/oneOf/27/properties/command/anyOf/0/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            };
                            s === null ? s = [xe] : s.push(xe), n++;
                          }
                          var J = re === n;
                          if (x = x || J, !x) {
                            const xe = n;
                            if (n === xe)
                              if (Array.isArray(
                                f
                              )) {
                                var ne = !0;
                                const Ke = f.length;
                                for (let Qt = 0; Qt < Ke; Qt++) {
                                  const Ue = n;
                                  if (typeof f[Qt] != "string") {
                                    const we = {
                                      instancePath: t + "/command/" + Qt,
                                      schemaPath: "#/oneOf/27/properties/command/anyOf/1/items/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    };
                                    s === null ? s = [
                                      we
                                    ] : s.push(
                                      we
                                    ), n++;
                                  }
                                  var ne = Ue === n;
                                  if (!ne)
                                    break;
                                }
                              } else {
                                const Ke = {
                                  instancePath: t + "/command",
                                  schemaPath: "#/oneOf/27/properties/command/anyOf/1/type",
                                  keyword: "type",
                                  params: {
                                    type: "array"
                                  },
                                  message: "must be array"
                                };
                                s === null ? s = [
                                  Ke
                                ] : s.push(
                                  Ke
                                ), n++;
                              }
                            var J = xe === n;
                            x = x || J;
                          }
                          if (x)
                            n = te, s !== null && (te ? s.length = te : s = null);
                          else {
                            const xe = {
                              instancePath: t + "/command",
                              schemaPath: "#/oneOf/27/properties/command/anyOf",
                              keyword: "anyOf",
                              params: {},
                              message: "must match a schema in anyOf"
                            };
                            return s === null ? s = [xe] : s.push(xe), n++, b.errors = s, !1;
                          }
                          var q = F === n;
                        } else
                          var q = !0;
                        if (q)
                          if (e.wpCliPath !== void 0) {
                            const f = n;
                            if (typeof e.wpCliPath != "string")
                              return b.errors = [
                                {
                                  instancePath: t + "/wpCliPath",
                                  schemaPath: "#/oneOf/27/properties/wpCliPath/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var q = f === n;
                          } else
                            var q = !0;
                      }
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/27/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else if (ce === "setSiteLanguage") {
            if (n === n)
              if (e && typeof e == "object" && !Array.isArray(e)) {
                let j;
                if (e.language === void 0 && (j = "language") || e.step === void 0 && (j = "step"))
                  return b.errors = [
                    {
                      instancePath: t,
                      schemaPath: "#/oneOf/28/required",
                      keyword: "required",
                      params: {
                        missingProperty: j
                      },
                      message: "must have required property '" + j + "'"
                    }
                  ], !1;
                {
                  const oe = n;
                  for (const f in e)
                    if (!(f === "progress" || f === "step" || f === "language"))
                      return b.errors = [
                        {
                          instancePath: t,
                          schemaPath: "#/oneOf/28/additionalProperties",
                          keyword: "additionalProperties",
                          params: {
                            additionalProperty: f
                          },
                          message: "must NOT have additional properties"
                        }
                      ], !1;
                  if (oe === n) {
                    if (e.progress !== void 0) {
                      let f = e.progress;
                      const F = n;
                      if (n === F)
                        if (f && typeof f == "object" && !Array.isArray(f)) {
                          const te = n;
                          for (const x in f)
                            if (!(x === "weight" || x === "caption"))
                              return b.errors = [
                                {
                                  instancePath: t + "/progress",
                                  schemaPath: "#/oneOf/28/properties/progress/additionalProperties",
                                  keyword: "additionalProperties",
                                  params: {
                                    additionalProperty: x
                                  },
                                  message: "must NOT have additional properties"
                                }
                              ], !1;
                          if (te === n) {
                            if (f.weight !== void 0) {
                              let x = f.weight;
                              const re = n;
                              if (!(typeof x == "number" && isFinite(
                                x
                              )))
                                return b.errors = [
                                  {
                                    instancePath: t + "/progress/weight",
                                    schemaPath: "#/oneOf/28/properties/progress/properties/weight/type",
                                    keyword: "type",
                                    params: {
                                      type: "number"
                                    },
                                    message: "must be number"
                                  }
                                ], !1;
                              var le = re === n;
                            } else
                              var le = !0;
                            if (le)
                              if (f.caption !== void 0) {
                                const x = n;
                                if (typeof f.caption != "string")
                                  return b.errors = [
                                    {
                                      instancePath: t + "/progress/caption",
                                      schemaPath: "#/oneOf/28/properties/progress/properties/caption/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var le = x === n;
                              } else
                                var le = !0;
                          }
                        } else
                          return b.errors = [
                            {
                              instancePath: t + "/progress",
                              schemaPath: "#/oneOf/28/properties/progress/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var de = F === n;
                    } else
                      var de = !0;
                    if (de) {
                      if (e.step !== void 0) {
                        let f = e.step;
                        const F = n;
                        if (typeof f != "string")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/28/properties/step/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        if (f !== "setSiteLanguage")
                          return b.errors = [
                            {
                              instancePath: t + "/step",
                              schemaPath: "#/oneOf/28/properties/step/const",
                              keyword: "const",
                              params: {
                                allowedValue: "setSiteLanguage"
                              },
                              message: "must be equal to constant"
                            }
                          ], !1;
                        var de = F === n;
                      } else
                        var de = !0;
                      if (de)
                        if (e.language !== void 0) {
                          const f = n;
                          if (typeof e.language != "string")
                            return b.errors = [
                              {
                                instancePath: t + "/language",
                                schemaPath: "#/oneOf/28/properties/language/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var de = f === n;
                        } else
                          var de = !0;
                    }
                  }
                }
              } else
                return b.errors = [
                  {
                    instancePath: t,
                    schemaPath: "#/oneOf/28/type",
                    keyword: "type",
                    params: { type: "object" },
                    message: "must be object"
                  }
                ], !1;
          } else
            return b.errors = [
              {
                instancePath: t,
                schemaPath: "#/discriminator",
                keyword: "discriminator",
                params: {
                  error: "mapping",
                  tag: "step",
                  tagValue: ce
                },
                message: 'value of tag "step" must be in oneOf'
              }
            ], !1;
        else
          return b.errors = [
            {
              instancePath: t,
              schemaPath: "#/discriminator",
              keyword: "discriminator",
              params: {
                error: "tag",
                tag: "step",
                tagValue: ce
              },
              message: 'tag "step" must be string'
            }
          ], !1;
      }
    } else
      return b.errors = [
        {
          instancePath: t,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ], !1;
  return b.errors = s, n === 0;
}
function me(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  if (n === 0)
    if (e && typeof e == "object" && !Array.isArray(e)) {
      const H = n;
      for (const k in e)
        if (!Qu.call(Ab.properties, k))
          return me.errors = [
            {
              instancePath: t,
              schemaPath: "#/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: k },
              message: "must NOT have additional properties"
            }
          ], !1;
      if (H === n) {
        if (e.landingPage !== void 0) {
          const k = n;
          if (typeof e.landingPage != "string")
            return me.errors = [
              {
                instancePath: t + "/landingPage",
                schemaPath: "#/properties/landingPage/type",
                keyword: "type",
                params: { type: "string" },
                message: "must be string"
              }
            ], !1;
          var o = k === n;
        } else
          var o = !0;
        if (o) {
          if (e.description !== void 0) {
            const k = n;
            if (typeof e.description != "string")
              return me.errors = [
                {
                  instancePath: t + "/description",
                  schemaPath: "#/properties/description/type",
                  keyword: "type",
                  params: { type: "string" },
                  message: "must be string"
                }
              ], !1;
            var o = k === n;
          } else
            var o = !0;
          if (o) {
            if (e.meta !== void 0) {
              let k = e.meta;
              const A = n;
              if (n === A)
                if (k && typeof k == "object" && !Array.isArray(k)) {
                  let S;
                  if (k.title === void 0 && (S = "title") || k.author === void 0 && (S = "author"))
                    return me.errors = [
                      {
                        instancePath: t + "/meta",
                        schemaPath: "#/properties/meta/required",
                        keyword: "required",
                        params: {
                          missingProperty: S
                        },
                        message: "must have required property '" + S + "'"
                      }
                    ], !1;
                  {
                    const P = n;
                    for (const I in k)
                      if (!(I === "title" || I === "description" || I === "author" || I === "categories"))
                        return me.errors = [
                          {
                            instancePath: t + "/meta",
                            schemaPath: "#/properties/meta/additionalProperties",
                            keyword: "additionalProperties",
                            params: {
                              additionalProperty: I
                            },
                            message: "must NOT have additional properties"
                          }
                        ], !1;
                    if (P === n) {
                      if (k.title !== void 0) {
                        const I = n;
                        if (typeof k.title != "string")
                          return me.errors = [
                            {
                              instancePath: t + "/meta/title",
                              schemaPath: "#/properties/meta/properties/title/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            }
                          ], !1;
                        var l = I === n;
                      } else
                        var l = !0;
                      if (l) {
                        if (k.description !== void 0) {
                          const I = n;
                          if (typeof k.description != "string")
                            return me.errors = [
                              {
                                instancePath: t + "/meta/description",
                                schemaPath: "#/properties/meta/properties/description/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          var l = I === n;
                        } else
                          var l = !0;
                        if (l) {
                          if (k.author !== void 0) {
                            const I = n;
                            if (typeof k.author != "string")
                              return me.errors = [
                                {
                                  instancePath: t + "/meta/author",
                                  schemaPath: "#/properties/meta/properties/author/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var l = I === n;
                          } else
                            var l = !0;
                          if (l)
                            if (k.categories !== void 0) {
                              let I = k.categories;
                              const $ = n;
                              if (n === $)
                                if (Array.isArray(
                                  I
                                )) {
                                  var p = !0;
                                  const U = I.length;
                                  for (let M = 0; M < U; M++) {
                                    const Z = n;
                                    if (typeof I[M] != "string")
                                      return me.errors = [
                                        {
                                          instancePath: t + "/meta/categories/" + M,
                                          schemaPath: "#/properties/meta/properties/categories/items/type",
                                          keyword: "type",
                                          params: {
                                            type: "string"
                                          },
                                          message: "must be string"
                                        }
                                      ], !1;
                                    var p = Z === n;
                                    if (!p)
                                      break;
                                  }
                                } else
                                  return me.errors = [
                                    {
                                      instancePath: t + "/meta/categories",
                                      schemaPath: "#/properties/meta/properties/categories/type",
                                      keyword: "type",
                                      params: {
                                        type: "array"
                                      },
                                      message: "must be array"
                                    }
                                  ], !1;
                              var l = $ === n;
                            } else
                              var l = !0;
                        }
                      }
                    }
                  }
                } else
                  return me.errors = [
                    {
                      instancePath: t + "/meta",
                      schemaPath: "#/properties/meta/type",
                      keyword: "type",
                      params: { type: "object" },
                      message: "must be object"
                    }
                  ], !1;
              var o = A === n;
            } else
              var o = !0;
            if (o) {
              if (e.preferredVersions !== void 0) {
                let k = e.preferredVersions;
                const A = n;
                if (n === A)
                  if (k && typeof k == "object" && !Array.isArray(k)) {
                    let S;
                    if (k.php === void 0 && (S = "php") || k.wp === void 0 && (S = "wp"))
                      return me.errors = [
                        {
                          instancePath: t + "/preferredVersions",
                          schemaPath: "#/properties/preferredVersions/required",
                          keyword: "required",
                          params: {
                            missingProperty: S
                          },
                          message: "must have required property '" + S + "'"
                        }
                      ], !1;
                    {
                      const P = n;
                      for (const I in k)
                        if (!(I === "php" || I === "wp"))
                          return me.errors = [
                            {
                              instancePath: t + "/preferredVersions",
                              schemaPath: "#/properties/preferredVersions/additionalProperties",
                              keyword: "additionalProperties",
                              params: {
                                additionalProperty: I
                              },
                              message: "must NOT have additional properties"
                            }
                          ], !1;
                      if (P === n) {
                        if (k.php !== void 0) {
                          let I = k.php;
                          const $ = n, N = n;
                          let U = !1;
                          const M = n;
                          if (typeof I != "string") {
                            const Z = {
                              instancePath: t + "/preferredVersions/php",
                              schemaPath: "#/definitions/SupportedPHPVersion/type",
                              keyword: "type",
                              params: {
                                type: "string"
                              },
                              message: "must be string"
                            };
                            s === null ? s = [Z] : s.push(Z), n++;
                          }
                          if (!(I === "8.4" || I === "8.3" || I === "8.2" || I === "8.1" || I === "8.0" || I === "7.4" || I === "7.3" || I === "7.2")) {
                            const Z = {
                              instancePath: t + "/preferredVersions/php",
                              schemaPath: "#/definitions/SupportedPHPVersion/enum",
                              keyword: "enum",
                              params: {
                                allowedValues: Tb.enum
                              },
                              message: "must be equal to one of the allowed values"
                            };
                            s === null ? s = [Z] : s.push(Z), n++;
                          }
                          var c = M === n;
                          if (U = U || c, !U) {
                            const Z = n;
                            if (typeof I != "string") {
                              const se = {
                                instancePath: t + "/preferredVersions/php",
                                schemaPath: "#/properties/preferredVersions/properties/php/anyOf/1/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              };
                              s === null ? s = [
                                se
                              ] : s.push(
                                se
                              ), n++;
                            }
                            if (I !== "latest") {
                              const se = {
                                instancePath: t + "/preferredVersions/php",
                                schemaPath: "#/properties/preferredVersions/properties/php/anyOf/1/const",
                                keyword: "const",
                                params: {
                                  allowedValue: "latest"
                                },
                                message: "must be equal to constant"
                              };
                              s === null ? s = [
                                se
                              ] : s.push(
                                se
                              ), n++;
                            }
                            var c = Z === n;
                            U = U || c;
                          }
                          if (U)
                            n = N, s !== null && (N ? s.length = N : s = null);
                          else {
                            const Z = {
                              instancePath: t + "/preferredVersions/php",
                              schemaPath: "#/properties/preferredVersions/properties/php/anyOf",
                              keyword: "anyOf",
                              params: {},
                              message: "must match a schema in anyOf"
                            };
                            return s === null ? s = [Z] : s.push(Z), n++, me.errors = s, !1;
                          }
                          var m = $ === n;
                        } else
                          var m = !0;
                        if (m)
                          if (k.wp !== void 0) {
                            const I = n;
                            if (typeof k.wp != "string")
                              return me.errors = [
                                {
                                  instancePath: t + "/preferredVersions/wp",
                                  schemaPath: "#/properties/preferredVersions/properties/wp/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                }
                              ], !1;
                            var m = I === n;
                          } else
                            var m = !0;
                      }
                    }
                  } else
                    return me.errors = [
                      {
                        instancePath: t + "/preferredVersions",
                        schemaPath: "#/properties/preferredVersions/type",
                        keyword: "type",
                        params: { type: "object" },
                        message: "must be object"
                      }
                    ], !1;
                var o = A === n;
              } else
                var o = !0;
              if (o) {
                if (e.features !== void 0) {
                  let k = e.features;
                  const A = n;
                  if (n === A)
                    if (k && typeof k == "object" && !Array.isArray(k)) {
                      const S = n;
                      for (const P in k)
                        if (!(P === "intl" || P === "networking"))
                          return me.errors = [
                            {
                              instancePath: t + "/features",
                              schemaPath: "#/properties/features/additionalProperties",
                              keyword: "additionalProperties",
                              params: {
                                additionalProperty: P
                              },
                              message: "must NOT have additional properties"
                            }
                          ], !1;
                      if (S === n) {
                        if (k.intl !== void 0) {
                          const P = n;
                          if (typeof k.intl != "boolean")
                            return me.errors = [
                              {
                                instancePath: t + "/features/intl",
                                schemaPath: "#/properties/features/properties/intl/type",
                                keyword: "type",
                                params: {
                                  type: "boolean"
                                },
                                message: "must be boolean"
                              }
                            ], !1;
                          var h = P === n;
                        } else
                          var h = !0;
                        if (h)
                          if (k.networking !== void 0) {
                            const P = n;
                            if (typeof k.networking != "boolean")
                              return me.errors = [
                                {
                                  instancePath: t + "/features/networking",
                                  schemaPath: "#/properties/features/properties/networking/type",
                                  keyword: "type",
                                  params: {
                                    type: "boolean"
                                  },
                                  message: "must be boolean"
                                }
                              ], !1;
                            var h = P === n;
                          } else
                            var h = !0;
                      }
                    } else
                      return me.errors = [
                        {
                          instancePath: t + "/features",
                          schemaPath: "#/properties/features/type",
                          keyword: "type",
                          params: { type: "object" },
                          message: "must be object"
                        }
                      ], !1;
                  var o = A === n;
                } else
                  var o = !0;
                if (o) {
                  if (e.extraLibraries !== void 0) {
                    let k = e.extraLibraries;
                    const A = n;
                    if (n === A)
                      if (Array.isArray(k)) {
                        var g = !0;
                        const S = k.length;
                        for (let P = 0; P < S; P++) {
                          let I = k[P];
                          const $ = n;
                          if (typeof I != "string")
                            return me.errors = [
                              {
                                instancePath: t + "/extraLibraries/" + P,
                                schemaPath: "#/definitions/ExtraLibrary/type",
                                keyword: "type",
                                params: {
                                  type: "string"
                                },
                                message: "must be string"
                              }
                            ], !1;
                          if (I !== "wp-cli")
                            return me.errors = [
                              {
                                instancePath: t + "/extraLibraries/" + P,
                                schemaPath: "#/definitions/ExtraLibrary/const",
                                keyword: "const",
                                params: {
                                  allowedValue: "wp-cli"
                                },
                                message: "must be equal to constant"
                              }
                            ], !1;
                          var g = $ === n;
                          if (!g)
                            break;
                        }
                      } else
                        return me.errors = [
                          {
                            instancePath: t + "/extraLibraries",
                            schemaPath: "#/properties/extraLibraries/type",
                            keyword: "type",
                            params: {
                              type: "array"
                            },
                            message: "must be array"
                          }
                        ], !1;
                    var o = A === n;
                  } else
                    var o = !0;
                  if (o) {
                    if (e.constants !== void 0) {
                      let k = e.constants;
                      const A = n;
                      if (n === n)
                        if (k && typeof k == "object" && !Array.isArray(k))
                          for (const P in k) {
                            let I = k[P];
                            const $ = n;
                            if (typeof I != "string" && typeof I != "boolean" && !(typeof I == "number" && isFinite(I)))
                              return me.errors = [
                                {
                                  instancePath: t + "/constants/" + P.replace(
                                    /~/g,
                                    "~0"
                                  ).replace(
                                    /\//g,
                                    "~1"
                                  ),
                                  schemaPath: "#/definitions/PHPConstants/additionalProperties/type",
                                  keyword: "type",
                                  params: {
                                    type: Ob.additionalProperties.type
                                  },
                                  message: "must be string,boolean,number"
                                }
                              ], !1;
                            var R = $ === n;
                            if (!R)
                              break;
                          }
                        else
                          return me.errors = [
                            {
                              instancePath: t + "/constants",
                              schemaPath: "#/definitions/PHPConstants/type",
                              keyword: "type",
                              params: {
                                type: "object"
                              },
                              message: "must be object"
                            }
                          ], !1;
                      var o = A === n;
                    } else
                      var o = !0;
                    if (o) {
                      if (e.plugins !== void 0) {
                        let k = e.plugins;
                        const A = n;
                        if (n === A)
                          if (Array.isArray(k)) {
                            var y = !0;
                            const S = k.length;
                            for (let P = 0; P < S; P++) {
                              let I = k[P];
                              const $ = n, N = n;
                              let U = !1;
                              const M = n;
                              if (typeof I != "string") {
                                const z = {
                                  instancePath: t + "/plugins/" + P,
                                  schemaPath: "#/properties/plugins/items/anyOf/0/type",
                                  keyword: "type",
                                  params: {
                                    type: "string"
                                  },
                                  message: "must be string"
                                };
                                s === null ? s = [
                                  z
                                ] : s.push(
                                  z
                                ), n++;
                              }
                              var _ = M === n;
                              if (U = U || _, !U) {
                                const z = n;
                                Ee(
                                  I,
                                  {
                                    instancePath: t + "/plugins/" + P,
                                    parentData: k,
                                    parentDataProperty: P,
                                    rootData: a
                                  }
                                ) || (s = s === null ? Ee.errors : s.concat(
                                  Ee.errors
                                ), n = s.length);
                                var _ = z === n;
                                U = U || _;
                              }
                              if (U)
                                n = N, s !== null && (N ? s.length = N : s = null);
                              else {
                                const z = {
                                  instancePath: t + "/plugins/" + P,
                                  schemaPath: "#/properties/plugins/items/anyOf",
                                  keyword: "anyOf",
                                  params: {},
                                  message: "must match a schema in anyOf"
                                };
                                return s === null ? s = [
                                  z
                                ] : s.push(
                                  z
                                ), n++, me.errors = s, !1;
                              }
                              var y = $ === n;
                              if (!y)
                                break;
                            }
                          } else
                            return me.errors = [
                              {
                                instancePath: t + "/plugins",
                                schemaPath: "#/properties/plugins/type",
                                keyword: "type",
                                params: {
                                  type: "array"
                                },
                                message: "must be array"
                              }
                            ], !1;
                        var o = A === n;
                      } else
                        var o = !0;
                      if (o) {
                        if (e.siteOptions !== void 0) {
                          let k = e.siteOptions;
                          const A = n;
                          if (n === A)
                            if (k && typeof k == "object" && !Array.isArray(
                              k
                            )) {
                              const S = n;
                              for (const P in k)
                                if (P !== "blogname") {
                                  const I = n;
                                  if (typeof k[P] != "string")
                                    return me.errors = [
                                      {
                                        instancePath: t + "/siteOptions/" + P.replace(
                                          /~/g,
                                          "~0"
                                        ).replace(
                                          /\//g,
                                          "~1"
                                        ),
                                        schemaPath: "#/properties/siteOptions/additionalProperties/type",
                                        keyword: "type",
                                        params: {
                                          type: "string"
                                        },
                                        message: "must be string"
                                      }
                                    ], !1;
                                  var w = I === n;
                                  if (!w)
                                    break;
                                }
                              if (S === n && k.blogname !== void 0 && typeof k.blogname != "string")
                                return me.errors = [
                                  {
                                    instancePath: t + "/siteOptions/blogname",
                                    schemaPath: "#/properties/siteOptions/properties/blogname/type",
                                    keyword: "type",
                                    params: {
                                      type: "string"
                                    },
                                    message: "must be string"
                                  }
                                ], !1;
                            } else
                              return me.errors = [
                                {
                                  instancePath: t + "/siteOptions",
                                  schemaPath: "#/properties/siteOptions/type",
                                  keyword: "type",
                                  params: {
                                    type: "object"
                                  },
                                  message: "must be object"
                                }
                              ], !1;
                          var o = A === n;
                        } else
                          var o = !0;
                        if (o) {
                          if (e.login !== void 0) {
                            let k = e.login;
                            const A = n, L = n;
                            let S = !1;
                            const P = n;
                            if (typeof k != "boolean") {
                              const $ = {
                                instancePath: t + "/login",
                                schemaPath: "#/properties/login/anyOf/0/type",
                                keyword: "type",
                                params: {
                                  type: "boolean"
                                },
                                message: "must be boolean"
                              };
                              s === null ? s = [
                                $
                              ] : s.push(
                                $
                              ), n++;
                            }
                            var C = P === n;
                            if (S = S || C, !S) {
                              const $ = n;
                              if (n === $)
                                if (k && typeof k == "object" && !Array.isArray(
                                  k
                                )) {
                                  let U;
                                  if (k.username === void 0 && (U = "username") || k.password === void 0 && (U = "password")) {
                                    const M = {
                                      instancePath: t + "/login",
                                      schemaPath: "#/properties/login/anyOf/1/required",
                                      keyword: "required",
                                      params: {
                                        missingProperty: U
                                      },
                                      message: "must have required property '" + U + "'"
                                    };
                                    s === null ? s = [
                                      M
                                    ] : s.push(
                                      M
                                    ), n++;
                                  } else {
                                    const M = n;
                                    for (const Z in k)
                                      if (!(Z === "username" || Z === "password")) {
                                        const z = {
                                          instancePath: t + "/login",
                                          schemaPath: "#/properties/login/anyOf/1/additionalProperties",
                                          keyword: "additionalProperties",
                                          params: {
                                            additionalProperty: Z
                                          },
                                          message: "must NOT have additional properties"
                                        };
                                        s === null ? s = [
                                          z
                                        ] : s.push(
                                          z
                                        ), n++;
                                        break;
                                      }
                                    if (M === n) {
                                      if (k.username !== void 0) {
                                        const Z = n;
                                        if (typeof k.username != "string") {
                                          const z = {
                                            instancePath: t + "/login/username",
                                            schemaPath: "#/properties/login/anyOf/1/properties/username/type",
                                            keyword: "type",
                                            params: {
                                              type: "string"
                                            },
                                            message: "must be string"
                                          };
                                          s === null ? s = [
                                            z
                                          ] : s.push(
                                            z
                                          ), n++;
                                        }
                                        var E = Z === n;
                                      } else
                                        var E = !0;
                                      if (E)
                                        if (k.password !== void 0) {
                                          const Z = n;
                                          if (typeof k.password != "string") {
                                            const se = {
                                              instancePath: t + "/login/password",
                                              schemaPath: "#/properties/login/anyOf/1/properties/password/type",
                                              keyword: "type",
                                              params: {
                                                type: "string"
                                              },
                                              message: "must be string"
                                            };
                                            s === null ? s = [
                                              se
                                            ] : s.push(
                                              se
                                            ), n++;
                                          }
                                          var E = Z === n;
                                        } else
                                          var E = !0;
                                    }
                                  }
                                } else {
                                  const U = {
                                    instancePath: t + "/login",
                                    schemaPath: "#/properties/login/anyOf/1/type",
                                    keyword: "type",
                                    params: {
                                      type: "object"
                                    },
                                    message: "must be object"
                                  };
                                  s === null ? s = [
                                    U
                                  ] : s.push(
                                    U
                                  ), n++;
                                }
                              var C = $ === n;
                              S = S || C;
                            }
                            if (S)
                              n = L, s !== null && (L ? s.length = L : s = null);
                            else {
                              const $ = {
                                instancePath: t + "/login",
                                schemaPath: "#/properties/login/anyOf",
                                keyword: "anyOf",
                                params: {},
                                message: "must match a schema in anyOf"
                              };
                              return s === null ? s = [
                                $
                              ] : s.push(
                                $
                              ), n++, me.errors = s, !1;
                            }
                            var o = A === n;
                          } else
                            var o = !0;
                          if (o) {
                            if (e.steps !== void 0) {
                              let k = e.steps;
                              const A = n;
                              if (n === A)
                                if (Array.isArray(
                                  k
                                )) {
                                  var D = !0;
                                  const S = k.length;
                                  for (let P = 0; P < S; P++) {
                                    let I = k[P];
                                    const $ = n, N = n;
                                    let U = !1;
                                    const M = n;
                                    b(
                                      I,
                                      {
                                        instancePath: t + "/steps/" + P,
                                        parentData: k,
                                        parentDataProperty: P,
                                        rootData: a
                                      }
                                    ) || (s = s === null ? b.errors : s.concat(
                                      b.errors
                                    ), n = s.length);
                                    var T = M === n;
                                    if (U = U || T, !U) {
                                      const z = n;
                                      if (typeof I != "string") {
                                        const G = {
                                          instancePath: t + "/steps/" + P,
                                          schemaPath: "#/properties/steps/items/anyOf/1/type",
                                          keyword: "type",
                                          params: {
                                            type: "string"
                                          },
                                          message: "must be string"
                                        };
                                        s === null ? s = [
                                          G
                                        ] : s.push(
                                          G
                                        ), n++;
                                      }
                                      var T = z === n;
                                      if (U = U || T, !U) {
                                        const G = n, Q = {
                                          instancePath: t + "/steps/" + P,
                                          schemaPath: "#/properties/steps/items/anyOf/2/not",
                                          keyword: "not",
                                          params: {},
                                          message: "must NOT be valid"
                                        };
                                        s === null ? s = [
                                          Q
                                        ] : s.push(
                                          Q
                                        ), n++;
                                        var T = G === n;
                                        if (U = U || T, !U) {
                                          const V = n;
                                          if (typeof I != "boolean") {
                                            const ie = {
                                              instancePath: t + "/steps/" + P,
                                              schemaPath: "#/properties/steps/items/anyOf/3/type",
                                              keyword: "type",
                                              params: {
                                                type: "boolean"
                                              },
                                              message: "must be boolean"
                                            };
                                            s === null ? s = [
                                              ie
                                            ] : s.push(
                                              ie
                                            ), n++;
                                          }
                                          if (I !== !1) {
                                            const ie = {
                                              instancePath: t + "/steps/" + P,
                                              schemaPath: "#/properties/steps/items/anyOf/3/const",
                                              keyword: "const",
                                              params: {
                                                allowedValue: !1
                                              },
                                              message: "must be equal to constant"
                                            };
                                            s === null ? s = [
                                              ie
                                            ] : s.push(
                                              ie
                                            ), n++;
                                          }
                                          var T = V === n;
                                          if (U = U || T, !U) {
                                            const ie = n;
                                            if (I !== null) {
                                              const Pe = {
                                                instancePath: t + "/steps/" + P,
                                                schemaPath: "#/properties/steps/items/anyOf/4/type",
                                                keyword: "type",
                                                params: {
                                                  type: "null"
                                                },
                                                message: "must be null"
                                              };
                                              s === null ? s = [
                                                Pe
                                              ] : s.push(
                                                Pe
                                              ), n++;
                                            }
                                            var T = ie === n;
                                            U = U || T;
                                          }
                                        }
                                      }
                                    }
                                    if (U)
                                      n = N, s !== null && (N ? s.length = N : s = null);
                                    else {
                                      const z = {
                                        instancePath: t + "/steps/" + P,
                                        schemaPath: "#/properties/steps/items/anyOf",
                                        keyword: "anyOf",
                                        params: {},
                                        message: "must match a schema in anyOf"
                                      };
                                      return s === null ? s = [
                                        z
                                      ] : s.push(
                                        z
                                      ), n++, me.errors = s, !1;
                                    }
                                    var D = $ === n;
                                    if (!D)
                                      break;
                                  }
                                } else
                                  return me.errors = [
                                    {
                                      instancePath: t + "/steps",
                                      schemaPath: "#/properties/steps/type",
                                      keyword: "type",
                                      params: {
                                        type: "array"
                                      },
                                      message: "must be array"
                                    }
                                  ], !1;
                              var o = A === n;
                            } else
                              var o = !0;
                            if (o)
                              if (e.$schema !== void 0) {
                                const k = n;
                                if (typeof e.$schema != "string")
                                  return me.errors = [
                                    {
                                      instancePath: t + "/$schema",
                                      schemaPath: "#/properties/%24schema/type",
                                      keyword: "type",
                                      params: {
                                        type: "string"
                                      },
                                      message: "must be string"
                                    }
                                  ], !1;
                                var o = k === n;
                              } else
                                var o = !0;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else
      return me.errors = [
        {
          instancePath: t,
          schemaPath: "#/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object"
        }
      ], !1;
  return me.errors = s, n === 0;
}
function Ns(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: a = e } = {}) {
  let s = null, n = 0;
  return me(e, {
    instancePath: t,
    parentData: r,
    parentDataProperty: i,
    rootData: a
  }) || (s = s === null ? me.errors : s.concat(me.errors), n = s.length), Ns.errors = s, n === 0;
}
const { wpCLI: $b, ...dp } = Pb, Ib = {
  ...dp,
  "wp-cli": $b,
  importFile: dp.importWxr
};
class Db extends Error {
  constructor(t, r) {
    super(t), this.name = "InvalidBlueprintError", this.validationErrors = r;
  }
}
class Hb extends Error {
  constructor(t) {
    const { stepNumber: r, step: i, cause: a } = t, s = a instanceof Error ? a : new Error(String(a)), n = `Error when executing the blueprint step #${r}`, o = s.message ? `${n}: ${s.message}` : n;
    super(o, { cause: s }), this.name = "BlueprintStepExecutionError", this.stepNumber = r, this.step = i, this.messages = (s.message || "").split(`
`).map((l) => l.trim()).filter(Boolean);
  }
}
async function td(e, t = {}) {
  const r = {
    ...t
  };
  let i;
  return rd(e) ? (i = await Fb(e), r.streamBundledFile = function(...a) {
    return e.read(...a);
  }) : i = e, Bb(i, r);
}
function rd(e) {
  return e && "read" in e && typeof e.read == "function";
}
async function Fb(e) {
  if (!rd(e))
    return e;
  const r = await (await e.read("blueprint.json")).text();
  return JSON.parse(r);
}
function Bb(e, {
  progress: t = new si(),
  semaphore: r = new cn({ concurrency: 3 }),
  onStepCompleted: i = () => {
  },
  onBlueprintValidated: a = () => {
  },
  corsProxy: s,
  streamBundledFile: n,
  gitAdditionalHeadersCallback: o,
  additionalSteps: l
} = {}) {
  var y, _, w, C, E, D, T, H, k, A;
  e = structuredClone(e), e = {
    ...e,
    steps: (e.steps || []).filter(Wb).filter(Mb)
  }, e.steps = [...e.steps || [], ...l || []];
  for (const L of e.steps)
    !L || typeof L != "object" || (L.step === "importFile" ? (L.step = "importWxr", Te.warn(
      'The "importFile" step is deprecated. Use "importWxr" instead.'
    )) : (L == null ? void 0 : L.step) === "installPlugin" && "pluginZipFile" in L ? (L.pluginData = L.pluginZipFile, Te.warn(
      'The "pluginZipFile" option of the "installPlugin" step is deprecated. Use "pluginData" instead.'
    )) : (L == null ? void 0 : L.step) === "installTheme" && "themeZipFile" in L && (L.themeData = L.themeZipFile, Te.warn(
      'The "themeZipFile" option of the "installTheme" step is deprecated. Use "themeData" instead.'
    )));
  if (e.constants && e.steps.unshift({
    step: "defineWpConfigConsts",
    consts: e.constants
  }), e.siteOptions && e.steps.unshift({
    step: "setSiteOptions",
    options: e.siteOptions
  }), e.plugins) {
    const L = e.plugins.map((S) => typeof S == "string" ? S.startsWith("https://") ? {
      resource: "url",
      url: S
    } : {
      resource: "wordpress.org/plugins",
      slug: S
    } : S).map((S) => ({
      step: "installPlugin",
      pluginData: S
    }));
    e.steps.unshift(...L);
  }
  e.login && e.steps.unshift({
    step: "login",
    ...e.login === !0 ? { username: "admin" } : e.login
  });
  const p = ((y = e.steps) == null ? void 0 : y.findIndex(
    (L) => typeof L == "object" && (L == null ? void 0 : L.step) && ["wp-cli", "enableMultisite"].includes(L.step)
  )) ?? -1;
  if ((_ = e == null ? void 0 : e.extraLibraries) != null && _.includes("wp-cli") || p !== -1) {
    const L = {
      step: "writeFile",
      data: sb,
      path: Lo
    };
    p === -1 ? (w = e.steps) == null || w.push(L) : (C = e.steps) == null || C.splice(
      p,
      0,
      L
    );
  }
  const c = (E = e.steps) == null ? void 0 : E.findIndex(
    (L) => typeof L == "object" && (L == null ? void 0 : L.step) === "importWxr"
  );
  c !== void 0 && c > -1 && ((D = e.steps) == null || D.splice(c, 0, {
    step: "installPlugin",
    pluginData: {
      resource: "wordpress.org/plugins",
      slug: "wordpress-importer"
    }
  }));
  const m = jb(e);
  if (!m.valid) {
    const { errors: L } = m, S = Nb(e, L);
    throw new Db(
      `Invalid Blueprint: The Blueprint does not conform to the schema.

Found ${L.length} validation error(s):

${S}

Please review your Blueprint and fix these issues. Learn more about the Blueprint format: https://wordpress.github.io/wordpress-playground/blueprints/data-format`,
      L
    );
  }
  a(e);
  const h = e.steps || [], g = h.reduce(
    (L, S) => {
      var P;
      return L + (((P = S.progress) == null ? void 0 : P.weight) || 1);
    },
    0
  ), R = h.map(
    (L) => qb(L, {
      semaphore: r,
      rootProgressTracker: t,
      totalProgressWeight: g,
      corsProxy: s,
      streamBundledFile: n,
      gitAdditionalHeadersCallback: o
    })
  );
  return {
    versions: {
      php: Ub(
        (T = e.preferredVersions) == null ? void 0 : T.php,
        ro,
        Td
      ),
      wp: ((H = e.preferredVersions) == null ? void 0 : H.wp) || "latest"
    },
    features: {
      // Disable intl by default to reduce the transfer size
      intl: ((k = e.features) == null ? void 0 : k.intl) ?? !1,
      // Enable network access by default
      networking: ((A = e.features) == null ? void 0 : A.networking) ?? !0
    },
    extraLibraries: e.extraLibraries || [],
    run: async (L) => {
      try {
        for (const { resources: S } of R)
          for (const P of S)
            P.setPlayground(L), P.isAsync && P.resolve().catch(() => {
            });
        for (const [S, { run: P, step: I }] of Object.entries(R))
          try {
            const $ = await P(L);
            i($, I);
          } catch ($) {
            const N = Number(S) + 1;
            throw new Hb({
              stepNumber: N,
              step: I,
              cause: $
            });
          }
      } finally {
        try {
          const S = await L.pathToInternalUrl(e.landingPage || "/");
          await L.goTo(
            "/index.php?playground-redirection-handler&next=" + encodeURIComponent(S)
          );
        } catch {
        }
        t.finish();
      }
    }
  };
}
function Nb(e, t) {
  return t.map((r, i) => {
    var o;
    const a = r.instancePath || "/";
    let s = r.message || "validation failed", n = "";
    if (s.includes("must NOT have additional properties")) {
      const l = (o = r.params) == null ? void 0 : o.additionalProperty;
      if (l) {
        s = `has unexpected property "${l}"`;
        try {
          const p = a.split("/").filter(Boolean);
          let c = e;
          for (const m of p)
            c && typeof c == "object" && (c = c[m]);
          if (c && typeof c == "object") {
            const m = c[l], h = JSON.stringify(m);
            n = `
  "${l}": ${h}
  ${"^".repeat(
              l.length + 2
            )} This property is not recognized`;
          }
        } catch {
        }
      }
    } else
      try {
        const l = a.split("/").filter(Boolean);
        let p = e;
        for (const c of l)
          p && typeof p == "object" && (p = p[c]);
        if (p !== void 0) {
          const c = JSON.stringify(p, null, 2);
          n = `
  Value: ${c.length > 200 ? c.substring(0, 200) + "..." : c}`;
        }
      } catch {
      }
    return `${i + 1}. At path "${a}": ${s}${n}`;
  }).join(`

`);
}
function jb(e) {
  var a;
  const t = Ns(e);
  if (t)
    return { valid: t };
  const r = /* @__PURE__ */ new Set();
  for (const s of Ns.errors)
    s.schemaPath.startsWith("#/properties/steps/items/anyOf") || r.add(s.instancePath);
  return {
    valid: !1,
    errors: ((a = Ns.errors) == null ? void 0 : a.filter(
      (s) => !(s.schemaPath.startsWith(
        "#/properties/steps/items/anyOf"
      ) && r.has(s.instancePath))
    )) ?? []
  };
}
function Ub(e, t, r) {
  return e && t.includes(e) ? e : r;
}
function Wb(e) {
  return !!(typeof e == "object" && e);
}
function Mb(e) {
  return ["setPhpIniEntry", "request"].includes(e.step) ? (Te.warn(
    `The "${e.step}" Blueprint is no longer supported and you can remove it from your Blueprint.`
  ), !1) : !0;
}
function qb(e, {
  semaphore: t,
  rootProgressTracker: r,
  totalProgressWeight: i,
  corsProxy: a,
  streamBundledFile: s,
  gitAdditionalHeadersCallback: n
}) {
  var g;
  const o = r.stage(
    (((g = e.progress) == null ? void 0 : g.weight) || 1) / i
  ), l = {};
  for (const R of Object.keys(e)) {
    let y = e[R];
    Dw(y) && (y = Jt.create(y, {
      semaphore: t,
      corsProxy: a,
      streamBundledFile: s,
      gitAdditionalHeadersCallback: n
    })), l[R] = y;
  }
  const p = async (R) => {
    var y;
    try {
      return o.fillSlowly(), await Ib[e.step](
        R,
        await Kb(l),
        {
          tracker: o,
          initialCaption: (y = e.progress) == null ? void 0 : y.caption
        }
      );
    } finally {
      o.finish();
    }
  }, c = hp(l), m = hp(l).filter(
    (R) => R.isAsync
  ), h = 1 / (m.length + 1);
  for (const R of m)
    R.progress = o.stage(h);
  return { run: p, step: e, resources: c };
}
function hp(e) {
  const t = [];
  for (const r in e) {
    const i = e[r];
    i instanceof Jt && t.push(i);
  }
  return t;
}
async function Kb(e) {
  const t = {};
  for (const r in e) {
    const i = e[r];
    i instanceof Jt ? t[r] = await i.resolve() : t[r] = i;
  }
  return t;
}
async function zb(e, t) {
  await e.run(t);
}
async function Gb() {
  const e = (
    // @ts-ignore
    (await import("./blueprints-Dg6flSLH.js")).default
  );
  return new File([e], "blueprints.phar", {
    type: "application/zip"
  });
}
function Vb(e) {
  if (typeof e == "object" && "type" in e && ["inline-file", "file-reference"].includes(e.type))
    return e;
  if (!e)
    return {
      type: "inline-file",
      contents: "{}"
    };
  if (typeof e != "string")
    return {
      type: "inline-file",
      contents: JSON.stringify(e)
    };
  try {
    return JSON.parse(e), {
      type: "inline-file",
      contents: e
    };
  } catch {
    return {
      type: "file-reference",
      reference: e
    };
  }
}
async function pv(e) {
  var c, m;
  const t = e.cliArgs || [];
  for (const h of t)
    if (h.startsWith("--site-path="))
      throw new Error(
        "The --site-path CLI argument must not be provided. In Playground, it is always set to /wordpress."
      );
  t.push("--site-path=/wordpress"), t.find((h) => h.startsWith("--db-engine=")) || t.push("--db-engine=sqlite");
  const i = e.php, a = (e == null ? void 0 : e.onMessage) || (() => {
  }), s = await Gb();
  i.writeFile(
    "/tmp/blueprints.phar",
    new Uint8Array(await s.arrayBuffer())
  );
  const n = Vb(
    e.blueprint
  );
  let o = "";
  switch (n.type) {
    case "inline-file":
      i.writeFile(
        "/tmp/blueprint.json",
        n.contents
      ), o = "/tmp/blueprint.json";
      break;
    case "file-reference":
      o = n.reference;
      break;
  }
  const l = await i.onMessage(async (h) => {
    try {
      const g = typeof h == "string" ? JSON.parse(h) : h;
      if (!g)
        return;
      await new Promise((R) => setTimeout(R, 0)), g.type.startsWith("blueprint.") && await a(g);
    } catch (g) {
      Te.warn("Failed to parse message as JSON:", h, g);
    }
  });
  await (i == null ? void 0 : i.writeFile(
    "/tmp/run-blueprints.php",
    `<?php
function playground_http_client_factory() {
	return new WordPress\\HttpClient\\Client([
		// sockets transport is somehow faster than curl in Playground. Maybe
		// it uses a larger chunk size?
		'transport' => 'sockets',
	]);
}
playground_add_filter('blueprint.http_client', 'playground_http_client_factory');

function playground_on_blueprint_target_resolved() {
	post_message_to_js(json_encode([
		'type' => 'blueprint.target_resolved',
	]));
}
playground_add_filter('blueprint.target_resolved', 'playground_on_blueprint_target_resolved');

playground_add_filter('blueprint.resolved', 'playground_on_blueprint_resolved');
function playground_on_blueprint_resolved($blueprint) {
	$additional_blueprint_steps = json_decode(${xt(
      JSON.stringify(((c = e.blueprintOverrides) == null ? void 0 : c.additionalSteps) || [])
    )}, true);
	if(count($additional_blueprint_steps) > 0) {
		$blueprint['additionalStepsAfterExecution'] = array_merge(
			$blueprint['additionalStepsAfterExecution'] ?? [],
			$additional_blueprint_steps
		);
	}

	$wp_version_override = json_decode(${xt(
      JSON.stringify(((m = e.blueprintOverrides) == null ? void 0 : m.wordpressVersion) || null)
    )}, true);
	if($wp_version_override) {
		$blueprint['wordpressVersion'] = $wp_version_override;
	}
	return $blueprint;
}

function playground_progress_reporter() {
	class PlaygroundProgressReporter implements ProgressReporter {

		public function reportProgress(float $progress, string $caption): void {
			$this->writeJsonMessage([
				'type' => 'blueprint.progress',
				'progress' => round($progress, 2),
				'caption' => $caption
			]);
		}

		public function reportError(string $message, ?Throwable $exception = null): void {
			$errorData = [
				'type' => 'blueprint.error',
				'message' => $message
			];

			if ($exception) {
				$errorData['details'] = [
					'exception' => get_class($exception),
					'message' => $exception->getMessage(),
					'file' => $exception->getFile(),
					'line' => $exception->getLine(),
					'trace' => $exception->getTraceAsString()
				];
			}

			$this->writeJsonMessage($errorData);
		}

		public function reportCompletion(string $message): void {
			$this->writeJsonMessage([
				'type' => 'blueprint.completion',
				'message' => $message
			]);
		}

		public function close(): void {}

		private function writeJsonMessage(array $data): void {
			post_message_to_js(json_encode($data));
		}
	}
	return new PlaygroundProgressReporter();
}
playground_add_filter('blueprint.progress_reporter', 'playground_progress_reporter');
require( "/tmp/blueprints.phar" );
`
  ));
  const p = await i.cli([
    "/internal/shared/bin/php",
    "/tmp/run-blueprints.php",
    "exec",
    o,
    ...t
  ]);
  return p.finished.finally(l), p;
}
class Zb extends Error {
  constructor(t, r, i) {
    super(t, i), this.name = "BlueprintFetchError", this.url = r;
  }
}
async function cv(e) {
  let t;
  try {
    const r = await fetch(e, {
      credentials: "omit"
    });
    if (!r.ok)
      throw new Error(`Failed to fetch blueprint from ${e}`);
    t = await r.arrayBuffer();
  } catch (r) {
    throw new Zb(
      `Blueprint file could not be resolved from ${e}: ${r instanceof Error ? r.message : String(r)}`,
      e,
      { cause: r }
    );
  }
  try {
    const r = new TextDecoder().decode(t);
    return JSON.parse(r), new gw([
      new _w({
        "blueprint.json": r
      }),
      new ww({
        baseUrl: e
      })
    ]);
  } catch (r) {
    if (await Yb(t))
      return ri.fromArrayBuffer(t);
    throw new Error(
      `Blueprint file at ${e} is neither a valid JSON nor a ZIP file.`,
      { cause: r }
    );
  }
}
async function Yb(e) {
  if (e.byteLength < 4)
    return !1;
  const t = new Uint8Array(e, 0, 4);
  return t[0] === 80 && t[1] === 75 && t[2] === 3 && t[3] === 4;
}
async function Xb(e) {
  if ((await Rn.create(e)).getVersion() === 1) {
    const r = await td(
      e
    );
    return {
      wpVersion: r.versions.wp,
      phpVersion: r.versions.php,
      intl: r.features.intl,
      networking: r.features.networking,
      extraLibraries: r.extraLibraries,
      /*
       * Constants don't matter so much for temporary sites so let's
       * use an empty object here. We can't easily figure out which
       * additional constants were applied via playground.defineConstant()
       * at this stage anyway.
       *
       * This property is only relevant for stored sites to ensure they're
       * consistently applied across page reloads.
       */
      constants: {}
    };
  } else
    return {
      phpVersion: Lw,
      wpVersion: "latest",
      intl: !1,
      networking: !0,
      constants: {},
      extraLibraries: []
    };
}
function uv() {
}
const Jb = [], Qb = "127.0.0.1", ev = 4400;
class tv {
  constructor(t) {
    this.options = t;
  }
  async bootPlayground(t, r) {
    const {
      onBlueprintValidated: i,
      onBlueprintStepCompleted: a,
      corsProxy: s,
      gitAdditionalHeadersCallback: n,
      mounts: o,
      sapiName: l,
      scope: p,
      shouldInstallWordPress: c,
      sqliteDriverVersion: m,
      onClientConnected: h
    } = this.options, g = r.stage(0.5), R = r.stage(), y = this.options.blueprint || {}, _ = $p(
      t.contentWindow,
      t.ownerDocument.defaultView
    );
    await _.isConnected(), r.pipe(_);
    const w = await Xb(y);
    if (await _.onDownloadProgress(R.loadingListener), await _.boot({
      mounts: o,
      sapiName: l,
      scope: p ?? Math.random().toFixed(16),
      shouldInstallWordPress: c,
      phpVersion: w.phpVersion,
      wpVersion: w.wpVersion,
      withNetworking: w.networking,
      corsProxyUrl: s,
      sqliteDriverVersion: m
    }), await _.isReady(), R.finish(), wp(Te, _), h == null || h(_), (await Rn.create(y)).getVersion() === 1) {
      const E = await td(y, {
        progress: g,
        onStepCompleted: a,
        onBlueprintValidated: i,
        corsProxy: s,
        gitAdditionalHeadersCallback: n
      });
      await zb(E, _);
    }
    return w.networking && await _.prefetchUpdateChecks(), _;
  }
}
class rv {
  constructor(t) {
    this.options = t;
  }
  async bootPlayground(t, r) {
    const {
      blueprint: i,
      onClientConnected: a,
      corsProxy: s,
      mounts: n,
      sapiName: o,
      scope: l
    } = this.options, p = r.stage(0.25), c = r.stage(0.75), m = $p(
      t.contentWindow,
      t.ownerDocument.defaultView
    );
    return await m.isConnected(), r.pipe(m), await m.onDownloadProgress(p.loadingListener), await m.addEventListener(
      "blueprint.message",
      ({ message: h }) => {
        switch (h.type) {
          case "blueprint.target_resolved":
            break;
          case "blueprint.progress": {
            c.set(h.progress), c.setCaption(h.caption);
            break;
          }
          case "blueprint.error": {
            const g = "\x1B[31m", R = "\x1B[1m", y = "\x1B[0m";
            throw h.details ? Te.error(
              `${g}${R}Fatal error:${y} Uncaught ${h.details.exception}: ${h.details.message}
  at ${h.details.file}:${h.details.line}
` + (h.details.trace ? h.details.trace + `
` : "")
            ) : Te.error(
              `${g}${R}Error:${y} ${h.message}
`
            ), new Error(h.message);
          }
        }
      }
    ), await m.boot({
      mounts: n,
      sapiName: o,
      scope: l ?? Math.random().toFixed(16),
      corsProxyUrl: s,
      experimentalBlueprintsV2Runner: !0,
      // Pass the declaration directly â€“ the worker runs the V2 runner.
      blueprint: i
    }), await m.isReady(), p.finish(), wp(Te, m), a == null || a(m), m.goTo("/"), m;
  }
}
async function dv(e) {
  const {
    iframe: t,
    progressTracker: r = new si(),
    disableProgressBar: i
  } = e;
  let { remoteUrl: a } = e;
  iv(a), nv(t), a = av(a, {
    progressbar: !i,
    "blueprints-runner": e.experimentalBlueprintsV2Runner ? "v2" : "v1"
  }), r.setCaption("Preparing WordPress"), await new Promise((o) => {
    t.src = a, t.addEventListener("load", o, !1);
  });
  const n = await (e.experimentalBlueprintsV2Runner ? new rv(e) : new tv(e)).bootPlayground(t, r);
  return r.finish(), n;
}
function nv(e) {
  var t, r;
  (t = e.sandbox) != null && t.length && !((r = e.sandbox) != null && r.contains("allow-storage-access-by-user-activation")) && e.sandbox.add("allow-storage-access-by-user-activation");
}
const nd = "https://playground.wordpress.net", sv = `http://${Qb}:${ev}`, mp = [
  nd,
  sv,
  // An older origin that's still used by some plugins.
  "https://wasm.wordpress.net",
  // Allow hosting remote from same origin
  location.origin,
  // Allow hosting remote from the same origin as the client library.
  new URL(import.meta.url).origin,
  "http://localhost",
  "http://localhost:5400",
  "https://localhost",
  "http://127.0.0.1",
  "http://127.0.0.1:5400",
  "https://127.0.0.1",
  ...Jb
], sd = nd;
function iv(e) {
  const t = new URL(e, sd);
  if (!(mp.includes(t.origin) && t.pathname === "/remote.html"))
    throw new Error(
      `Invalid remote URL: ${t}. Expected remote URL to have a path of "/remote.html" based on one of the following origins:
 ${mp.join(
        `
`
      )}`
    );
}
function av(e, t) {
  const r = new URL(e, sd), i = new URLSearchParams(r.search);
  for (const [a, s] of Object.entries(t))
    if (s != null && s !== !1)
      if (Array.isArray(s))
        for (const n of s)
          i.append(a, n.toString());
      else
        i.set(a, s.toString());
  return r.search = i.toString(), r.toString();
}
export {
  Zb as BlueprintFetchError,
  $w as BlueprintFilesystemRequiredError,
  Rn as BlueprintReflection,
  Hb as BlueprintStepExecutionError,
  Db as InvalidBlueprintError,
  Td as LatestSupportedPHPVersion,
  ro as SupportedPHPVersions,
  lv as SupportedPHPVersionsList,
  Mu as activatePlugin,
  qu as activateTheme,
  td as compileBlueprint,
  td as compileBlueprintV1,
  ob as cp,
  Zu as defineSiteUrl,
  Co as defineWpConfigConsts,
  ab as enableMultisite,
  mb as exportWXR,
  Fb as getBlueprintDeclaration,
  Gb as getV2Runner,
  Yu as importThemeStarterContent,
  hb as importWordPressFiles,
  ub as importWxr,
  yb as installPlugin,
  _b as installTheme,
  rd as isBlueprintBundle,
  Wb as isStepDefinition,
  gb as login,
  fb as mkdir,
  lb as mv,
  xt as phpVar,
  ai as phpVars,
  Qw as request,
  wb as resetData,
  cv as resolveRemoteBlueprint,
  Xb as resolveRuntimeConfiguration,
  eo as rm,
  pb as rmdir,
  zb as runBlueprintSteps,
  zb as runBlueprintV1Steps,
  pv as runBlueprintV2,
  Zw as runPHP,
  Yw as runPHPWithOptions,
  Jw as runSql,
  bb as runWpInstallationWizard,
  ov as setPhpIniEntries,
  uv as setPluginProxyURL,
  kb as setSiteLanguage,
  zu as setSiteOptions,
  dv as startPlaygroundWeb,
  $o as unzip,
  nb as updateUserMeta,
  jb as validateBlueprint,
  Vu as wpCLI,
  Xu as wpContentFilesExcludedFromExport,
  Ro as writeFile,
  cb as writeFiles,
  vb as zipWpContent
};
